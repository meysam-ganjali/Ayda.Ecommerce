(function () {
	var m, w, t, e, s = [].slice,
		u = function (t, e) {
			return function () {
				return t.apply(e, arguments)
			}
		},
		r = {}.hasOwnProperty,
		a = function (t, e) {
			for (var i in e) r.call(e, i) && (t[i] = e[i]);

			function n() {
				this.constructor = t
			}
			return n.prototype = e.prototype, t.prototype = new n, t.__super__ = e.prototype, t
		},
		l = [].indexOf || function (t) {
			for (var e = 0, i = this.length; e < i; e++)
				if (e in this && this[e] === t) return e;
			return -1
		};
	w = window.Morris = {}, m = jQuery, w.EventEmitter = function () {
		function t() {}
		return t.prototype.on = function (t, e) {
			return null == this.handlers && (this.handlers = {}), null == this.handlers[t] && (this.handlers[t] = []), this.handlers[t].push(e), this
		}, t.prototype.fire = function () {
			var t, e, i, n, r, a, o;
			if (i = arguments[0], t = 2 <= arguments.length ? s.call(arguments, 1) : [], null != this.handlers && null != this.handlers[i]) {
				for (o = [], n = 0, r = (a = this.handlers[i]).length; n < r; n++) e = a[n], o.push(e.apply(null, t));
				return o
			}
		}, t
	}(), w.commas = function (t) {
		var e, i, n, r;
		return null != t ? (n = t < 0 ? "-" : "", e = Math.abs(t), n += (i = Math.floor(e).toFixed(0)).replace(/(?=(?:\d{3})+$)(?!^)/g, ","), (r = e.toString()).length > i.length && (n += r.slice(i.length)), n) : "-"
	}, w.pad2 = function (t) {
		return (t < 10 ? "0" : "") + t
	}, w.Grid = function (t) {
		function e(t) {
			this.resizeHandler = u(this.resizeHandler, this);
			var a = this;
			if ("string" == typeof t.element ? this.el = m(document.getElementById(t.element)) : this.el = m(t.element), null == this.el || 0 === this.el.length) throw new Error("Graph container element not found");
			"static" === this.el.css("position") && this.el.css("position", "relative"), this.options = m.extend({}, this.gridDefaults, this.defaults || {}, t), "string" == typeof this.options.units && (this.options.postUnits = t.units), this.raphael = new Raphael(this.el[0]), this.elementWidth = null, this.elementHeight = null, this.dirty = !1, this.selectFrom = null, this.init && this.init(), this.setData(this.options.data), this.el.bind("mousemove", function (t) {
				var e, i, n, r;
				return i = a.el.offset(), r = t.pageX - i.left, a.selectFrom ? (e = a.data[a.hitTest(Math.min(r, a.selectFrom))]._x, n = a.data[a.hitTest(Math.max(r, a.selectFrom))]._x - e, a.selectionRect.attr({
					x: e,
					width: n
				})) : a.fire("hovermove", r, t.pageY - i.top)
			}), this.el.bind("mouseleave", function (t) {
				return a.selectFrom && (a.selectionRect.hide(), a.selectFrom = null), a.fire("hoverout")
			}), this.el.bind("touchstart touchmove touchend", function (t) {
				var e, i;
				return i = t.originalEvent.touches[0] || t.originalEvent.changedTouches[0], e = a.el.offset(), a.fire("hovermove", i.pageX - e.left, i.pageY - e.top)
			}), this.el.bind("click", function (t) {
				var e;
				return e = a.el.offset(), a.fire("gridclick", t.pageX - e.left, t.pageY - e.top)
			}), this.options.rangeSelect && (this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({
				fill: this.options.rangeSelectColor,
				stroke: !1
			}).toBack().hide(), this.el.bind("mousedown", function (t) {
				var e;
				return e = a.el.offset(), a.startRange(t.pageX - e.left)
			}), this.el.bind("mouseup", function (t) {
				var e;
				return e = a.el.offset(), a.endRange(t.pageX - e.left), a.fire("hovermove", t.pageX - e.left, t.pageY - e.top)
			})), this.options.resize && m(window).bind("resize", function (t) {
				return null != a.timeoutId && window.clearTimeout(a.timeoutId), a.timeoutId = window.setTimeout(a.resizeHandler, 100)
			}), this.el.css("-webkit-tap-highlight-color", "rgba(0,0,0,0)"), this.postInit && this.postInit()
		}
		return a(e, t), e.prototype.gridDefaults = {
			dateFormat: null,
			axes: !0,
			grid: !0,
			gridLineColor: "#aaa",
			gridStrokeWidth: .5,
			gridTextColor: "#888",
			gridTextSize: 12,
			gridTextFamily: "sans-serif",
			gridTextWeight: "normal",
			hideHover: !1,
			yLabelFormat: null,
			xLabelAngle: 0,
			numLines: 5,
			padding: 25,
			parseTime: !0,
			postUnits: "",
			preUnits: "",
			ymax: "auto",
			ymin: "auto 0",
			goals: [],
			goalStrokeWidth: 1,
			goalLineColors: ["#666633", "#999966", "#cc6666", "#663333"],
			events: [],
			eventStrokeWidth: 1,
			eventLineColors: ["#005a04", "#ccffbb", "#3a5f0b", "#005502"],
			rangeSelect: null,
			rangeSelectColor: "#eef",
			resize: !1
		}, e.prototype.setData = function (n, t) {
			var r, a, o, e, i, s, l, h, u, d, c, f, p, g, m;
			return null == t && (t = !0), null == (this.options.data = n) || 0 === n.length ? (this.data = [], this.raphael.clear(), void(null != this.hover && this.hover.hide())) : (f = this.cumulative ? 0 : null, p = this.cumulative ? 0 : null, 0 < this.options.goals.length && (i = Math.min.apply(Math, this.options.goals), e = Math.max.apply(Math, this.options.goals), p = null != p ? Math.min(p, i) : i, f = null != f ? Math.max(f, e) : e), this.data = function () {
				var t, e, i;
				for (i = [], o = t = 0, e = n.length; t < e; o = ++t) l = n[o], (s = {
					src: l
				}).label = l[this.options.xkey], this.options.parseTime ? (s.x = w.parseDate(s.label), this.options.dateFormat ? s.label = this.options.dateFormat(s.x) : "number" == typeof s.label && (s.label = new Date(s.label).toString())) : (s.x = o, this.options.xLabelFormat && (s.label = this.options.xLabelFormat(s))), u = 0, s.y = function () {
					var t, e, i, n;
					for (i = this.options.ykeys, n = [], a = t = 0, e = i.length; t < e; a = ++t) c = i[a], "string" == typeof (g = l[c]) && (g = parseFloat(g)), null != g && "number" != typeof g && (g = null), null != g && (this.cumulative ? u += g : null != f ? (f = Math.max(g, f), p = Math.min(g, p)) : f = p = g), this.cumulative && null != u && (f = Math.max(u, f), p = Math.min(u, p)), n.push(g);
					return n
				}.call(this), i.push(s);
				return i
			}.call(this), this.options.parseTime && (this.data = this.data.sort(function (t, e) {
				return (t.x > e.x) - (e.x > t.x)
			})), this.xmin = this.data[0].x, this.xmax = this.data[this.data.length - 1].x, this.events = [], 0 < this.options.events.length && (this.options.parseTime ? this.events = function () {
				var t, e, i, n;
				for (n = [], t = 0, e = (i = this.options.events).length; t < e; t++) r = i[t], n.push(w.parseDate(r));
				return n
			}.call(this) : this.events = this.options.events, this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events)), this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events))), this.xmin === this.xmax && (this.xmin -= 1, this.xmax += 1), this.ymin = this.yboundary("min", p), this.ymax = this.yboundary("max", f), this.ymin === this.ymax && (p && (this.ymin -= 1), this.ymax += 1), !0 !== (m = this.options.axes) && "both" !== m && "y" !== m && !0 !== this.options.grid || (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin ? (this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines), this.ymin = Math.min(this.ymin, this.grid[0]), this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1])) : (h = (this.ymax - this.ymin) / (this.options.numLines - 1), this.grid = function () {
				var t, e, i;
				for (i = [], d = t = this.ymin, e = this.ymax; 0 < h ? t <= e : e <= t; d = t += h) i.push(d);
				return i
			}.call(this))), this.dirty = !0, t ? this.redraw() : void 0)
		}, e.prototype.yboundary = function (t, e) {
			var i, n;
			return "string" == typeof (i = this.options["y" + t]) ? "auto" === i.slice(0, 4) ? 5 < i.length ? (n = parseInt(i.slice(5), 10), null == e ? n : Math[t](e, n)) : null != e ? e : 0 : parseInt(i, 10) : i
		}, e.prototype.autoGridLines = function (t, e, i) {
			var n, r, a, o, s, l, h, u;
			return o = e - t, u = Math.floor(Math.log(o) / Math.log(10)), l = Math.pow(10, u), r = Math.floor(t / l) * l, n = Math.ceil(e / l) * l, s = (n - r) / (i - 1), 1 === l && 1 < s && Math.ceil(s) !== s && (s = Math.ceil(s), n = r + s * (i - 1)), r < 0 && 0 < n && (r = Math.floor(t / s) * s, n = Math.ceil(e / s) * s), s < 1 ? (a = Math.floor(Math.log(s) / Math.log(10)), function () {
				var t, e;
				for (e = [], h = t = r; 0 < s ? t <= n : n <= t; h = t += s) e.push(parseFloat(h.toFixed(1 - a)));
				return e
			}()) : function () {
				var t, e;
				for (e = [], h = t = r; 0 < s ? t <= n : n <= t; h = t += s) e.push(h);
				return e
			}()
		}, e.prototype._calc = function () {
			var t, r, e, n, i, a, o, s;
			if (i = this.el.width(), e = this.el.height(), (this.elementWidth !== i || this.elementHeight !== e || this.dirty) && (this.elementWidth = i, this.elementHeight = e, this.dirty = !1, this.left = this.options.padding, this.right = this.elementWidth - this.options.padding, this.top = this.options.padding, this.bottom = this.elementHeight - this.options.padding, !0 !== (o = this.options.axes) && "both" !== o && "y" !== o || (a = function () {
					var t, e, i, n;
					for (n = [], t = 0, e = (i = this.grid).length; t < e; t++) r = i[t], n.push(this.measureText(this.yAxisFormat(r)).width);
					return n
				}.call(this), this.left += Math.max.apply(Math, a)), !0 !== (s = this.options.axes) && "both" !== s && "x" !== s || (t = function () {
					var t, e, i;
					for (i = [], n = t = 0, e = this.data.length; 0 <= e ? t < e : e < t; n = 0 <= e ? ++t : --t) i.push(this.measureText(this.data[n].text, -this.options.xLabelAngle).height);
					return i
				}.call(this), this.bottom -= Math.max.apply(Math, t)), this.width = Math.max(1, this.right - this.left), this.height = Math.max(1, this.bottom - this.top), this.dx = this.width / (this.xmax - this.xmin), this.dy = this.height / (this.ymax - this.ymin), this.calc)) return this.calc()
		}, e.prototype.transY = function (t) {
			return this.bottom - (t - this.ymin) * this.dy
		}, e.prototype.transX = function (t) {
			return 1 === this.data.length ? (this.left + this.right) / 2 : this.left + (t - this.xmin) * this.dx
		}, e.prototype.redraw = function () {
			if (this.raphael.clear(), this._calc(), this.drawGrid(), this.drawGoals(), this.drawEvents(), this.draw) return this.draw()
		}, e.prototype.measureText = function (t, e) {
			var i, n;
			return null == e && (e = 0), i = (n = this.raphael.text(100, 100, t).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).rotate(e)).getBBox(), n.remove(), i
		}, e.prototype.yAxisFormat = function (t) {
			return this.yLabelFormat(t)
		}, e.prototype.yLabelFormat = function (t) {
			return "function" == typeof this.options.yLabelFormat ? this.options.yLabelFormat(t) : "" + this.options.preUnits + w.commas(t) + this.options.postUnits
		}, e.prototype.drawGrid = function () {
			var t, e, i, n, r, a, o, s;
			if (!1 !== this.options.grid || !0 === (r = this.options.axes) || "both" === r || "y" === r) {
				for (s = [], i = 0, n = (a = this.grid).length; i < n; i++) t = a[i], e = this.transY(t), !0 !== (o = this.options.axes) && "both" !== o && "y" !== o || this.drawYAxisLabel(this.left - this.options.padding / 2, e, this.yAxisFormat(t)), this.options.grid ? s.push(this.drawGridLine("M" + this.left + "," + e + "H" + (this.left + this.width))) : s.push(void 0);
				return s
			}
		}, e.prototype.drawGoals = function () {
			var t, e, i, n, r, a, o;
			for (o = [], i = n = 0, r = (a = this.options.goals).length; n < r; i = ++n) e = a[i], t = this.options.goalLineColors[i % this.options.goalLineColors.length], o.push(this.drawGoal(e, t));
			return o
		}, e.prototype.drawEvents = function () {
			var t, e, i, n, r, a, o;
			for (o = [], i = n = 0, r = (a = this.events).length; n < r; i = ++n) e = a[i], t = this.options.eventLineColors[i % this.options.eventLineColors.length], o.push(this.drawEvent(e, t));
			return o
		}, e.prototype.drawGoal = function (t, e) {
			return this.raphael.path("M" + this.left + "," + this.transY(t) + "H" + this.right).attr("stroke", e).attr("stroke-width", this.options.goalStrokeWidth)
		}, e.prototype.drawEvent = function (t, e) {
			return this.raphael.path("M" + this.transX(t) + "," + this.bottom + "V" + this.top).attr("stroke", e).attr("stroke-width", this.options.eventStrokeWidth)
		}, e.prototype.drawYAxisLabel = function (t, e, i) {
			return this.raphael.text(t, e, i).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor).attr("text-anchor", "end")
		}, e.prototype.drawGridLine = function (t) {
			return this.raphael.path(t).attr("stroke", this.options.gridLineColor).attr("stroke-width", this.options.gridStrokeWidth)
		}, e.prototype.startRange = function (t) {
			return this.hover.hide(), this.selectFrom = t, this.selectionRect.attr({
				x: t,
				width: 0
			}).show()
		}, e.prototype.endRange = function (t) {
			var e, i;
			if (this.selectFrom) return i = Math.min(this.selectFrom, t), e = Math.max(this.selectFrom, t), this.options.rangeSelect.call(this.el, {
				start: this.data[this.hitTest(i)].x,
				end: this.data[this.hitTest(e)].x
			}), this.selectFrom = null
		}, e.prototype.resizeHandler = function () {
			return this.timeoutId = null, this.raphael.setSize(this.el.width(), this.el.height()), this.redraw()
		}, e
	}(w.EventEmitter), w.parseDate = function (t) {
		var e, i, n, r, a, o, s, l, h, u, d;
		return "number" == typeof t ? t : (i = t.match(/^(\d+) Q(\d)$/), r = t.match(/^(\d+)-(\d+)$/), a = t.match(/^(\d+)-(\d+)-(\d+)$/), s = t.match(/^(\d+) W(\d+)$/), l = t.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+)(Z|([+-])(\d\d):?(\d\d))?$/), h = t.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+):(\d+(\.\d+)?)(Z|([+-])(\d\d):?(\d\d))?$/), i ? new Date(parseInt(i[1], 10), 3 * parseInt(i[2], 10) - 1, 1).getTime() : r ? new Date(parseInt(r[1], 10), parseInt(r[2], 10) - 1, 1).getTime() : a ? new Date(parseInt(a[1], 10), parseInt(a[2], 10) - 1, parseInt(a[3], 10)).getTime() : s ? (4 !== (u = new Date(parseInt(s[1], 10), 0, 1)).getDay() && u.setMonth(0, 1 + (4 - u.getDay() + 7) % 7), u.getTime() + 6048e5 * parseInt(s[2], 10)) : l ? l[6] ? (o = 0, "Z" !== l[6] && (o = 60 * parseInt(l[8], 10) + parseInt(l[9], 10), "+" === l[7] && (o = 0 - o)), Date.UTC(parseInt(l[1], 10), parseInt(l[2], 10) - 1, parseInt(l[3], 10), parseInt(l[4], 10), parseInt(l[5], 10) + o)) : new Date(parseInt(l[1], 10), parseInt(l[2], 10) - 1, parseInt(l[3], 10), parseInt(l[4], 10), parseInt(l[5], 10)).getTime() : h ? (d = parseFloat(h[6]), e = Math.floor(d), n = Math.round(1e3 * (d - e)), h[8] ? (o = 0, "Z" !== h[8] && (o = 60 * parseInt(h[10], 10) + parseInt(h[11], 10), "+" === h[9] && (o = 0 - o)), Date.UTC(parseInt(h[1], 10), parseInt(h[2], 10) - 1, parseInt(h[3], 10), parseInt(h[4], 10), parseInt(h[5], 10) + o, e, n)) : new Date(parseInt(h[1], 10), parseInt(h[2], 10) - 1, parseInt(h[3], 10), parseInt(h[4], 10), parseInt(h[5], 10), e, n).getTime()) : new Date(parseInt(t, 10), 0, 1).getTime())
	}, w.Hover = function () {
		function t(t) {
			null == t && (t = {}), this.options = m.extend({}, w.Hover.defaults, t), this.el = m("<div class='" + this.options.class + "'></div>"), this.el.hide(), this.options.parent.append(this.el)
		}
		return t.defaults = {
			class: "morris-hover morris-default-style"
		}, t.prototype.update = function (t, e, i) {
			return t ? (this.html(t), this.show(), this.moveTo(e, i)) : this.hide()
		}, t.prototype.html = function (t) {
			return this.el.html(t)
		}, t.prototype.moveTo = function (t, e) {
			var i, n, r, a, o, s;
			return o = this.options.parent.innerWidth(), a = this.options.parent.innerHeight(), n = this.el.outerWidth(), i = this.el.outerHeight(), r = Math.min(Math.max(0, t - n / 2), o - n), null != e ? (s = e - i - 10) < 0 && a < (s = e + 10) + i && (s = a / 2 - i / 2) : s = a / 2 - i / 2, this.el.css({
				left: r + "px",
				top: parseInt(s) + "px"
			})
		}, t.prototype.show = function () {
			return this.el.show()
		}, t.prototype.hide = function () {
			return this.el.hide()
		}, t
	}(), w.Line = function (t) {
		function e(t) {
			if (this.hilight = u(this.hilight, this), this.onHoverOut = u(this.onHoverOut, this), this.onHoverMove = u(this.onHoverMove, this), this.onGridClick = u(this.onGridClick, this), !(this instanceof w.Line)) return new w.Line(t);
			e.__super__.constructor.call(this, t)
		}
		return a(e, t), e.prototype.init = function () {
			if ("always" !== this.options.hideHover) return this.hover = new w.Hover({
				parent: this.el
			}), this.on("hovermove", this.onHoverMove), this.on("hoverout", this.onHoverOut), this.on("gridclick", this.onGridClick)
		}, e.prototype.defaults = {
			lineWidth: 3,
			pointSize: 4,
			lineColors: ["#0b62a4", "#7A92A3", "#4da74d", "#afd8f8", "#edc240", "#cb4b4b", "#9440ed"],
			pointStrokeWidths: [1],
			pointStrokeColors: ["#ffffff"],
			pointFillColors: [],
			smooth: !0,
			xLabels: "auto",
			xLabelFormat: null,
			xLabelMargin: 24,
			hideHover: !1
		}, e.prototype.calc = function () {
			return this.calcPoints(), this.generatePaths()
		}, e.prototype.calcPoints = function () {
			var r, a, t, e, i, n;
			for (n = [], t = 0, e = (i = this.data).length; t < e; t++)(r = i[t])._x = this.transX(r.x), r._y = function () {
				var t, e, i, n;
				for (n = [], t = 0, e = (i = r.y).length; t < e; t++) null != (a = i[t]) ? n.push(this.transY(a)) : n.push(a);
				return n
			}.call(this), n.push(r._ymax = Math.min.apply(Math, [this.bottom].concat(function () {
				var t, e, i, n;
				for (n = [], t = 0, e = (i = r._y).length; t < e; t++) null != (a = i[t]) && n.push(a);
				return n
			}())));
			return n
		}, e.prototype.hitTest = function (t) {
			var e, i, n, r;
			if (0 === this.data.length) return null;
			for (e = i = 0, n = (r = this.data.slice(1)).length; i < n && !(t < (r[e]._x + this.data[e]._x) / 2); e = ++i);
			return e
		}, e.prototype.onGridClick = function (t, e) {
			var i;
			return i = this.hitTest(t), this.fire("click", i, this.data[i].src, t, e)
		}, e.prototype.onHoverMove = function (t, e) {
			var i;
			return i = this.hitTest(t), this.displayHoverForRow(i)
		}, e.prototype.onHoverOut = function () {
			if (!1 !== this.options.hideHover) return this.displayHoverForRow(null)
		}, e.prototype.displayHoverForRow = function (t) {
			var e;
			return null != t ? ((e = this.hover).update.apply(e, this.hoverContentForRow(t)), this.hilight(t)) : (this.hover.hide(), this.hilight())
		}, e.prototype.hoverContentForRow = function (t) {
			var e, i, n, r, a, o, s;
			for (e = "<div class='morris-hover-row-label'>" + (n = this.data[t]).label + "</div>", i = a = 0, o = (s = n.y).length; a < o; i = ++a) r = s[i], e += "<div class='morris-hover-point' style='color: " + this.colorFor(n, i, "label") + "'>\n  " + this.options.labels[i] + ":\n  " + this.yLabelFormat(r) + "\n</div>";
			return "function" == typeof this.options.hoverCallback && (e = this.options.hoverCallback(t, this.options, e, n.src)), [e, n._x, n._ymax]
		}, e.prototype.generatePaths = function () {
			var r, a, o, s;
			return this.paths = function () {
				var t, e, i, n;
				for (n = [], a = t = 0, e = this.options.ykeys.length; 0 <= e ? t < e : e < t; a = 0 <= e ? ++t : --t) s = "boolean" == typeof this.options.smooth ? this.options.smooth : (i = this.options.ykeys[a], 0 <= l.call(this.options.smooth, i)), 1 < (r = function () {
					var t, e, i, n;
					for (n = [], t = 0, e = (i = this.data).length; t < e; t++) void 0 !== (o = i[t])._y[a] && n.push({
						x: o._x,
						y: o._y[a]
					});
					return n
				}.call(this)).length ? n.push(w.Line.createPath(r, s, this.bottom)) : n.push(null);
				return n
			}.call(this)
		}, e.prototype.draw = function () {
			var t;
			if (!0 !== (t = this.options.axes) && "both" !== t && "x" !== t || this.drawXAxis(), this.drawSeries(), !1 === this.options.hideHover) return this.displayHoverForRow(this.data.length - 1)
		}, e.prototype.drawXAxis = function () {
			var t, e, i, s, l, r, h, n, a, o, u = this;
			for (h = this.bottom + this.options.padding / 2, s = l = null, t = function (t, e) {
					var i, n, r, a, o;
					return o = (i = u.drawXAxisLabel(u.transX(e), h, t)).getBBox(), i.transform("r" + -u.options.xLabelAngle), n = i.getBBox(), i.transform("t0," + n.height / 2 + "..."), 0 !== u.options.xLabelAngle && (a = -.5 * o.width * Math.cos(u.options.xLabelAngle * Math.PI / 180), i.transform("t" + a + ",0...")), n = i.getBBox(), (null == l || l >= n.x + n.width || null != s && s >= n.x) && 0 <= n.x && n.x + n.width < u.el.width() ? (0 !== u.options.xLabelAngle && (r = 1.25 * u.options.gridTextSize / Math.sin(u.options.xLabelAngle * Math.PI / 180), s = n.x - r), l = n.x - u.options.xLabelMargin) : i.remove()
				}, (i = this.options.parseTime ? 1 === this.data.length && "auto" === this.options.xLabels ? [[this.data[0].label, this.data[0].x]] : w.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat) : function () {
					var t, e, i, n;
					for (n = [], t = 0, e = (i = this.data).length; t < e; t++) r = i[t], n.push([r.label, r.x]);
					return n
				}.call(this)).reverse(), o = [], n = 0, a = i.length; n < a; n++) e = i[n], o.push(t(e[0], e[1]));
			return o
		}, e.prototype.drawSeries = function () {
			var t, e, i, n, r, a;
			for (this.seriesPoints = [], t = e = n = this.options.ykeys.length - 1; n <= 0 ? e <= 0 : 0 <= e; t = n <= 0 ? ++e : --e) this._drawLineFor(t);
			for (a = [], t = i = r = this.options.ykeys.length - 1; r <= 0 ? i <= 0 : 0 <= i; t = r <= 0 ? ++i : --i) a.push(this._drawPointFor(t));
			return a
		}, e.prototype._drawPointFor = function (t) {
			var e, i, n, r, a, o;
			for (this.seriesPoints[t] = [], o = [], n = 0, r = (a = this.data).length; n < r; n++)(e = null) != (i = a[n])._y[t] && (e = this.drawLinePoint(i._x, i._y[t], this.colorFor(i, t, "point"), t)), o.push(this.seriesPoints[t].push(e));
			return o
		}, e.prototype._drawLineFor = function (t) {
			var e;
			if (null !== (e = this.paths[t])) return this.drawLinePath(e, this.colorFor(null, t, "line"), t)
		}, e.createPath = function (t, e, i) {
			var n, r, a, o, s, l, h, u, d, c;
			for (h = "", e && (a = w.Line.gradients(t)), u = {
					y: null
				}, o = d = 0, c = t.length; d < c; o = ++d) null != (n = t[o]).y && (null != u.y ? e ? (r = a[o], l = a[o - 1], s = (n.x - u.x) / 4, h += "C" + (u.x + s) + "," + Math.min(i, u.y + s * l) + "," + (n.x - s) + "," + Math.min(i, n.y - s * r) + "," + n.x + "," + n.y) : h += "L" + n.x + "," + n.y : e && null == a[o] || (h += "M" + n.x + "," + n.y)), u = n;
			return h
		}, e.gradients = function (t) {
			var e, i, n, r, a, o, s, l;
			for (i = function (t, e) {
					return (t.y - e.y) / (t.x - e.x)
				}, l = [], n = o = 0, s = t.length; o < s; n = ++o) null != (e = t[n]).y ? (r = t[n + 1] || {
				y: null
			}, null != (a = t[n - 1] || {
				y: null
			}).y && null != r.y ? l.push(i(a, r)) : null != a.y ? l.push(i(a, e)) : null != r.y ? l.push(i(e, r)) : l.push(null)) : l.push(null);
			return l
		}, e.prototype.hilight = function (t) {
			var e, i, n, r, a;
			if (null !== this.prevHilight && this.prevHilight !== t)
				for (e = i = 0, r = this.seriesPoints.length - 1; 0 <= r ? i <= r : r <= i; e = 0 <= r ? ++i : --i) this.seriesPoints[e][this.prevHilight] && this.seriesPoints[e][this.prevHilight].animate(this.pointShrinkSeries(e));
			if (null !== t && this.prevHilight !== t)
				for (e = n = 0, a = this.seriesPoints.length - 1; 0 <= a ? n <= a : a <= n; e = 0 <= a ? ++n : --n) this.seriesPoints[e][t] && this.seriesPoints[e][t].animate(this.pointGrowSeries(e));
			return this.prevHilight = t
		}, e.prototype.colorFor = function (t, e, i) {
			return "function" == typeof this.options.lineColors ? this.options.lineColors.call(this, t, e, i) : "point" === i && this.options.pointFillColors[e % this.options.pointFillColors.length] || this.options.lineColors[e % this.options.lineColors.length]
		}, e.prototype.drawXAxisLabel = function (t, e, i) {
			return this.raphael.text(t, e, i).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor)
		}, e.prototype.drawLinePath = function (t, e, i) {
			return this.raphael.path(t).attr("stroke", e).attr("stroke-width", this.lineWidthForSeries(i))
		}, e.prototype.drawLinePoint = function (t, e, i, n) {
			return this.raphael.circle(t, e, this.pointSizeForSeries(n)).attr("fill", i).attr("stroke-width", this.pointStrokeWidthForSeries(n)).attr("stroke", this.pointStrokeColorForSeries(n))
		}, e.prototype.pointStrokeWidthForSeries = function (t) {
			return this.options.pointStrokeWidths[t % this.options.pointStrokeWidths.length]
		}, e.prototype.pointStrokeColorForSeries = function (t) {
			return this.options.pointStrokeColors[t % this.options.pointStrokeColors.length]
		}, e.prototype.lineWidthForSeries = function (t) {
			return this.options.lineWidth instanceof Array ? this.options.lineWidth[t % this.options.lineWidth.length] : this.options.lineWidth
		}, e.prototype.pointSizeForSeries = function (t) {
			return this.options.pointSize instanceof Array ? this.options.pointSize[t % this.options.pointSize.length] : this.options.pointSize
		}, e.prototype.pointGrowSeries = function (t) {
			return Raphael.animation({
				r: this.pointSizeForSeries(t) + 3
			}, 25, "linear")
		}, e.prototype.pointShrinkSeries = function (t) {
			return Raphael.animation({
				r: this.pointSizeForSeries(t)
			}, 25, "linear")
		}, e
	}(w.Grid), w.labelSeries = function (t, e, i, n, r) {
		var a, o, s, l, h, u, d, c, f, p, g;
		if (s = 200 * (e - t) / i, o = new Date(t), void 0 === (d = w.LABEL_SPECS[n]))
			for (f = 0, p = (g = w.AUTO_LABEL_ORDER).length; f < p; f++)
				if (l = g[f], s >= (u = w.LABEL_SPECS[l]).span) {
					d = u;
					break
				} for (void 0 === d && (d = w.LABEL_SPECS.second), r && (d = m.extend({}, d, {
				fmt: r
			})), a = d.start(o), h = [];
			(c = a.getTime()) <= e;) t <= c && h.push([d.fmt(a), c]), d.incr(a);
		return h
	}, t = function (e) {
		return {
			span: 60 * e * 1e3,
			start: function (t) {
				return new Date(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours())
			},
			fmt: function (t) {
				return w.pad2(t.getHours()) + ":" + w.pad2(t.getMinutes())
			},
			incr: function (t) {
				return t.setUTCMinutes(t.getUTCMinutes() + e)
			}
		}
	}, e = function (e) {
		return {
			span: 1e3 * e,
			start: function (t) {
				return new Date(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes())
			},
			fmt: function (t) {
				return w.pad2(t.getHours()) + ":" + w.pad2(t.getMinutes()) + ":" + w.pad2(t.getSeconds())
			},
			incr: function (t) {
				return t.setUTCSeconds(t.getUTCSeconds() + e)
			}
		}
	}, w.LABEL_SPECS = {
		decade: {
			span: 1728e8,
			start: function (t) {
				return new Date(t.getFullYear() - t.getFullYear() % 10, 0, 1)
			},
			fmt: function (t) {
				return "" + t.getFullYear()
			},
			incr: function (t) {
				return t.setFullYear(t.getFullYear() + 10)
			}
		},
		year: {
			span: 1728e7,
			start: function (t) {
				return new Date(t.getFullYear(), 0, 1)
			},
			fmt: function (t) {
				return "" + t.getFullYear()
			},
			incr: function (t) {
				return t.setFullYear(t.getFullYear() + 1)
			}
		},
		month: {
			span: 24192e5,
			start: function (t) {
				return new Date(t.getFullYear(), t.getMonth(), 1)
			},
			fmt: function (t) {
				return t.getFullYear() + "-" + w.pad2(t.getMonth() + 1)
			},
			incr: function (t) {
				return t.setMonth(t.getMonth() + 1)
			}
		},
		week: {
			span: 6048e5,
			start: function (t) {
				return new Date(t.getFullYear(), t.getMonth(), t.getDate())
			},
			fmt: function (t) {
				return t.getFullYear() + "-" + w.pad2(t.getMonth() + 1) + "-" + w.pad2(t.getDate())
			},
			incr: function (t) {
				return t.setDate(t.getDate() + 7)
			}
		},
		day: {
			span: 864e5,
			start: function (t) {
				return new Date(t.getFullYear(), t.getMonth(), t.getDate())
			},
			fmt: function (t) {
				return t.getFullYear() + "-" + w.pad2(t.getMonth() + 1) + "-" + w.pad2(t.getDate())
			},
			incr: function (t) {
				return t.setDate(t.getDate() + 1)
			}
		},
		hour: t(60),
		"30min": t(30),
		"15min": t(15),
		"10min": t(10),
		"5min": t(5),
		minute: t(1),
		"30sec": e(30),
		"15sec": e(15),
		"10sec": e(10),
		"5sec": e(5),
		second: e(1)
	}, w.AUTO_LABEL_ORDER = ["decade", "year", "month", "week", "day", "hour", "30min", "15min", "10min", "5min", "minute", "30sec", "15sec", "10sec", "5sec", "second"], w.Area = function (t) {
		var i;

		function n(t) {
			var e;
			if (!(this instanceof w.Area)) return new w.Area(t);
			e = m.extend({}, i, t), this.cumulative = !e.behaveLikeLine, "auto" === e.fillOpacity && (e.fillOpacity = e.behaveLikeLine ? .8 : 1), n.__super__.constructor.call(this, e)
		}
		return a(n, t), i = {
			fillOpacity: "auto",
			behaveLikeLine: !1
		}, n.prototype.calcPoints = function () {
			var r, a, o, t, e, i, n;
			for (n = [], t = 0, e = (i = this.data).length; t < e; t++)(r = i[t])._x = this.transX(r.x), a = 0, r._y = function () {
				var t, e, i, n;
				for (n = [], t = 0, e = (i = r.y).length; t < e; t++) o = i[t], this.options.behaveLikeLine ? n.push(this.transY(o)) : (a += o || 0, n.push(this.transY(a)));
				return n
			}.call(this), n.push(r._ymax = Math.max.apply(Math, r._y));
			return n
		}, n.prototype.drawSeries = function () {
			var t, e, i, n, r, a, o, s;
			for (this.seriesPoints = [], s = [], i = 0, n = (e = this.options.behaveLikeLine ? function () {
					a = [];
					for (var t = 0, e = this.options.ykeys.length - 1; 0 <= e ? t <= e : e <= t; 0 <= e ? t++ : t--) a.push(t);
					return a
				}.apply(this) : function () {
					o = [];
					for (var t = r = this.options.ykeys.length - 1; r <= 0 ? t <= 0 : 0 <= t; r <= 0 ? t++ : t--) o.push(t);
					return o
				}.apply(this)).length; i < n; i++) t = e[i], this._drawFillFor(t), this._drawLineFor(t), s.push(this._drawPointFor(t));
			return s
		}, n.prototype._drawFillFor = function (t) {
			var e;
			if (null !== (e = this.paths[t])) return e = e + "L" + this.transX(this.xmax) + "," + this.bottom + "L" + this.transX(this.xmin) + "," + this.bottom + "Z", this.drawFilledPath(e, this.fillForSeries(t))
		}, n.prototype.fillForSeries = function (t) {
			var e;
			return e = Raphael.rgb2hsl(this.colorFor(this.data[t], t, "line")), Raphael.hsl(e.h, this.options.behaveLikeLine ? .9 * e.s : .75 * e.s, Math.min(.98, this.options.behaveLikeLine ? 1.2 * e.l : 1.25 * e.l))
		}, n.prototype.drawFilledPath = function (t, e) {
			return this.raphael.path(t).attr("fill", e).attr("fill-opacity", this.options.fillOpacity).attr("stroke", "none")
		}, n
	}(w.Line), w.Bar = function (t) {
		function e(t) {
			if (this.onHoverOut = u(this.onHoverOut, this), this.onHoverMove = u(this.onHoverMove, this), this.onGridClick = u(this.onGridClick, this), !(this instanceof w.Bar)) return new w.Bar(t);
			e.__super__.constructor.call(this, m.extend({}, t, {
				parseTime: !1
			}))
		}
		return a(e, t), e.prototype.init = function () {
			if (this.cumulative = this.options.stacked, "always" !== this.options.hideHover) return this.hover = new w.Hover({
				parent: this.el
			}), this.on("hovermove", this.onHoverMove), this.on("hoverout", this.onHoverOut), this.on("gridclick", this.onGridClick)
		}, e.prototype.defaults = {
			barSizeRatio: .75,
			barGap: 3,
			barColors: ["#0b62a4", "#7a92a3", "#4da74d", "#afd8f8", "#edc240", "#cb4b4b", "#9440ed"],
			barOpacity: 1,
			barRadius: [0, 0, 0, 0],
			xLabelMargin: 50
		}, e.prototype.calc = function () {
			var t;
			if (this.calcBars(), !1 === this.options.hideHover) return (t = this.hover).update.apply(t, this.hoverContentForRow(this.data.length - 1))
		}, e.prototype.calcBars = function () {
			var t, r, a, e, i, n, o;
			for (o = [], t = e = 0, i = (n = this.data).length; e < i; t = ++e)(r = n[t])._x = this.left + this.width * (t + .5) / this.data.length, o.push(r._y = function () {
				var t, e, i, n;
				for (n = [], t = 0, e = (i = r.y).length; t < e; t++) null != (a = i[t]) ? n.push(this.transY(a)) : n.push(null);
				return n
			}.call(this));
			return o
		}, e.prototype.draw = function () {
			var t;
			return !0 !== (t = this.options.axes) && "both" !== t && "x" !== t || this.drawXAxis(), this.drawSeries()
		}, e.prototype.drawXAxis = function () {
			var t, e, i, n, r, a, o, s, l, h, u, d, c;
			for (h = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2), a = o = null, c = [], t = u = 0, d = this.data.length; 0 <= d ? u < d : d < u; t = 0 <= d ? ++u : --u) s = this.data[this.data.length - 1 - t], l = (e = this.drawXAxisLabel(s._x, h, s.label)).getBBox(), e.transform("r" + -this.options.xLabelAngle), i = e.getBBox(), e.transform("t0," + i.height / 2 + "..."), 0 !== this.options.xLabelAngle && (r = -.5 * l.width * Math.cos(this.options.xLabelAngle * Math.PI / 180), e.transform("t" + r + ",0...")), (null == o || o >= i.x + i.width || null != a && a >= i.x) && 0 <= i.x && i.x + i.width < this.el.width() ? (0 !== this.options.xLabelAngle && (n = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180), a = i.x - n), c.push(o = i.x - this.options.xLabelMargin)) : c.push(e.remove());
			return c
		}, e.prototype.drawSeries = function () {
			var r, a, o, s, l, h, u, t, d, c, f, e, p, g, m;
			return o = this.width / this.options.data.length, t = this.options.stacked ? 1 : this.options.ykeys.length, r = (o * this.options.barSizeRatio - this.options.barGap * (t - 1)) / t, this.options.barSize && (r = Math.min(r, this.options.barSize)), e = o - r * t - this.options.barGap * (t - 1), u = e / 2, m = this.ymin <= 0 && 0 <= this.ymax ? this.transY(0) : null, this.bars = function () {
				var t, e, i, n;
				for (i = this.data, n = [], s = t = 0, e = i.length; t < e; s = ++t) d = i[s], l = 0, n.push(function () {
					var t, e, i, n;
					for (i = d._y, n = [], c = t = 0, e = i.length; t < e; c = ++t) null !== (g = i[c]) ? (a = m ? (p = Math.min(g, m), Math.max(g, m)) : (p = g, this.bottom), h = this.left + s * o + u, this.options.stacked || (h += c * (r + this.options.barGap)), f = a - p, this.options.verticalGridCondition && this.options.verticalGridCondition(d.x) && this.drawBar(this.left + s * o, this.top, o, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius), this.options.stacked && (p -= l), this.drawBar(h, p, r, f, this.colorFor(d, c, "bar"), this.options.barOpacity, this.options.barRadius), n.push(l += f)) : n.push(null);
					return n
				}.call(this));
				return n
			}.call(this)
		}, e.prototype.colorFor = function (t, e, i) {
			var n, r;
			return "function" == typeof this.options.barColors ? (n = {
				x: t.x,
				y: t.y[e],
				label: t.label
			}, r = {
				index: e,
				key: this.options.ykeys[e],
				label: this.options.labels[e]
			}, this.options.barColors.call(this, n, r, i)) : this.options.barColors[e % this.options.barColors.length]
		}, e.prototype.hitTest = function (t) {
			return 0 === this.data.length ? null : (t = Math.max(Math.min(t, this.right), this.left), Math.min(this.data.length - 1, Math.floor((t - this.left) / (this.width / this.data.length))))
		}, e.prototype.onGridClick = function (t, e) {
			var i;
			return i = this.hitTest(t), this.fire("click", i, this.data[i].src, t, e)
		}, e.prototype.onHoverMove = function (t, e) {
			var i, n;
			return i = this.hitTest(t), (n = this.hover).update.apply(n, this.hoverContentForRow(i))
		}, e.prototype.onHoverOut = function () {
			if (!1 !== this.options.hideHover) return this.hover.hide()
		}, e.prototype.hoverContentForRow = function (t) {
			var e, i, n, r, a, o, s;
			for (e = "<div class='morris-hover-row-label'>" + (n = this.data[t]).label + "</div>", i = a = 0, o = (s = n.y).length; a < o; i = ++a) r = s[i], e += "<div class='morris-hover-point' style='color: " + this.colorFor(n, i, "label") + "'>\n  " + this.options.labels[i] + ":\n  " + this.yLabelFormat(r) + "\n</div>";
			return "function" == typeof this.options.hoverCallback && (e = this.options.hoverCallback(t, this.options, e, n.src)), [e, this.left + (t + .5) * this.width / this.data.length]
		}, e.prototype.drawXAxisLabel = function (t, e, i) {
			return this.raphael.text(t, e, i).attr("font-size", this.options.gridTextSize).attr("font-family", this.options.gridTextFamily).attr("font-weight", this.options.gridTextWeight).attr("fill", this.options.gridTextColor)
		}, e.prototype.drawBar = function (t, e, i, n, r, a, o) {
			var s;
			return (0 === (s = Math.max.apply(Math, o)) || n < s ? this.raphael.rect(t, e, i, n) : this.raphael.path(this.roundedRect(t, e, i, n, o))).attr("fill", r).attr("fill-opacity", a).attr("stroke", "none")
		}, e.prototype.roundedRect = function (t, e, i, n, r) {
			return null == r && (r = [0, 0, 0, 0]), ["M", t, r[0] + e, "Q", t, e, t + r[0], e, "L", t + i - r[1], e, "Q", t + i, e, t + i, e + r[1], "L", t + i, e + n - r[2], "Q", t + i, e + n, t + i - r[2], e + n, "L", t + r[3], e + n, "Q", t, e + n, t, e + n - r[3], "Z"]
		}, e
	}(w.Grid), w.Donut = function (t) {
		function e(t) {
			this.resizeHandler = u(this.resizeHandler, this), this.select = u(this.select, this), this.click = u(this.click, this);
			var e = this;
			if (!(this instanceof w.Donut)) return new w.Donut(t);
			if (this.options = m.extend({}, this.defaults, t), "string" == typeof t.element ? this.el = m(document.getElementById(t.element)) : this.el = m(t.element), null === this.el || 0 === this.el.length) throw new Error("Graph placeholder not found.");
			void 0 !== t.data && 0 !== t.data.length && (this.raphael = new Raphael(this.el[0]), this.options.resize && m(window).bind("resize", function (t) {
				return null != e.timeoutId && window.clearTimeout(e.timeoutId), e.timeoutId = window.setTimeout(e.resizeHandler, 100)
			}), this.setData(t.data))
		}
		return a(e, t), e.prototype.defaults = {
			colors: ["#0B62A4", "#3980B5", "#679DC6", "#95BBD7", "#B0CCE1", "#095791", "#095085", "#083E67", "#052C48", "#042135"],
			backgroundColor: "#FFFFFF",
			labelColor: "#000000",
			formatter: w.commas,
			resize: !1
		}, e.prototype.redraw = function () {
			var t, e, i, n, r, a, o, s, l, h, u, d, c, f, p, g, m, v, y, x, b, _;
			for (this.raphael.clear(), e = this.el.width() / 2, i = this.el.height() / 2, d = (Math.min(e, i) - 10) / 3, c = u = 0, g = (y = this.values).length; c < g; c++) u += y[c];
			for (s = 5 / (2 * d), t = 1.9999 * Math.PI - s * this.data.length, r = a = 0, this.segments = [], n = f = 0, m = (x = this.values).length; f < m; n = ++f) l = a + s + t * (x[n] / u), (h = new w.DonutSegment(e, i, 2 * d, d, a, l, this.data[n].color || this.options.colors[r % this.options.colors.length], this.options.backgroundColor, r, this.raphael)).render(), this.segments.push(h), h.on("hover", this.select), h.on("click", this.click), a = l, r += 1;
			for (this.text1 = this.drawEmptyDonutLabel(e, i - 10, this.options.labelColor, 15, 800), this.text2 = this.drawEmptyDonutLabel(e, i + 10, this.options.labelColor, 14), o = Math.max.apply(Math, this.values), _ = [], p = r = 0, v = (b = this.values).length; p < v; p++) {
				if (b[p] === o) {
					this.select(r);
					break
				}
				_.push(r += 1)
			}
			return _
		}, e.prototype.setData = function (t) {
			var r;
			return this.data = t, this.values = function () {
				var t, e, i, n;
				for (n = [], t = 0, e = (i = this.data).length; t < e; t++) r = i[t], n.push(parseFloat(r.value));
				return n
			}.call(this), this.redraw()
		}, e.prototype.click = function (t) {
			return this.fire("click", t, this.data[t])
		}, e.prototype.select = function (t) {
			var e, i, n, r;
			for (i = 0, n = (r = this.segments).length; i < n; i++) r[i].deselect();
			return this.segments[t].select(), e = this.data[t], this.setLabels(e.label, this.options.formatter(e.value, e))
		}, e.prototype.setLabels = function (t, e) {
			var i, n, r, a, o, s, l, h;
			return a = 1.8 * (i = 2 * (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) / 3), r = i / 2, n = i / 3, this.text1.attr({
				text: t,
				transform: ""
			}), o = this.text1.getBBox(), s = Math.min(a / o.width, r / o.height), this.text1.attr({
				transform: "S" + s + "," + s + "," + (o.x + o.width / 2) + "," + (o.y + o.height)
			}), this.text2.attr({
				text: e,
				transform: ""
			}), l = this.text2.getBBox(), h = Math.min(a / l.width, n / l.height), this.text2.attr({
				transform: "S" + h + "," + h + "," + (l.x + l.width / 2) + "," + l.y
			})
		}, e.prototype.drawEmptyDonutLabel = function (t, e, i, n, r) {
			var a;
			return a = this.raphael.text(t, e, "").attr("font-size", n).attr("fill", i), null != r && a.attr("font-weight", r), a
		}, e.prototype.resizeHandler = function () {
			return this.timeoutId = null, this.raphael.setSize(this.el.width(), this.el.height()), this.redraw()
		}, e
	}(w.EventEmitter), w.DonutSegment = function (t) {
		function e(t, e, i, n, r, a, o, s, l, h) {
			this.cx = t, this.cy = e, this.inner = i, this.outer = n, this.color = o, this.backgroundColor = s, this.index = l, this.raphael = h, this.deselect = u(this.deselect, this), this.select = u(this.select, this), this.sin_p0 = Math.sin(r), this.cos_p0 = Math.cos(r), this.sin_p1 = Math.sin(a), this.cos_p1 = Math.cos(a), this.is_long = a - r > Math.PI ? 1 : 0, this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5), this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer), this.hilight = this.calcArc(this.inner)
		}
		return a(e, t), e.prototype.calcArcPoints = function (t) {
			return [this.cx + t * this.sin_p0, this.cy + t * this.cos_p0, this.cx + t * this.sin_p1, this.cy + t * this.cos_p1]
		}, e.prototype.calcSegment = function (t, e) {
			var i, n, r, a, o, s, l, h, u, d;
			return i = (u = this.calcArcPoints(t))[0], r = u[1], n = u[2], a = u[3], o = (d = this.calcArcPoints(e))[0], l = d[1], s = d[2], h = d[3], "M" + i + "," + r + "A" + t + "," + t + ",0," + this.is_long + ",0," + n + "," + a + "L" + s + "," + h + "A" + e + "," + e + ",0," + this.is_long + ",1," + o + "," + l + "Z"
		}, e.prototype.calcArc = function (t) {
			var e, i, n, r, a;
			return e = (a = this.calcArcPoints(t))[0], n = a[1], i = a[2], r = a[3], "M" + e + "," + n + "A" + t + "," + t + ",0," + this.is_long + ",0," + i + "," + r
		}, e.prototype.render = function () {
			var t = this;
			return this.arc = this.drawDonutArc(this.hilight, this.color), this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function () {
				return t.fire("hover", t.index)
			}, function () {
				return t.fire("click", t.index)
			})
		}, e.prototype.drawDonutArc = function (t, e) {
			return this.raphael.path(t).attr({
				stroke: e,
				"stroke-width": 2,
				opacity: 0
			})
		}, e.prototype.drawDonutSegment = function (t, e, i, n, r) {
			return this.raphael.path(t).attr({
				fill: e,
				stroke: i,
				"stroke-width": 3
			}).hover(n).click(r)
		}, e.prototype.select = function () {
			if (!this.selected) return this.seg.animate({
				path: this.selectedPath
			}, 150, "<>"), this.arc.animate({
				opacity: 1
			}, 150, "<>"), this.selected = !0
		}, e.prototype.deselect = function () {
			if (this.selected) return this.seg.animate({
				path: this.path
			}, 150, "<>"), this.arc.animate({
				opacity: 0
			}, 150, "<>"), this.selected = !1
		}, e
	}(w.EventEmitter)
}).call(this),
	function (t, e) {
		"object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.Raphael = e() : t.Raphael = e()
	}(this, function () {
		return function (i) {
			function n(t) {
				if (r[t]) return r[t].exports;
				var e = r[t] = {
					exports: {},
					id: t,
					loaded: !1
				};
				return i[t].call(e.exports, e, e.exports, n), e.loaded = !0, e.exports
			}
			var r = {};
			return n.m = i, n.c = r, n.p = "", n(0)
		}([function (t, e, i) {
			var n, r;
			n = [i(1), i(3), i(4)], void 0 === (r = function (t) {
				return t
			}.apply(e, n)) || (t.exports = r)
		}, function (t, e, i) {
			var n, r;
			n = [i(2)], void 0 === (r = function (O) {
				function R(t) {
					if (R.is(t, "function")) return n ? t() : O.on("raphael.DOMload", t);
					if (R.is(t, A)) return R._engine.create[b](R, t.splice(0, 3 + R.is(t[0], E))).add(t);
					var e = Array.prototype.slice.call(arguments, 0);
					if (R.is(e[e.length - 1], "function")) {
						var i = e.pop();
						return n ? i.call(R._engine.create[b](R, e)) : O.on("raphael.DOMload", function () {
							i.call(R._engine.create[b](R, e))
						})
					}
					return R._engine.create[b](R, arguments)
				}

				function v(t) {
					if ("function" == typeof t || Object(t) !== t) return t;
					var e = new t.constructor;
					for (var i in t) t[N](i) && (e[i] = v(t[i]));
					return e
				}

				function V(a, o, s) {
					return function t() {
						var e = Array.prototype.slice.call(arguments, 0),
							i = e.join("‚êÄ"),
							n = t.cache = t.cache || {},
							r = t.count = t.count || [];
						return n[N](i) ? function (t, e) {
							for (var i = 0, n = t.length; i < n; i++)
								if (t[i] === e) return t.push(t.splice(i, 1)[0])
						}(r, i) : (1e3 <= r.length && delete n[r.shift()], r.push(i), n[i] = a[b](o, e)), s ? s(n[i]) : n[i]
					}
				}

				function l() {
					return this.hex
				}

				function y(t, e) {
					for (var i = [], n = 0, r = t.length; n < r - 2 * !e; n += 2) {
						var a = [{
							x: +t[n - 2],
							y: +t[n - 1]
						}, {
							x: +t[n],
							y: +t[n + 1]
						}, {
							x: +t[n + 2],
							y: +t[n + 3]
						}, {
							x: +t[n + 4],
							y: +t[n + 5]
						}];
						e ? n ? r - 4 == n ? a[3] = {
							x: +t[0],
							y: +t[1]
						} : r - 2 == n && (a[2] = {
							x: +t[0],
							y: +t[1]
						}, a[3] = {
							x: +t[2],
							y: +t[3]
						}) : a[0] = {
							x: +t[r - 2],
							y: +t[r - 1]
						} : r - 4 == n ? a[3] = a[2] : n || (a[0] = {
							x: +t[n],
							y: +t[n + 1]
						}), i.push(["C", (-a[0].x + 6 * a[1].x + a[2].x) / 6, (-a[0].y + 6 * a[1].y + a[2].y) / 6, (a[1].x + 6 * a[2].x - a[3].x) / 6, (a[1].y + 6 * a[2].y - a[3].y) / 6, a[2].x, a[2].y])
					}
					return i
				}

				function x(t, e, i, n, r) {
					return t * (t * (-3 * e + 9 * i - 9 * n + 3 * r) + 6 * e - 12 * i + 6 * n) - 3 * e + 3 * i
				}

				function S(t, e, i, n, r, a, o, s, l) {
					null == l && (l = 1);
					for (var h = (l = 1 < l ? 1 : l < 0 ? 0 : l) / 2, u = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816], d = [.2491, .2491, .2335, .2335, .2032, .2032, .1601, .1601, .1069, .1069, .0472, .0472], c = 0, f = 0; f < 12; f++) {
						var p = h * u[f] + h,
							g = x(p, t, i, r, o),
							m = x(p, e, n, a, s),
							v = g * g + m * m;
						c += d[f] * G.sqrt(v)
					}
					return h * c
				}

				function C(t, e, i, n, r, a, o, s) {
					if (!(D(t, i) < T(r, o) || T(t, i) > D(r, o) || D(e, n) < T(a, s) || T(e, n) > D(a, s))) {
						var l = (t - i) * (a - s) - (e - n) * (r - o);
						if (l) {
							var h = ((t * n - e * i) * (r - o) - (t - i) * (r * s - a * o)) / l,
								u = ((t * n - e * i) * (a - s) - (e - n) * (r * s - a * o)) / l,
								d = +h.toFixed(2),
								c = +u.toFixed(2);
							if (!(d < +T(t, i).toFixed(2) || d > +D(t, i).toFixed(2) || d < +T(r, o).toFixed(2) || d > +D(r, o).toFixed(2) || c < +T(e, n).toFixed(2) || c > +D(e, n).toFixed(2) || c < +T(a, s).toFixed(2) || c > +D(a, s).toFixed(2))) return {
								x: h,
								y: u
							}
						}
					}
				}

				function k(t, e, i) {
					var n = R.bezierBBox(t),
						r = R.bezierBBox(e);
					if (!R.isBBoxIntersect(n, r)) return i ? 0 : [];
					for (var a = S.apply(0, t), o = S.apply(0, e), s = D(~~(a / 5), 1), l = D(~~(o / 5), 1), h = [], u = [], d = {}, c = i ? 0 : [], f = 0; f < s + 1; f++) {
						var p = R.findDotsAtSegment.apply(R, t.concat(f / s));
						h.push({
							x: p.x,
							y: p.y,
							t: f / s
						})
					}
					for (f = 0; f < l + 1; f++) p = R.findDotsAtSegment.apply(R, e.concat(f / l)), u.push({
						x: p.x,
						y: p.y,
						t: f / l
					});
					for (f = 0; f < s; f++)
						for (var g = 0; g < l; g++) {
							var m = h[f],
								v = h[f + 1],
								y = u[g],
								x = u[g + 1],
								b = $(v.x - m.x) < .001 ? "y" : "x",
								_ = $(x.x - y.x) < .001 ? "y" : "x",
								w = C(m.x, m.y, v.x, v.y, y.x, y.y, x.x, x.y);
							if (w) {
								if (d[w.x.toFixed(4)] == w.y.toFixed(4)) continue;
								d[w.x.toFixed(4)] = w.y.toFixed(4);
								var k = m.t + $((w[b] - m[b]) / (v[b] - m[b])) * (v.t - m.t),
									M = y.t + $((w[_] - y[_]) / (x[_] - y[_])) * (x.t - y.t);
								0 <= k && k <= 1.001 && 0 <= M && M <= 1.001 && (i ? c++ : c.push({
									x: w.x,
									y: w.y,
									t1: T(k, 1),
									t2: T(M, 1)
								}))
							}
						}
					return c
				}

				function r(t, e, i) {
					t = R._path2curve(t), e = R._path2curve(e);
					for (var n, r, a, o, s, l, h, u, d, c, f = i ? 0 : [], p = 0, g = t.length; p < g; p++) {
						var m = t[p];
						if ("M" == m[0]) n = s = m[1], r = l = m[2];
						else {
							r = "C" == m[0] ? (n = (d = [n, r].concat(m.slice(1)))[6], d[7]) : (d = [n, r, n, r, s, l, s, l], n = s, l);
							for (var v = 0, y = e.length; v < y; v++) {
								var x = e[v];
								if ("M" == x[0]) a = h = x[1], o = u = x[2];
								else {
									o = "C" == x[0] ? (a = (c = [a, o].concat(x.slice(1)))[6], c[7]) : (c = [a, o, a, o, h, u, h, u], a = h, u);
									var b = k(d, c, i);
									if (i) f += b;
									else {
										for (var _ = 0, w = b.length; _ < w; _++) b[_].segment1 = p, b[_].segment2 = v, b[_].bez1 = d, b[_].bez2 = c;
										f = f.concat(b)
									}
								}
							}
						}
					}
					return f
				}

				function B(t, e, i, n, r, a) {
					this.f = null != t ? (this.a = +t, this.b = +e, this.c = +i, this.d = +n, this.e = +r, +a) : (this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0)
				}

				function i() {
					return this.x + M + this.y + M + this.width + " √ó " + this.height
				}

				function W(t, e, i, n, r, a) {
					function l(t) {
						return ((d * t + u) * t + h) * t
					}
					var o, h = 3 * e,
						u = 3 * (n - e) - h,
						d = 1 - h - u,
						s = 3 * i,
						c = 3 * (r - i) - s,
						f = 1 - s - c;
					return o = function (t, e) {
						var i, n, r, a, o, s;
						for (r = t, s = 0; s < 8; s++) {
							if (a = l(r) - t, $(a) < e) return r;
							if ($(o = (3 * d * r + 2 * u) * r + h) < 1e-6) break;
							r -= a / o
						}
						if (n = 1, (r = t) < (i = 0)) return i;
						if (n < r) return n;
						for (; i < n;) {
							if (a = l(r), $(a - t) < e) return r;
							a < t ? i = r : n = r, r = (n - i) / 2 + i
						}
						return r
					}(t, 1 / (200 * a)), ((f * o + c) * o + s) * o
				}

				function u(t, e) {
					var i = [],
						n = {};
					if (this.ms = e, this.times = 1, t) {
						for (var r in t) t[N](r) && (n[X(r)] = t[r], i.push(X(r)));
						i.sort(st)
					}
					this.anim = n, this.top = i[i.length - 1], this.percents = i
				}

				function w(t, e, i, n, r, a) {
					i = X(i);
					var o, s, l, h, u, d, c = t.ms,
						f = {},
						p = {},
						g = {};
					if (n)
						for (v = 0, y = ne.length; v < y; v++) {
							var m = ne[v];
							if (m.el.id == e.id && m.anim == t) {
								m.percent != i ? (ne.splice(v, 1), l = 1) : s = m, e.attr(m.totalOrigin);
								break
							}
						} else n = +p;
					for (var v = 0, y = t.percents.length; v < y; v++) {
						if (t.percents[v] == i || t.percents[v] > n * t.top) {
							i = t.percents[v], u = t.percents[v - 1] || 0, c = c / t.top * (i - u), h = t.percents[v + 1], o = t.anim[i];
							break
						}
						n && e.attr(t.anim[t.percents[v]])
					}
					if (o) {
						if (s) s.initstatus = n, s.start = new Date - s.ms * n;
						else {
							for (var x in o)
								if (o[N](x) && (J[N](x) || e.paper.customAttributes[N](x))) switch (f[x] = e.attr(x), null == f[x] && (f[x] = K[x]), p[x] = o[x], J[x]) {
									case E:
										g[x] = (p[x] - f[x]) / c;
										break;
									case "colour":
										f[x] = R.getRGB(f[x]);
										var b = R.getRGB(p[x]);
										g[x] = {
											r: (b.r - f[x].r) / c,
											g: (b.g - f[x].g) / c,
											b: (b.b - f[x].b) / c
										};
										break;
									case "path":
										var _ = Lt(f[x], p[x]),
											w = _[1];
										for (f[x] = _[0], g[x] = [], v = 0, y = f[x].length; v < y; v++) {
											g[x][v] = [0];
											for (var k = 1, M = f[x][v].length; k < M; k++) g[x][v][k] = (w[v][k] - f[x][v][k]) / c
										}
										break;
									case "transform":
										var S = e._,
											C = zt(S[x], p[x]);
										if (C)
											for (f[x] = C.from, p[x] = C.to, g[x] = [], g[x].real = !0, v = 0, y = f[x].length; v < y; v++)
												for (g[x][v] = [f[x][v][0]], k = 1, M = f[x][v].length; k < M; k++) g[x][v][k] = (p[x][v][k] - f[x][v][k]) / c;
										else {
											var D = e.matrix || new B,
												T = {
													_: {
														transform: S.transform
													},
													getBBox: function () {
														return e.getBBox(1)
													}
												};
											f[x] = [D.a, D.b, D.c, D.d, D.e, D.f], Bt(T, p[x]), p[x] = T._.transform, g[x] = [(T.matrix.a - D.a) / c, (T.matrix.b - D.b) / c, (T.matrix.c - D.c) / c, (T.matrix.d - D.d) / c, (T.matrix.e - D.e) / c, (T.matrix.f - D.f) / c]
										}
										break;
									case "csv":
										var P = Y(o[x])[U](z),
											A = Y(f[x])[U](z);
										if ("clip-rect" == x)
											for (f[x] = A, g[x] = [], v = A.length; v--;) g[x][v] = (P[v] - f[x][v]) / c;
										p[x] = P;
										break;
									default:
										for (P = [][j](o[x]), A = [][j](f[x]), g[x] = [], v = e.paper.customAttributes[x].length; v--;) g[x][v] = ((P[v] || 0) - (A[v] || 0)) / c
								}
							var F = o.easing,
								I = R.easing_formulas[F];
							if (!I)
								if ((I = Y(F).match(H)) && 5 == I.length) {
									var L = I;
									I = function (t) {
										return W(t, +L[1], +L[2], +L[3], +L[4], c)
									}
								} else I = lt;
							if (m = {
									anim: t,
									percent: i,
									timestamp: d = o.start || t.start || +new Date,
									start: d + (t.del || 0),
									status: 0,
									initstatus: n || 0,
									stop: !1,
									ms: c,
									easing: I,
									from: f,
									diff: g,
									to: p,
									el: e,
									callback: o.callback,
									prev: u,
									next: h,
									repeat: a || t.times,
									origin: e.attr(),
									totalOrigin: r
								}, ne.push(m), n && !s && !l && (m.stop = !0, m.start = new Date - c * n, 1 == ne.length)) return ae();
							l && (m.start = new Date - m.ms * n), 1 == ne.length && re(ae)
						}
						O("raphael.anim.start." + e.id, e, t)
					}
				}

				function t(t) {
					for (var e = 0; e < ne.length; e++) ne[e].el.paper == t && ne.splice(e--, 1)
				}
				R.version = "2.2.0", R.eve = O;
				var n, e, z = /[, ]+/,
					a = {
						circle: 1,
						rect: 1,
						path: 1,
						ellipse: 1,
						text: 1,
						image: 1
					},
					o = /\{(\d+)\}/g,
					N = "hasOwnProperty",
					p = {
						doc: document,
						win: window
					},
					s = {
						was: Object.prototype[N].call(p.win, "Raphael"),
						is: p.win.Raphael
					},
					h = function () {
						this.ca = this.customAttributes = {}
					},
					b = "apply",
					j = "concat",
					g = "ontouchstart" in p.win || p.win.DocumentTouch && p.doc instanceof DocumentTouch,
					M = " ",
					Y = String,
					U = "split",
					d = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel" [U](M),
					c = {
						mousedown: "touchstart",
						mousemove: "touchmove",
						mouseup: "touchend"
					},
					_ = Y.prototype.toLowerCase,
					G = Math,
					D = G.max,
					T = G.min,
					$ = G.abs,
					P = G.pow,
					q = G.PI,
					E = "number",
					f = "string",
					A = "array",
					m = Object.prototype.toString,
					F = (R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i, /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i),
					I = {
						NaN: 1,
						Infinity: 1,
						"-Infinity": 1
					},
					H = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
					L = G.round,
					X = parseFloat,
					Z = parseInt,
					Q = Y.prototype.toUpperCase,
					K = R._availableAttrs = {
						"arrow-end": "none",
						"arrow-start": "none",
						blur: 0,
						"clip-rect": "0 0 1e9 1e9",
						cursor: "default",
						cx: 0,
						cy: 0,
						fill: "#fff",
						"fill-opacity": 1,
						font: '10px "Shabnam"',
						"font-family": '"Shabnam"',
						"font-size": "10",
						"font-style": "normal",
						"font-weight": 400,
						gradient: 0,
						height: 0,
						href: "http://raphaeljs.com/",
						"letter-spacing": 0,
						opacity: 1,
						path: "M0,0",
						r: 0,
						rx: 0,
						ry: 0,
						src: "",
						stroke: "#000",
						"stroke-dasharray": "",
						"stroke-linecap": "butt",
						"stroke-linejoin": "butt",
						"stroke-miterlimit": 0,
						"stroke-opacity": 1,
						"stroke-width": 1,
						target: "_blank",
						"text-anchor": "middle",
						title: "Raphael",
						transform: "",
						width: 0,
						x: 0,
						y: 0,
						class: ""
					},
					J = R._availableAnimAttrs = {
						blur: E,
						"clip-rect": "csv",
						cx: E,
						cy: E,
						fill: "colour",
						"fill-opacity": E,
						"font-size": E,
						height: E,
						opacity: E,
						path: "path",
						r: E,
						rx: E,
						ry: E,
						stroke: "colour",
						"stroke-opacity": E,
						"stroke-width": E,
						transform: "transform",
						width: E,
						x: E,
						y: E
					},
					tt = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
					et = {
						hs: 1,
						rg: 1
					},
					it = /,?([achlmqrstvxz]),?/gi,
					nt = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi,
					rt = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi,
					at = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/gi,
					ot = (R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/, {}),
					st = function (t, e) {
						return X(t) - X(e)
					},
					lt = function (t) {
						return t
					},
					ht = R._rectPath = function (t, e, i, n, r) {
						return r ? [["M", t + r, e], ["l", i - 2 * r, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, n - 2 * r], ["a", r, r, 0, 0, 1, -r, r], ["l", 2 * r - i, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, 2 * r - n], ["a", r, r, 0, 0, 1, r, -r], ["z"]] : [["M", t, e], ["l", i, 0], ["l", 0, n], ["l", -i, 0], ["z"]]
					},
					ut = function (t, e, i, n) {
						return null == n && (n = i), [["M", t, e], ["m", 0, -n], ["a", i, n, 0, 1, 1, 0, 2 * n], ["a", i, n, 0, 1, 1, 0, -2 * n], ["z"]]
					},
					dt = R._getPath = {
						path: function (t) {
							return t.attr("path")
						},
						circle: function (t) {
							var e = t.attrs;
							return ut(e.cx, e.cy, e.r)
						},
						ellipse: function (t) {
							var e = t.attrs;
							return ut(e.cx, e.cy, e.rx, e.ry)
						},
						rect: function (t) {
							var e = t.attrs;
							return ht(e.x, e.y, e.width, e.height, e.r)
						},
						image: function (t) {
							var e = t.attrs;
							return ht(e.x, e.y, e.width, e.height)
						},
						text: function (t) {
							var e = t._getBBox();
							return ht(e.x, e.y, e.width, e.height)
						},
						set: function (t) {
							var e = t._getBBox();
							return ht(e.x, e.y, e.width, e.height)
						}
					},
					ct = R.mapPath = function (t, e) {
						if (!e) return t;
						var i, n, r, a, o, s, l;
						for (r = 0, o = (t = Lt(t)).length; r < o; r++)
							for (a = 1, s = (l = t[r]).length; a < s; a += 2) i = e.x(l[a], l[a + 1]), n = e.y(l[a], l[a + 1]), l[a] = i, l[a + 1] = n;
						return t
					};
				if (R._g = p, "VML" == (R.type = p.win.SVGAngle || p.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML")) {
					var ft, pt = p.doc.createElement("div");
					if (pt.innerHTML = '<v:shape adj="1"/>', (ft = pt.firstChild).style.behavior = "url(#default#VML)", !ft || "object" != typeof ft.adj) return R.type = "";
					pt = null
				}
				R.svg = !(R.vml = "VML" == R.type), R._Paper = h, R.fn = e = h.prototype = R.prototype, R._id = 0, R.is = function (t, e) {
					return "finite" == (e = _.call(e)) ? !I[N](+t) : "array" == e ? t instanceof Array : "null" == e && null === t || e == typeof t && null !== t || "object" == e && t === Object(t) || "array" == e && Array.isArray && Array.isArray(t) || m.call(t).slice(8, -1).toLowerCase() == e
				}, R.angle = function (t, e, i, n, r, a) {
					if (null != r) return R.angle(t, e, r, a) - R.angle(i, n, r, a);
					var o = t - i,
						s = e - n;
					return o || s ? (180 + 180 * G.atan2(-s, -o) / q + 360) % 360 : 0
				}, R.rad = function (t) {
					return t % 360 * q / 180
				}, R.deg = function (t) {
					return Math.round(180 * t / q % 360 * 1e3) / 1e3
				}, R.snapTo = function (t, e, i) {
					if (i = R.is(i, "finite") ? i : 10, R.is(t, A)) {
						for (var n = t.length; n--;)
							if ($(t[n] - e) <= i) return t[n]
					} else {
						var r = e % (t = +t);
						if (r < i) return e - r;
						if (t - i < r) return e - r + t
					}
					return e
				};
				var gt, mt;
				R.createUUID = (gt = /[xy]/g, mt = function (t) {
					var e = 16 * G.random() | 0;
					return ("x" == t ? e : 3 & e | 8).toString(16)
				}, function () {
					return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(gt, mt).toUpperCase()
				});
				R.setWindow = function (t) {
					O("raphael.setWindow", R, p.win, t), p.win = t, p.doc = p.win.document, R._engine.initWin && R._engine.initWin(p.win)
				};
				var vt = function (t) {
						if (R.vml) {
							var i, n = /^\s+|\s+$/g;
							try {
								var e = new ActiveXObject("htmlfile");
								e.write("<body>"), e.close(), i = e.body
							} catch (t) {
								i = createPopup().document.body
							}
							var r = i.createTextRange();
							vt = V(function (t) {
								try {
									i.style.color = Y(t).replace(n, "");
									var e = r.queryCommandValue("ForeColor");
									return "#" + ("000000" + (e = (255 & e) << 16 | 65280 & e | (16711680 & e) >>> 16).toString(16)).slice(-6)
								} catch (t) {
									return "none"
								}
							})
						} else {
							var a = p.doc.createElement("i");
							a.title = "Rapha√´l Colour Picker", a.style.display = "none", p.doc.body.appendChild(a), vt = V(function (t) {
								return a.style.color = t, p.doc.defaultView.getComputedStyle(a, "").getPropertyValue("color")
							})
						}
						return vt(t)
					},
					yt = function () {
						return "hsb(" + [this.h, this.s, this.b] + ")"
					},
					xt = function () {
						return "hsl(" + [this.h, this.s, this.l] + ")"
					},
					bt = function () {
						return this.hex
					},
					_t = function (t, e, i) {
						if (null == e && R.is(t, "object") && "r" in t && "g" in t && "b" in t && (i = t.b, e = t.g, t = t.r), null == e && R.is(t, f)) {
							var n = R.getRGB(t);
							t = n.r, e = n.g, i = n.b
						}
						return (1 < t || 1 < e || 1 < i) && (t /= 255, e /= 255, i /= 255), [t, e, i]
					},
					wt = function (t, e, i, n) {
						var r = {
							r: t *= 255,
							g: e *= 255,
							b: i *= 255,
							hex: R.rgb(t, e, i),
							toString: bt
						};
						return R.is(n, "finite") && (r.opacity = n), r
					};
				R.color = function (t) {
					var e;
					return R.is(t, "object") && "h" in t && "s" in t && "b" in t ? (e = R.hsb2rgb(t), t.r = e.r, t.g = e.g, t.b = e.b, t.hex = e.hex) : R.is(t, "object") && "h" in t && "s" in t && "l" in t ? (e = R.hsl2rgb(t), t.r = e.r, t.g = e.g, t.b = e.b, t.hex = e.hex) : (R.is(t, "string") && (t = R.getRGB(t)), R.is(t, "object") && "r" in t && "g" in t && "b" in t ? (e = R.rgb2hsl(t), t.h = e.h, t.s = e.s, t.l = e.l, e = R.rgb2hsb(t), t.v = e.b) : (t = {
						hex: "none"
					}).r = t.g = t.b = t.h = t.s = t.v = t.l = -1), t.toString = bt, t
				}, R.hsb2rgb = function (t, e, i, n) {
					var r, a, o, s, l;
					return this.is(t, "object") && "h" in t && "s" in t && "b" in t && (i = t.b, e = t.s, n = t.o, t = t.h), s = (l = i * e) * (1 - $((t = (t *= 360) % 360 / 60) % 2 - 1)), r = a = o = i - l, wt(r += [l, s, 0, 0, s, l][t = ~~t], a += [s, l, l, s, 0, 0][t], o += [0, 0, s, l, l, s][t], n)
				}, R.hsl2rgb = function (t, e, i, n) {
					var r, a, o, s, l;
					return this.is(t, "object") && "h" in t && "s" in t && "l" in t && (i = t.l, e = t.s, t = t.h), (1 < t || 1 < e || 1 < i) && (t /= 360, e /= 100, i /= 100), s = (l = 2 * e * (i < .5 ? i : 1 - i)) * (1 - $((t = (t *= 360) % 360 / 60) % 2 - 1)), r = a = o = i - l / 2, wt(r += [l, s, 0, 0, s, l][t = ~~t], a += [s, l, l, s, 0, 0][t], o += [0, 0, s, l, l, s][t], n)
				}, R.rgb2hsb = function (t, e, i) {
					var n, r;
					return t = (i = _t(t, e, i))[0], e = i[1], i = i[2], {
						h: ((0 == (r = (n = D(t, e, i)) - T(t, e, i)) ? null : n == t ? (e - i) / r : n == e ? (i - t) / r + 2 : (t - e) / r + 4) + 360) % 6 * 60 / 360,
						s: 0 == r ? 0 : r / n,
						b: n,
						toString: yt
					}
				}, R.rgb2hsl = function (t, e, i) {
					var n, r, a, o;
					return t = (i = _t(t, e, i))[0], e = i[1], i = i[2], n = ((r = D(t, e, i)) + (a = T(t, e, i))) / 2, {
						h: ((0 == (o = r - a) ? null : r == t ? (e - i) / o : r == e ? (i - t) / o + 2 : (t - e) / o + 4) + 360) % 6 * 60 / 360,
						s: 0 == o ? 0 : n < .5 ? o / (2 * n) : o / (2 - 2 * n),
						l: n,
						toString: xt
					}
				}, R._path2string = function () {
					return this.join(",").replace(it, "$1")
				};
				R._preload = function (t, e) {
					var i = p.doc.createElement("img");
					i.style.cssText = "position:absolute;left:-9999em;top:-9999em", i.onload = function () {
						e.call(this), this.onload = null, p.doc.body.removeChild(this)
					}, i.onerror = function () {
						p.doc.body.removeChild(this)
					}, p.doc.body.appendChild(i), i.src = t
				};
				R.getRGB = V(function (t) {
					if (!t || (t = Y(t)).indexOf("-") + 1) return {
						r: -1,
						g: -1,
						b: -1,
						hex: "none",
						error: 1,
						toString: l
					};
					if ("none" == t) return {
						r: -1,
						g: -1,
						b: -1,
						hex: "none",
						toString: l
					};
					!et[N](t.toLowerCase().substring(0, 2)) && "#" != t.charAt() && (t = vt(t));
					var e, i, n, r, a, o, s = t.match(F);
					return s ? (s[2] && (n = Z(s[2].substring(5), 16), i = Z(s[2].substring(3, 5), 16), e = Z(s[2].substring(1, 3), 16)), s[3] && (n = Z((a = s[3].charAt(3)) + a, 16), i = Z((a = s[3].charAt(2)) + a, 16), e = Z((a = s[3].charAt(1)) + a, 16)), s[4] && (o = s[4][U](tt), e = X(o[0]), "%" == o[0].slice(-1) && (e *= 2.55), i = X(o[1]), "%" == o[1].slice(-1) && (i *= 2.55), n = X(o[2]), "%" == o[2].slice(-1) && (n *= 2.55), "rgba" == s[1].toLowerCase().slice(0, 4) && (r = X(o[3])), o[3] && "%" == o[3].slice(-1) && (r /= 100)), s[5] ? (o = s[5][U](tt), e = X(o[0]), "%" == o[0].slice(-1) && (e *= 2.55), i = X(o[1]), "%" == o[1].slice(-1) && (i *= 2.55), n = X(o[2]), "%" == o[2].slice(-1) && (n *= 2.55), ("deg" == o[0].slice(-3) || "¬∞" == o[0].slice(-1)) && (e /= 360), "hsba" == s[1].toLowerCase().slice(0, 4) && (r = X(o[3])), o[3] && "%" == o[3].slice(-1) && (r /= 100), R.hsb2rgb(e, i, n, r)) : s[6] ? (o = s[6][U](tt), e = X(o[0]), "%" == o[0].slice(-1) && (e *= 2.55), i = X(o[1]), "%" == o[1].slice(-1) && (i *= 2.55), n = X(o[2]), "%" == o[2].slice(-1) && (n *= 2.55), ("deg" == o[0].slice(-3) || "¬∞" == o[0].slice(-1)) && (e /= 360), "hsla" == s[1].toLowerCase().slice(0, 4) && (r = X(o[3])), o[3] && "%" == o[3].slice(-1) && (r /= 100), R.hsl2rgb(e, i, n, r)) : ((s = {
						r: e,
						g: i,
						b: n,
						toString: l
					}).hex = "#" + (16777216 | n | i << 8 | e << 16).toString(16).slice(1), R.is(r, "finite") && (s.opacity = r), s)) : {
						r: -1,
						g: -1,
						b: -1,
						hex: "none",
						error: 1,
						toString: l
					}
				}, R), R.hsb = V(function (t, e, i) {
					return R.hsb2rgb(t, e, i).hex
				}), R.hsl = V(function (t, e, i) {
					return R.hsl2rgb(t, e, i).hex
				}), R.rgb = V(function (t, e, i) {
					function n(t) {
						return t + .5 | 0
					}
					return "#" + (16777216 | n(i) | n(e) << 8 | n(t) << 16).toString(16).slice(1)
				}), (R.getColor = function (t) {
					var e = this.getColor.start = this.getColor.start || {
							h: 0,
							s: 1,
							b: t || .75
						},
						i = this.hsb2rgb(e.h, e.s, e.b);
					return e.h += .075, 1 < e.h && (e.h = 0, e.s -= .2, e.s <= 0 && (this.getColor.start = {
						h: 0,
						s: 1,
						b: e.b
					})), i.hex
				}).reset = function () {
					delete this.start
				}, R.parsePathString = function (t) {
					if (!t) return null;
					var e = kt(t);
					if (e.arr) return St(e.arr);
					var a = {
							a: 7,
							c: 6,
							h: 1,
							l: 2,
							m: 2,
							r: 4,
							q: 4,
							s: 4,
							t: 2,
							v: 1,
							z: 0
						},
						o = [];
					return R.is(t, A) && R.is(t[0], A) && (o = St(t)), o.length || Y(t).replace(nt, function (t, e, i) {
						var n = [],
							r = e.toLowerCase();
						if (i.replace(at, function (t, e) {
								e && n.push(+e)
							}), "m" == r && 2 < n.length && (o.push([e][j](n.splice(0, 2))), r = "l", e = "m" == e ? "l" : "L"), "r" == r) o.push([e][j](n));
						else
							for (; n.length >= a[r] && (o.push([e][j](n.splice(0, a[r]))), a[r]););
					}), o.toString = R._path2string, e.arr = St(o), o
				}, R.parseTransformString = V(function (t) {
					if (!t) return null;
					var r = [];
					return R.is(t, A) && R.is(t[0], A) && (r = St(t)), r.length || Y(t).replace(rt, function (t, e, i) {
						var n = [];
						_.call(e);
						i.replace(at, function (t, e) {
							e && n.push(+e)
						}), r.push([e][j](n))
					}), r.toString = R._path2string, r
				});
				var kt = function (e) {
					var i = kt.ps = kt.ps || {};
					return i[e] ? i[e].sleep = 100 : i[e] = {
						sleep: 100
					}, setTimeout(function () {
						for (var t in i) i[N](t) && t != e && (i[t].sleep--, !i[t].sleep && delete i[t])
					}), i[e]
				};
				R.findDotsAtSegment = function (t, e, i, n, r, a, o, s, l) {
					var h = 1 - l,
						u = P(h, 3),
						d = P(h, 2),
						c = l * l,
						f = c * l,
						p = u * t + 3 * d * l * i + 3 * h * l * l * r + f * o,
						g = u * e + 3 * d * l * n + 3 * h * l * l * a + f * s,
						m = t + 2 * l * (i - t) + c * (r - 2 * i + t),
						v = e + 2 * l * (n - e) + c * (a - 2 * n + e),
						y = i + 2 * l * (r - i) + c * (o - 2 * r + i),
						x = n + 2 * l * (a - n) + c * (s - 2 * a + n),
						b = h * t + l * i,
						_ = h * e + l * n,
						w = h * r + l * o,
						k = h * a + l * s,
						M = 90 - 180 * G.atan2(m - y, v - x) / q;
					return (y < m || v < x) && (M += 180), {
						x: p,
						y: g,
						m: {
							x: m,
							y: v
						},
						n: {
							x: y,
							y: x
						},
						start: {
							x: b,
							y: _
						},
						end: {
							x: w,
							y: k
						},
						alpha: M
					}
				}, R.bezierBBox = function (t, e, i, n, r, a, o, s) {
					R.is(t, "array") || (t = [t, e, i, n, r, a, o, s]);
					var l = It.apply(null, t);
					return {
						x: l.min.x,
						y: l.min.y,
						x2: l.max.x,
						y2: l.max.y,
						width: l.max.x - l.min.x,
						height: l.max.y - l.min.y
					}
				}, R.isPointInsideBBox = function (t, e, i) {
					return e >= t.x && e <= t.x2 && i >= t.y && i <= t.y2
				}, R.isBBoxIntersect = function (t, e) {
					var i = R.isPointInsideBBox;
					return i(e, t.x, t.y) || i(e, t.x2, t.y) || i(e, t.x, t.y2) || i(e, t.x2, t.y2) || i(t, e.x, e.y) || i(t, e.x2, e.y) || i(t, e.x, e.y2) || i(t, e.x2, e.y2) || (t.x < e.x2 && t.x > e.x || e.x < t.x2 && e.x > t.x) && (t.y < e.y2 && t.y > e.y || e.y < t.y2 && e.y > t.y)
				}, R.pathIntersection = function (t, e) {
					return r(t, e)
				}, R.pathIntersectionNumber = function (t, e) {
					return r(t, e, 1)
				}, R.isPointInsidePath = function (t, e, i) {
					var n = R.pathBBox(t);
					return R.isPointInsideBBox(n, e, i) && r(t, [["M", e, i], ["H", n.x2 + 10]], 1) % 2 == 1
				}, R._removedFactory = function (t) {
					return function () {
						O("raphael.log", null, "Rapha√´l: you are calling to method ‚Äú" + t + "‚Äù of removed object", t)
					}
				};
				var Mt = R.pathBBox = function (t) {
						var e = kt(t);
						if (e.bbox) return v(e.bbox);
						if (!t) return {
							x: 0,
							y: 0,
							width: 0,
							height: 0,
							x2: 0,
							y2: 0
						};
						for (var i, n = 0, r = 0, a = [], o = [], s = 0, l = (t = Lt(t)).length; s < l; s++)
							if ("M" == (i = t[s])[0]) n = i[1], r = i[2], a.push(n), o.push(r);
							else {
								var h = It(n, r, i[1], i[2], i[3], i[4], i[5], i[6]);
								a = a[j](h.min.x, h.max.x), o = o[j](h.min.y, h.max.y), n = i[5], r = i[6]
							} var u = T[b](0, a),
							d = T[b](0, o),
							c = D[b](0, a),
							f = D[b](0, o),
							p = c - u,
							g = f - d,
							m = {
								x: u,
								y: d,
								x2: c,
								y2: f,
								width: p,
								height: g,
								cx: u + p / 2,
								cy: d + g / 2
							};
						return e.bbox = v(m), m
					},
					St = function (t) {
						var e = v(t);
						return e.toString = R._path2string, e
					},
					Ct = R._pathToRelative = function (t) {
						var e = kt(t);
						if (e.rel) return St(e.rel);
						R.is(t, A) && R.is(t && t[0], A) || (t = R.parsePathString(t));
						var i = [],
							n = 0,
							r = 0,
							a = 0,
							o = 0,
							s = 0;
						"M" == t[0][0] && (a = n = t[0][1], o = r = t[0][2], s++, i.push(["M", n, r]));
						for (var l = s, h = t.length; l < h; l++) {
							var u = i[l] = [],
								d = t[l];
							if (d[0] != _.call(d[0])) switch (u[0] = _.call(d[0]), u[0]) {
								case "a":
									u[1] = d[1], u[2] = d[2], u[3] = d[3], u[4] = d[4], u[5] = d[5], u[6] = +(d[6] - n).toFixed(3), u[7] = +(d[7] - r).toFixed(3);
									break;
								case "v":
									u[1] = +(d[1] - r).toFixed(3);
									break;
								case "m":
									a = d[1], o = d[2];
								default:
									for (var c = 1, f = d.length; c < f; c++) u[c] = +(d[c] - (c % 2 ? n : r)).toFixed(3)
							} else {
								u = i[l] = [], "m" == d[0] && (a = d[1] + n, o = d[2] + r);
								for (var p = 0, g = d.length; p < g; p++) i[l][p] = d[p]
							}
							var m = i[l].length;
							switch (i[l][0]) {
								case "z":
									n = a, r = o;
									break;
								case "h":
									n += +i[l][m - 1];
									break;
								case "v":
									r += +i[l][m - 1];
									break;
								default:
									n += +i[l][m - 2], r += +i[l][m - 1]
							}
						}
						return i.toString = R._path2string, e.rel = St(i), i
					},
					Dt = R._pathToAbsolute = function (t) {
						var e = kt(t);
						if (e.abs) return St(e.abs);
						if (R.is(t, A) && R.is(t && t[0], A) || (t = R.parsePathString(t)), !t || !t.length) return [["M", 0, 0]];
						var i = [],
							n = 0,
							r = 0,
							a = 0,
							o = 0,
							s = 0;
						"M" == t[0][0] && (a = n = +t[0][1], o = r = +t[0][2], s++, i[0] = ["M", n, r]);
						for (var l, h, u = 3 == t.length && "M" == t[0][0] && "R" == t[1][0].toUpperCase() && "Z" == t[2][0].toUpperCase(), d = s, c = t.length; d < c; d++) {
							if (i.push(l = []), (h = t[d])[0] != Q.call(h[0])) switch (l[0] = Q.call(h[0]), l[0]) {
									case "A":
										l[1] = h[1], l[2] = h[2], l[3] = h[3], l[4] = h[4], l[5] = h[5], l[6] = +(h[6] + n), l[7] = +(h[7] + r);
										break;
									case "V":
										l[1] = +h[1] + r;
										break;
									case "H":
										l[1] = +h[1] + n;
										break;
									case "R":
										for (var f = [n, r][j](h.slice(1)), p = 2, g = f.length; p < g; p++) f[p] = +f[p] + n, f[++p] = +f[p] + r;
										i.pop(), i = i[j](y(f, u));
										break;
									case "M":
										a = +h[1] + n, o = +h[2] + r;
									default:
										for (p = 1, g = h.length; p < g; p++) l[p] = +h[p] + (p % 2 ? n : r)
								} else if ("R" == h[0]) f = [n, r][j](h.slice(1)), i.pop(), i = i[j](y(f, u)), l = ["R"][j](h.slice(-2));
								else
									for (var m = 0, v = h.length; m < v; m++) l[m] = h[m];
							switch (l[0]) {
								case "Z":
									n = a, r = o;
									break;
								case "H":
									n = l[1];
									break;
								case "V":
									r = l[1];
									break;
								case "M":
									a = l[l.length - 2], o = l[l.length - 1];
								default:
									n = l[l.length - 2], r = l[l.length - 1]
							}
						}
						return i.toString = R._path2string, e.abs = St(i), i
					},
					Tt = function (t, e, i, n) {
						return [t, e, i, n, i, n]
					},
					Pt = function (t, e, i, n, r, a) {
						return [1 / 3 * t + 2 / 3 * i, 1 / 3 * e + 2 / 3 * n, 1 / 3 * r + 2 / 3 * i, 1 / 3 * a + 2 / 3 * n, r, a]
					},
					At = function (t, e, i, n, r, a, o, s, l, h) {
						var u, d = 120 * q / 180,
							c = q / 180 * (+r || 0),
							f = [],
							p = V(function (t, e, i) {
								return {
									x: t * G.cos(i) - e * G.sin(i),
									y: t * G.sin(i) + e * G.cos(i)
								}
							});
						if (h) k = h[0], M = h[1], _ = h[2], w = h[3];
						else {
							t = (u = p(t, e, -c)).x, e = u.y, s = (u = p(s, l, -c)).x, l = u.y;
							G.cos(q / 180 * r), G.sin(q / 180 * r);
							var g = (t - s) / 2,
								m = (e - l) / 2,
								v = g * g / (i * i) + m * m / (n * n);
							1 < v && (i *= v = G.sqrt(v), n *= v);
							var y = i * i,
								x = n * n,
								b = (a == o ? -1 : 1) * G.sqrt($((y * x - y * m * m - x * g * g) / (y * m * m + x * g * g))),
								_ = b * i * m / n + (t + s) / 2,
								w = b * -n * g / i + (e + l) / 2,
								k = G.asin(((e - w) / n).toFixed(9)),
								M = G.asin(((l - w) / n).toFixed(9));
							(k = t < _ ? q - k : k) < 0 && (k = 2 * q + k), (M = s < _ ? q - M : M) < 0 && (M = 2 * q + M), o && M < k && (k -= 2 * q), !o && k < M && (M -= 2 * q)
						}
						var S = M - k;
						if ($(S) > d) {
							var C = M,
								D = s,
								T = l;
							M = k + d * (o && k < M ? 1 : -1), s = _ + i * G.cos(M), l = w + n * G.sin(M), f = At(s, l, i, n, r, 0, o, D, T, [M, C, _, w])
						}
						S = M - k;
						var P = G.cos(k),
							A = G.sin(k),
							F = G.cos(M),
							I = G.sin(M),
							L = G.tan(S / 4),
							O = 4 / 3 * i * L,
							R = 4 / 3 * n * L,
							B = [t, e],
							W = [t + O * A, e - R * P],
							z = [s + O * I, l - R * F],
							N = [s, l];
						if (W[0] = 2 * B[0] - W[0], W[1] = 2 * B[1] - W[1], h) return [W, z, N][j](f);
						for (var Y = [], E = 0, H = (f = [W, z, N][j](f).join()[U](",")).length; E < H; E++) Y[E] = E % 2 ? p(f[E - 1], f[E], c).y : p(f[E], f[E + 1], c).x;
						return Y
					},
					Ft = function (t, e, i, n, r, a, o, s, l) {
						var h = 1 - l;
						return {
							x: P(h, 3) * t + 3 * P(h, 2) * l * i + 3 * h * l * l * r + P(l, 3) * o,
							y: P(h, 3) * e + 3 * P(h, 2) * l * n + 3 * h * l * l * a + P(l, 3) * s
						}
					},
					It = V(function (t, e, i, n, r, a, o, s) {
						var l, h = r - 2 * i + t - (o - 2 * r + i),
							u = 2 * (i - t) - 2 * (r - i),
							d = t - i,
							c = (-u + G.sqrt(u * u - 4 * h * d)) / 2 / h,
							f = (-u - G.sqrt(u * u - 4 * h * d)) / 2 / h,
							p = [e, s],
							g = [t, o];
						return "1e12" < $(c) && (c = .5), "1e12" < $(f) && (f = .5), 0 < c && c < 1 && (l = Ft(t, e, i, n, r, a, o, s, c), g.push(l.x), p.push(l.y)), 0 < f && f < 1 && (l = Ft(t, e, i, n, r, a, o, s, f), g.push(l.x), p.push(l.y)), h = a - 2 * n + e - (s - 2 * a + n), d = e - n, c = (-(u = 2 * (n - e) - 2 * (a - n)) + G.sqrt(u * u - 4 * h * d)) / 2 / h, f = (-u - G.sqrt(u * u - 4 * h * d)) / 2 / h, "1e12" < $(c) && (c = .5), "1e12" < $(f) && (f = .5), 0 < c && c < 1 && (l = Ft(t, e, i, n, r, a, o, s, c), g.push(l.x), p.push(l.y)), 0 < f && f < 1 && (l = Ft(t, e, i, n, r, a, o, s, f), g.push(l.x), p.push(l.y)), {
							min: {
								x: T[b](0, g),
								y: T[b](0, p)
							},
							max: {
								x: D[b](0, g),
								y: D[b](0, p)
							}
						}
					}),
					Lt = R._path2curve = V(function (t, e) {
						var i = !e && kt(t);
						if (!e && i.curve) return St(i.curve);
						for (var a = Dt(t), o = e && Dt(e), n = {
								x: 0,
								y: 0,
								bx: 0,
								by: 0,
								X: 0,
								Y: 0,
								qx: null,
								qy: null
							}, r = {
								x: 0,
								y: 0,
								bx: 0,
								by: 0,
								X: 0,
								Y: 0,
								qx: null,
								qy: null
							}, s = function (t, e, i) {
								var n, r;
								if (!t) return ["C", e.x, e.y, e.x, e.y, e.x, e.y];
								switch (!(t[0] in {
									T: 1,
									Q: 1
								}) && (e.qx = e.qy = null), t[0]) {
									case "M":
										e.X = t[1], e.Y = t[2];
										break;
									case "A":
										t = ["C"][j](At[b](0, [e.x, e.y][j](t.slice(1))));
										break;
									case "S":
										r = "C" == i || "S" == i ? (n = 2 * e.x - e.bx, 2 * e.y - e.by) : (n = e.x, e.y), t = ["C", n, r][j](t.slice(1));
										break;
									case "T":
										e.qy = "Q" == i || "T" == i ? (e.qx = 2 * e.x - e.qx, 2 * e.y - e.qy) : (e.qx = e.x, e.y), t = ["C"][j](Pt(e.x, e.y, e.qx, e.qy, t[1], t[2]));
										break;
									case "Q":
										e.qx = t[1], e.qy = t[2], t = ["C"][j](Pt(e.x, e.y, t[1], t[2], t[3], t[4]));
										break;
									case "L":
										t = ["C"][j](Tt(e.x, e.y, t[1], t[2]));
										break;
									case "H":
										t = ["C"][j](Tt(e.x, e.y, t[1], e.y));
										break;
									case "V":
										t = ["C"][j](Tt(e.x, e.y, e.x, t[1]));
										break;
									case "Z":
										t = ["C"][j](Tt(e.x, e.y, e.X, e.Y))
								}
								return t
							}, l = function (t, e) {
								if (7 < t[e].length) {
									t[e].shift();
									for (var i = t[e]; i.length;) u[e] = "A", o && (d[e] = "A"), t.splice(e++, 0, ["C"][j](i.splice(0, 6)));
									t.splice(e, 1), g = D(a.length, o && o.length || 0)
								}
							}, h = function (t, e, i, n, r) {
								t && e && "M" == t[r][0] && "M" != e[r][0] && (e.splice(r, 0, ["M", n.x, n.y]), i.bx = 0, i.by = 0, i.x = t[r][1], i.y = t[r][2], g = D(a.length, o && o.length || 0))
							}, u = [], d = [], c = "", f = "", p = 0, g = D(a.length, o && o.length || 0); p < g; p++) {
							a[p] && (c = a[p][0]), "C" != c && (u[p] = c, p && (f = u[p - 1])), a[p] = s(a[p], n, f), "A" != u[p] && "C" == c && (u[p] = "C"), l(a, p), o && (o[p] && (c = o[p][0]), "C" != c && (d[p] = c, p && (f = d[p - 1])), o[p] = s(o[p], r, f), "A" != d[p] && "C" == c && (d[p] = "C"), l(o, p)), h(a, o, n, r, p), h(o, a, r, n, p);
							var m = a[p],
								v = o && o[p],
								y = m.length,
								x = o && v.length;
							n.x = m[y - 2], n.y = m[y - 1], n.bx = X(m[y - 4]) || n.x, n.by = X(m[y - 3]) || n.y, r.bx = o && (X(v[x - 4]) || r.x), r.by = o && (X(v[x - 3]) || r.y), r.x = o && v[x - 2], r.y = o && v[x - 1]
						}
						return o || (i.curve = St(a)), o ? [a, o] : a
					}, null, St),
					Ot = (R._parseDots = V(function (t) {
						for (var e = [], i = 0, n = t.length; i < n; i++) {
							var r = {},
								a = t[i].match(/^([^:]*):?([\d\.]*)/);
							if (r.color = R.getRGB(a[1]), r.color.error) return null;
							r.opacity = r.color.opacity, r.color = r.color.hex, a[2] && (r.offset = a[2] + "%"), e.push(r)
						}
						for (i = 1, n = e.length - 1; i < n; i++)
							if (!e[i].offset) {
								for (var o = X(e[i - 1].offset || 0), s = 0, l = i + 1; l < n; l++)
									if (e[l].offset) {
										s = e[l].offset;
										break
									} s || (s = 100, l = n);
								for (var h = ((s = X(s)) - o) / (l - i + 1); i < l; i++) o += h, e[i].offset = o + "%"
							} return e
					}), R._tear = function (t, e) {
						t == e.top && (e.top = t.prev), t == e.bottom && (e.bottom = t.next), t.next && (t.next.prev = t.prev), t.prev && (t.prev.next = t.next)
					}),
					Rt = (R._tofront = function (t, e) {
						e.top !== t && (Ot(t, e), t.next = null, t.prev = e.top, e.top.next = t, e.top = t)
					}, R._toback = function (t, e) {
						e.bottom !== t && (Ot(t, e), t.next = e.bottom, t.prev = null, e.bottom.prev = t, e.bottom = t)
					}, R._insertafter = function (t, e, i) {
						Ot(t, i), e == i.top && (i.top = t), e.next && (e.next.prev = t), t.next = e.next, (t.prev = e).next = t
					}, R._insertbefore = function (t, e, i) {
						Ot(t, i), e == i.bottom && (i.bottom = t), e.prev && (e.prev.next = t), t.prev = e.prev, (e.prev = t).next = e
					}, R.toMatrix = function (t, e) {
						var i = Mt(t),
							n = {
								_: {
									transform: ""
								},
								getBBox: function () {
									return i
								}
							};
						return Bt(n, e), n.matrix
					}),
					Bt = (R.transformPath = function (t, e) {
						return ct(t, Rt(t, e))
					}, R._extractTransform = function (t, e) {
						if (null == e) return t._.transform;
						e = Y(e).replace(/\.{3}|\u2026/g, t._.transform || "");
						var i, n, r = R.parseTransformString(e),
							a = 0,
							o = 1,
							s = 1,
							l = t._,
							h = new B;
						if (l.transform = r || [], r)
							for (var u = 0, d = r.length; u < d; u++) {
								var c, f, p, g, m, v = r[u],
									y = v.length,
									x = Y(v[0]).toLowerCase(),
									b = v[0] != x,
									_ = b ? h.invert() : 0;
								"t" == x && 3 == y ? b ? (c = _.x(0, 0), f = _.y(0, 0), p = _.x(v[1], v[2]), g = _.y(v[1], v[2]), h.translate(p - c, g - f)) : h.translate(v[1], v[2]) : "r" == x ? 2 == y ? (m = m || t.getBBox(1), h.rotate(v[1], m.x + m.width / 2, m.y + m.height / 2), a += v[1]) : 4 == y && (b ? (p = _.x(v[2], v[3]), g = _.y(v[2], v[3]), h.rotate(v[1], p, g)) : h.rotate(v[1], v[2], v[3]), a += v[1]) : "s" == x ? 2 == y || 3 == y ? (m = m || t.getBBox(1), h.scale(v[1], v[y - 1], m.x + m.width / 2, m.y + m.height / 2), o *= v[1], s *= v[y - 1]) : 5 == y && (b ? (p = _.x(v[3], v[4]), g = _.y(v[3], v[4]), h.scale(v[1], v[2], p, g)) : h.scale(v[1], v[2], v[3], v[4]), o *= v[1], s *= v[2]) : "m" == x && 7 == y && h.add(v[1], v[2], v[3], v[4], v[5], v[6]), l.dirtyT = 1, t.matrix = h
							}
						t.matrix = h, l.sx = o, l.sy = s, l.deg = a, l.dx = i = h.e, l.dy = n = h.f, 1 == o && 1 == s && !a && l.bbox ? (l.bbox.x += +i, l.bbox.y += +n) : l.dirtyT = 1
					}),
					Wt = function (t) {
						var e = t[0];
						switch (e.toLowerCase()) {
							case "t":
								return [e, 0, 0];
							case "m":
								return [e, 1, 0, 0, 1, 0, 0];
							case "r":
								return 4 == t.length ? [e, 0, t[2], t[3]] : [e, 0];
							case "s":
								return 5 == t.length ? [e, 1, 1, t[3], t[4]] : 3 == t.length ? [e, 1, 1] : [e, 1]
						}
					},
					zt = R._equaliseTransform = function (t, e) {
						e = Y(e).replace(/\.{3}|\u2026/g, t), t = R.parseTransformString(t) || [], e = R.parseTransformString(e) || [];
						for (var i, n, r, a, o = D(t.length, e.length), s = [], l = [], h = 0; h < o; h++) {
							if (r = t[h] || Wt(e[h]), a = e[h] || Wt(r), r[0] != a[0] || "r" == r[0].toLowerCase() && (r[2] != a[2] || r[3] != a[3]) || "s" == r[0].toLowerCase() && (r[3] != a[3] || r[4] != a[4])) return;
							for (s[h] = [], l[h] = [], i = 0, n = D(r.length, a.length); i < n; i++) i in r && (s[h][i] = r[i]), i in a && (l[h][i] = a[i])
						}
						return {
							from: s,
							to: l
						}
					};
				R._getContainer = function (t, e, i, n) {
						var r;
						if (null != (r = null != n || R.is(t, "object") ? t : p.doc.getElementById(t))) return r.tagName ? null == e ? {
							container: r,
							width: r.style.pixelWidth || r.offsetWidth,
							height: r.style.pixelHeight || r.offsetHeight
						} : {
							container: r,
							width: e,
							height: i
						} : {
							container: 1,
							x: t,
							y: e,
							width: i,
							height: n
						}
					}, R.pathToRelative = Ct, R._engine = {}, R.path2curve = Lt, R.matrix = function (t, e, i, n, r, a) {
						return new B(t, e, i, n, r, a)
					},
					function (t) {
						function r(t) {
							return t[0] * t[0] + t[1] * t[1]
						}

						function a(t) {
							var e = G.sqrt(r(t));
							t[0] && (t[0] /= e), t[1] && (t[1] /= e)
						}
						t.add = function (t, e, i, n, r, a) {
							var o, s, l, h, u = [[], [], []],
								d = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
								c = [[t, i, r], [e, n, a], [0, 0, 1]];
							for (t && t instanceof B && (c = [[t.a, t.c, t.e], [t.b, t.d, t.f], [0, 0, 1]]), o = 0; o < 3; o++)
								for (s = 0; s < 3; s++) {
									for (l = h = 0; l < 3; l++) h += d[o][l] * c[l][s];
									u[o][s] = h
								}
							this.a = u[0][0], this.b = u[1][0], this.c = u[0][1], this.d = u[1][1], this.e = u[0][2], this.f = u[1][2]
						}, t.invert = function () {
							var t = this,
								e = t.a * t.d - t.b * t.c;
							return new B(t.d / e, -t.b / e, -t.c / e, t.a / e, (t.c * t.f - t.d * t.e) / e, (t.b * t.e - t.a * t.f) / e)
						}, t.clone = function () {
							return new B(this.a, this.b, this.c, this.d, this.e, this.f)
						}, t.translate = function (t, e) {
							this.add(1, 0, 0, 1, t, e)
						}, t.scale = function (t, e, i, n) {
							null == e && (e = t), (i || n) && this.add(1, 0, 0, 1, i, n), this.add(t, 0, 0, e, 0, 0), (i || n) && this.add(1, 0, 0, 1, -i, -n)
						}, t.rotate = function (t, e, i) {
							t = R.rad(t), e = e || 0, i = i || 0;
							var n = +G.cos(t).toFixed(9),
								r = +G.sin(t).toFixed(9);
							this.add(n, r, -r, n, e, i), this.add(1, 0, 0, 1, -e, -i)
						}, t.x = function (t, e) {
							return t * this.a + e * this.c + this.e
						}, t.y = function (t, e) {
							return t * this.b + e * this.d + this.f
						}, t.get = function (t) {
							return +this[Y.fromCharCode(97 + t)].toFixed(4)
						}, t.toString = function () {
							return R.svg ? "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join()
						}, t.toFilter = function () {
							return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) + ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) + ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')"
						}, t.offset = function () {
							return [this.e.toFixed(4), this.f.toFixed(4)]
						}, t.split = function () {
							var t = {};
							t.dx = this.e, t.dy = this.f;
							var e = [[this.a, this.c], [this.b, this.d]];
							t.scalex = G.sqrt(r(e[0])), a(e[0]), t.shear = e[0][0] * e[1][0] + e[0][1] * e[1][1], e[1] = [e[1][0] - e[0][0] * t.shear, e[1][1] - e[0][1] * t.shear], t.scaley = G.sqrt(r(e[1])), a(e[1]), t.shear /= t.scaley;
							var i = -e[0][1],
								n = e[1][1];
							return n < 0 ? (t.rotate = R.deg(G.acos(n)), i < 0 && (t.rotate = 360 - t.rotate)) : t.rotate = R.deg(G.asin(i)), t.isSimple = !(+t.shear.toFixed(9) || t.scalex.toFixed(9) != t.scaley.toFixed(9) && t.rotate), t.isSuperSimple = !+t.shear.toFixed(9) && t.scalex.toFixed(9) == t.scaley.toFixed(9) && !t.rotate, t.noRotation = !+t.shear.toFixed(9) && !t.rotate, t
						}, t.toTransformString = function (t) {
							var e = t || this[U]();
							return e.isSimple ? (e.scalex = +e.scalex.toFixed(4), e.scaley = +e.scaley.toFixed(4), e.rotate = +e.rotate.toFixed(4), (e.dx || e.dy ? "t" + [e.dx, e.dy] : "") + (1 != e.scalex || 1 != e.scaley ? "s" + [e.scalex, e.scaley, 0, 0] : "") + (e.rotate ? "r" + [e.rotate, 0, 0] : "")) : "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)]
						}
					}(B.prototype);
				for (var Nt = function () {
						this.returnValue = !1
					}, Yt = function () {
						return this.originalEvent.preventDefault()
					}, Et = function () {
						this.cancelBubble = !0
					}, Ht = function () {
						return this.originalEvent.stopPropagation()
					}, Vt = function (t) {
						var e = p.doc.documentElement.scrollTop || p.doc.body.scrollTop,
							i = p.doc.documentElement.scrollLeft || p.doc.body.scrollLeft;
						return {
							x: t.clientX + i,
							y: t.clientY + e
						}
					}, jt = p.doc.addEventListener ? function (a, t, o, s) {
						var e = function (t) {
							var e = Vt(t);
							return o.call(s, t, e.x, e.y)
						};
						if (a.addEventListener(t, e, !1), g && c[t]) {
							var i = function (t) {
								for (var e = Vt(t), i = t, n = 0, r = t.targetTouches && t.targetTouches.length; n < r; n++)
									if (t.targetTouches[n].target == a) {
										(t = t.targetTouches[n]).originalEvent = i, t.preventDefault = Yt, t.stopPropagation = Ht;
										break
									} return o.call(s, t, e.x, e.y)
							};
							a.addEventListener(c[t], i, !1)
						}
						return function () {
							return a.removeEventListener(t, e, !1), g && c[t] && a.removeEventListener(c[t], i, !1), !0
						}
					} : p.doc.attachEvent ? function (t, e, a, o) {
						var i = function (t) {
							t = t || p.win.event;
							var e = p.doc.documentElement.scrollTop || p.doc.body.scrollTop,
								i = p.doc.documentElement.scrollLeft || p.doc.body.scrollLeft,
								n = t.clientX + i,
								r = t.clientY + e;
							return t.preventDefault = t.preventDefault || Nt, t.stopPropagation = t.stopPropagation || Et, a.call(o, t, n, r)
						};
						return t.attachEvent("on" + e, i),
							function () {
								return t.detachEvent("on" + e, i), !0
							}
					} : void 0, Ut = [], Gt = function (t) {
						for (var e, i = t.clientX, n = t.clientY, r = p.doc.documentElement.scrollTop || p.doc.body.scrollTop, a = p.doc.documentElement.scrollLeft || p.doc.body.scrollLeft, o = Ut.length; o--;) {
							if (e = Ut[o], g && t.touches) {
								for (var s, l = t.touches.length; l--;)
									if ((s = t.touches[l]).identifier == e.el._drag.id) {
										i = s.clientX, n = s.clientY, (t.originalEvent ? t.originalEvent : t).preventDefault();
										break
									}
							} else t.preventDefault();
							var h, u = e.el.node,
								d = u.nextSibling,
								c = u.parentNode,
								f = u.style.display;
							p.win.opera && c.removeChild(u), u.style.display = "none", h = e.el.paper.getElementByPoint(i, n), u.style.display = f, p.win.opera && (d ? c.insertBefore(u, d) : c.appendChild(u)), h && O("raphael.drag.over." + e.el.id, e.el, h), i += a, n += r, O("raphael.drag.move." + e.el.id, e.move_scope || e.el, i - e.el._drag.x, n - e.el._drag.y, i, n, t)
						}
					}, $t = function (t) {
						R.unmousemove(Gt).unmouseup($t);
						for (var e, i = Ut.length; i--;)(e = Ut[i]).el._drag = {}, O("raphael.drag.end." + e.el.id, e.end_scope || e.start_scope || e.move_scope || e.el, t);
						Ut = []
					}, qt = R.el = {}, Xt = d.length; Xt--;) ! function (n) {
					R[n] = qt[n] = function (t, e) {
						return R.is(t, "function") && (this.events = this.events || [], this.events.push({
							name: n,
							f: t,
							unbind: jt(this.shape || this.node || p.doc, n, t, e || this)
						})), this
					}, R["un" + n] = qt["un" + n] = function (t) {
						for (var e = this.events || [], i = e.length; i--;) e[i].name != n || !R.is(t, "undefined") && e[i].f != t || (e[i].unbind(), e.splice(i, 1), !e.length && delete this.events);
						return this
					}
				}(d[Xt]);
				qt.data = function (t, e) {
					var i = ot[this.id] = ot[this.id] || {};
					if (0 == arguments.length) return i;
					if (1 != arguments.length) return i[t] = e, O("raphael.data.set." + this.id, this, e, t), this;
					if (R.is(t, "object")) {
						for (var n in t) t[N](n) && this.data(n, t[n]);
						return this
					}
					return O("raphael.data.get." + this.id, this, i[t], t), i[t]
				}, qt.removeData = function (t) {
					return null == t ? ot[this.id] = {} : ot[this.id] && delete ot[this.id][t], this
				}, qt.getData = function () {
					return v(ot[this.id] || {})
				}, qt.hover = function (t, e, i, n) {
					return this.mouseover(t, i).mouseout(e, n || i)
				}, qt.unhover = function (t, e) {
					return this.unmouseover(t).unmouseout(e)
				};
				var Zt = [];
				qt.drag = function (s, l, h, u, d, c) {
					function t(t) {
						(t.originalEvent || t).preventDefault();
						var e = t.clientX,
							i = t.clientY,
							n = p.doc.documentElement.scrollTop || p.doc.body.scrollTop,
							r = p.doc.documentElement.scrollLeft || p.doc.body.scrollLeft;
						if (this._drag.id = t.identifier, g && t.touches)
							for (var a, o = t.touches.length; o--;)
								if (a = t.touches[o], this._drag.id = a.identifier, a.identifier == this._drag.id) {
									e = a.clientX, i = a.clientY;
									break
								} this._drag.x = e + r, this._drag.y = i + n, !Ut.length && R.mousemove(Gt).mouseup($t), Ut.push({
							el: this,
							move_scope: u,
							start_scope: d,
							end_scope: c
						}), l && O.on("raphael.drag.start." + this.id, l), s && O.on("raphael.drag.move." + this.id, s), h && O.on("raphael.drag.end." + this.id, h), O("raphael.drag.start." + this.id, d || u || this, t.clientX + r, t.clientY + n, t)
					}
					return this._drag = {}, Zt.push({
						el: this,
						start: t
					}), this.mousedown(t), this
				}, qt.onDragOver = function (t) {
					t ? O.on("raphael.drag.over." + this.id, t) : O.unbind("raphael.drag.over." + this.id)
				}, qt.undrag = function () {
					for (var t = Zt.length; t--;) Zt[t].el == this && (this.unmousedown(Zt[t].start), Zt.splice(t, 1), O.unbind("raphael.drag.*." + this.id));
					!Zt.length && R.unmousemove(Gt).unmouseup($t), Ut = []
				}, e.circle = function (t, e, i) {
					var n = R._engine.circle(this, t || 0, e || 0, i || 0);
					return this.__set__ && this.__set__.push(n), n
				}, e.rect = function (t, e, i, n, r) {
					var a = R._engine.rect(this, t || 0, e || 0, i || 0, n || 0, r || 0);
					return this.__set__ && this.__set__.push(a), a
				}, e.ellipse = function (t, e, i, n) {
					var r = R._engine.ellipse(this, t || 0, e || 0, i || 0, n || 0);
					return this.__set__ && this.__set__.push(r), r
				}, e.path = function (t) {
					t && !R.is(t, f) && !R.is(t[0], A) && (t += "");
					var e = R._engine.path(R.format[b](R, arguments), this);
					return this.__set__ && this.__set__.push(e), e
				}, e.image = function (t, e, i, n, r) {
					var a = R._engine.image(this, t || "about:blank", e || 0, i || 0, n || 0, r || 0);
					return this.__set__ && this.__set__.push(a), a
				}, e.text = function (t, e, i) {
					var n = R._engine.text(this, t || 0, e || 0, Y(i));
					return this.__set__ && this.__set__.push(n), n
				}, e.set = function (t) {
					!R.is(t, "array") && (t = Array.prototype.splice.call(arguments, 0, arguments.length));
					var e = new ce(t);
					return this.__set__ && this.__set__.push(e), e.paper = this, e.type = "set", e
				}, e.setStart = function (t) {
					this.__set__ = t || this.set()
				}, e.setFinish = function (t) {
					var e = this.__set__;
					return delete this.__set__, e
				}, e.getSize = function () {
					var t = this.canvas.parentNode;
					return {
						width: t.offsetWidth,
						height: t.offsetHeight
					}
				}, e.setSize = function (t, e) {
					return R._engine.setSize.call(this, t, e)
				}, e.setViewBox = function (t, e, i, n, r) {
					return R._engine.setViewBox.call(this, t, e, i, n, r)
				}, e.top = e.bottom = null, e.raphael = R;
				e.getElementByPoint = function (t, e) {
					var i, n, r, a, o, s, l, h = this.canvas,
						u = p.doc.elementFromPoint(t, e);
					if (p.win.opera && "svg" == u.tagName) {
						var d = (n = (i = h).getBoundingClientRect(), r = i.ownerDocument, a = r.body, o = r.documentElement, s = o.clientTop || a.clientTop || 0, l = o.clientLeft || a.clientLeft || 0, {
								y: n.top + (p.win.pageYOffset || o.scrollTop || a.scrollTop) - s,
								x: n.left + (p.win.pageXOffset || o.scrollLeft || a.scrollLeft) - l
							}),
							c = h.createSVGRect();
						c.x = t - d.x, c.y = e - d.y, c.width = c.height = 1;
						var f = h.getIntersectionList(c, null);
						f.length && (u = f[f.length - 1])
					}
					if (!u) return null;
					for (; u.parentNode && u != h.parentNode && !u.raphael;) u = u.parentNode;
					return u == this.canvas.parentNode && (u = h), u && u.raphael ? this.getById(u.raphaelid) : null
				}, e.getElementsByBBox = function (e) {
					var i = this.set();
					return this.forEach(function (t) {
						R.isBBoxIntersect(t.getBBox(), e) && i.push(t)
					}), i
				}, e.getById = function (t) {
					for (var e = this.bottom; e;) {
						if (e.id == t) return e;
						e = e.next
					}
					return null
				}, e.forEach = function (t, e) {
					for (var i = this.bottom; i;) {
						if (!1 === t.call(e, i)) return this;
						i = i.next
					}
					return this
				}, e.getElementsByPoint = function (e, i) {
					var n = this.set();
					return this.forEach(function (t) {
						t.isPointInside(e, i) && n.push(t)
					}), n
				}, qt.isPointInside = function (t, e) {
					var i = this.realPath = dt[this.type](this);
					return this.attr("transform") && this.attr("transform").length && (i = R.transformPath(i, this.attr("transform"))), R.isPointInsidePath(i, t, e)
				}, qt.getBBox = function (t) {
					if (this.removed) return {};
					var e = this._;
					return t ? (!e.dirty && e.bboxwt || (this.realPath = dt[this.type](this), e.bboxwt = Mt(this.realPath), e.bboxwt.toString = i, e.dirty = 0), e.bboxwt) : ((e.dirty || e.dirtyT || !e.bbox) && (!e.dirty && this.realPath || (e.bboxwt = 0, this.realPath = dt[this.type](this)), e.bbox = Mt(ct(this.realPath, this.matrix)), e.bbox.toString = i, e.dirty = e.dirtyT = 0), e.bbox)
				}, qt.clone = function () {
					if (this.removed) return null;
					var t = this.paper[this.type]().attr(this.attr());
					return this.__set__ && this.__set__.push(t), t
				}, qt.glow = function (t) {
					if ("text" == this.type) return null;
					var e = {
							width: ((t = t || {}).width || 10) + (+this.attr("stroke-width") || 1),
							fill: t.fill || !1,
							opacity: null == t.opacity ? .5 : t.opacity,
							offsetx: t.offsetx || 0,
							offsety: t.offsety || 0,
							color: t.color || "#000"
						},
						i = e.width / 2,
						n = this.paper,
						r = n.set(),
						a = this.realPath || dt[this.type](this);
					a = this.matrix ? ct(a, this.matrix) : a;
					for (var o = 1; o < i + 1; o++) r.push(n.path(a).attr({
						stroke: e.color,
						fill: e.fill ? e.color : "none",
						"stroke-linejoin": "round",
						"stroke-linecap": "round",
						"stroke-width": +(e.width / i * o).toFixed(3),
						opacity: +(e.opacity / i).toFixed(3)
					}));
					return r.insertBefore(this).translate(e.offsetx, e.offsety)
				};
				var Qt = function (t, e, i, n, r, a, o, s, l) {
						return null == l ? S(t, e, i, n, r, a, o, s) : R.findDotsAtSegment(t, e, i, n, r, a, o, s, function (t, e, i, n, r, a, o, s, l) {
							if (!(l < 0 || S(t, e, i, n, r, a, o, s) < l)) {
								var h, u = .5,
									d = 1 - u;
								for (h = S(t, e, i, n, r, a, o, s, d); .01 < $(h - l);) h = S(t, e, i, n, r, a, o, s, d += (h < l ? 1 : -1) * (u /= 2));
								return d
							}
						}(t, e, i, n, r, a, o, s, l))
					},
					Kt = function (f, p) {
						return function (t, e, i) {
							for (var n, r, a, o, s, l = "", h = {}, u = 0, d = 0, c = (t = Lt(t)).length; d < c; d++) {
								if ("M" == (a = t[d])[0]) n = +a[1], r = +a[2];
								else {
									if (e < u + (o = Qt(n, r, a[1], a[2], a[3], a[4], a[5], a[6]))) {
										if (p && !h.start) {
											if (l += ["C" + (s = Qt(n, r, a[1], a[2], a[3], a[4], a[5], a[6], e - u)).start.x, s.start.y, s.m.x, s.m.y, s.x, s.y], i) return l;
											h.start = l, l = ["M" + s.x, s.y + "C" + s.n.x, s.n.y, s.end.x, s.end.y, a[5], a[6]].join(), u += o, n = +a[5], r = +a[6];
											continue
										}
										if (!f && !p) return {
											x: (s = Qt(n, r, a[1], a[2], a[3], a[4], a[5], a[6], e - u)).x,
											y: s.y,
											alpha: s.alpha
										}
									}
									u += o, n = +a[5], r = +a[6]
								}
								l += a.shift() + a
							}
							return h.end = l, (s = f ? u : p ? h : R.findDotsAtSegment(n, r, a[0], a[1], a[2], a[3], a[4], a[5], 1)).alpha && (s = {
								x: s.x,
								y: s.y,
								alpha: s.alpha
							}), s
						}
					},
					Jt = Kt(1),
					te = Kt(),
					ee = Kt(0, 1);
				R.getTotalLength = Jt, R.getPointAtLength = te, R.getSubpath = function (t, e, i) {
					if (this.getTotalLength(t) - i < 1e-6) return ee(t, e).end;
					var n = ee(t, i, 1);
					return e ? ee(n, e).end : n
				}, qt.getTotalLength = function () {
					var t = this.getPath();
					if (t) return this.node.getTotalLength ? this.node.getTotalLength() : Jt(t)
				}, qt.getPointAtLength = function (t) {
					var e = this.getPath();
					if (e) return te(e, t)
				}, qt.getPath = function () {
					var t, e = R._getPath[this.type];
					if ("text" != this.type && "set" != this.type) return e && (t = e(this)), t
				}, qt.getSubpath = function (t, e) {
					var i = this.getPath();
					if (i) return R.getSubpath(i, t, e)
				};
				var ie = R.easing_formulas = {
					linear: function (t) {
						return t
					},
					"<": function (t) {
						return P(t, 1.7)
					},
					">": function (t) {
						return P(t, .48)
					},
					"<>": function (t) {
						var e = .48 - t / 1.04,
							i = G.sqrt(.1734 + e * e),
							n = i - e,
							r = -i - e,
							a = P($(n), 1 / 3) * (n < 0 ? -1 : 1) + P($(r), 1 / 3) * (r < 0 ? -1 : 1) + .5;
						return 3 * (1 - a) * a * a + a * a * a
					},
					backIn: function (t) {
						return t * t * (2.70158 * t - 1.70158)
					},
					backOut: function (t) {
						return (t -= 1) * t * (2.70158 * t + 1.70158) + 1
					},
					elastic: function (t) {
						return t == !!t ? t : P(2, -10 * t) * G.sin(2 * q * (t - .075) / .3) + 1
					},
					bounce: function (t) {
						var e = 7.5625,
							i = 2.75;
						return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375
					}
				};
				ie.easeIn = ie["ease-in"] = ie["<"], ie.easeOut = ie["ease-out"] = ie[">"], ie.easeInOut = ie["ease-in-out"] = ie["<>"], ie["back-in"] = ie.backIn, ie["back-out"] = ie.backOut;
				var ne = [],
					re = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {
						setTimeout(t, 16)
					},
					ae = function () {
						for (var t = +new Date, e = 0; e < ne.length; e++) {
							var i = ne[e];
							if (!i.el.removed && !i.paused) {
								var n, r, a = t - i.start,
									o = i.ms,
									s = i.easing,
									l = i.from,
									h = i.diff,
									u = i.to,
									d = (i.t, i.el),
									c = {},
									f = {};
								if (i.initstatus ? (a = (i.initstatus * i.anim.top - i.prev) / (i.percent - i.prev) * o, i.status = i.initstatus, delete i.initstatus, i.stop && ne.splice(e--, 1)) : i.status = (i.prev + (i.percent - i.prev) * (a / o)) / i.anim.top, !(a < 0))
									if (a < o) {
										var p = s(a / o);
										for (var g in l)
											if (l[N](g)) {
												switch (J[g]) {
													case E:
														n = +l[g] + p * o * h[g];
														break;
													case "colour":
														n = "rgb(" + [oe(L(l[g].r + p * o * h[g].r)), oe(L(l[g].g + p * o * h[g].g)), oe(L(l[g].b + p * o * h[g].b))].join(",") + ")";
														break;
													case "path":
														n = [];
														for (var m = 0, v = l[g].length; m < v; m++) {
															n[m] = [l[g][m][0]];
															for (var y = 1, x = l[g][m].length; y < x; y++) n[m][y] = +l[g][m][y] + p * o * h[g][m][y];
															n[m] = n[m].join(M)
														}
														n = n.join(M);
														break;
													case "transform":
														if (h[g].real)
															for (n = [], m = 0, v = l[g].length; m < v; m++)
																for (n[m] = [l[g][m][0]], y = 1, x = l[g][m].length; y < x; y++) n[m][y] = l[g][m][y] + p * o * h[g][m][y];
														else {
															var b = function (t) {
																return +l[g][t] + p * o * h[g][t]
															};
															n = [["m", b(0), b(1), b(2), b(3), b(4), b(5)]]
														}
														break;
													case "csv":
														if ("clip-rect" == g)
															for (n = [], m = 4; m--;) n[m] = +l[g][m] + p * o * h[g][m];
														break;
													default:
														var _ = [][j](l[g]);
														for (n = [], m = d.paper.customAttributes[g].length; m--;) n[m] = +_[m] + p * o * h[g][m]
												}
												c[g] = n
											} d.attr(c),
											function (t, e, i) {
												setTimeout(function () {
													O("raphael.anim.frame." + t, e, i)
												})
											}(d.id, d, i.anim)
									} else {
										if (function (t, e, i) {
												setTimeout(function () {
													O("raphael.anim.frame." + e.id, e, i), O("raphael.anim.finish." + e.id, e, i), R.is(t, "function") && t.call(e)
												})
											}(i.callback, d, i.anim), d.attr(u), ne.splice(e--, 1), 1 < i.repeat && !i.next) {
											for (r in u) u[N](r) && (f[r] = i.totalOrigin[r]);
											i.el.attr(f), w(i.anim, i.el, i.anim.percents[0], null, i.totalOrigin, i.repeat - 1)
										}
										i.next && !i.stop && w(i.anim, i.el, i.next, null, i.totalOrigin, i.repeat)
									}
							}
						}
						ne.length && re(ae)
					},
					oe = function (t) {
						return 255 < t ? 255 : t < 0 ? 0 : t
					};
				qt.animateWith = function (t, e, i, n, r, a) {
					var o = this;
					if (o.removed) return a && a.call(o), o;
					var s = i instanceof u ? i : R.animation(i, n, r, a);
					w(s, o, s.percents[0], null, o.attr());
					for (var l = 0, h = ne.length; l < h; l++)
						if (ne[l].anim == e && ne[l].el == t) {
							ne[h - 1].start = ne[l].start;
							break
						} return o
				}, qt.onAnimation = function (t) {
					return t ? O.on("raphael.anim.frame." + this.id, t) : O.unbind("raphael.anim.frame." + this.id), this
				}, u.prototype.delay = function (t) {
					var e = new u(this.anim, this.ms);
					return e.times = this.times, e.del = +t || 0, e
				}, u.prototype.repeat = function (t) {
					var e = new u(this.anim, this.ms);
					return e.del = this.del, e.times = G.floor(D(t, 0)) || 1, e
				}, R.animation = function (t, e, i, n) {
					if (t instanceof u) return t;
					!R.is(i, "function") && i || (n = n || i || null, i = null), t = Object(t), e = +e || 0;
					var r, a, o = {};
					for (a in t) t[N](a) && X(a) != a && X(a) + "%" != a && (r = !0, o[a] = t[a]);
					if (r) return i && (o.easing = i), n && (o.callback = n), new u({
						100: o
					}, e);
					if (n) {
						var s = 0;
						for (var l in t) {
							var h = Z(l);
							t[N](l) && s < h && (s = h)
						}!t[s += "%"].callback && (t[s].callback = n)
					}
					return new u(t, e)
				}, qt.animate = function (t, e, i, n) {
					var r = this;
					if (r.removed) return n && n.call(r), r;
					var a = t instanceof u ? t : R.animation(t, e, i, n);
					return w(a, r, a.percents[0], null, r.attr()), r
				}, qt.setTime = function (t, e) {
					return t && null != e && this.status(t, T(e, t.ms) / t.ms), this
				}, qt.status = function (t, e) {
					var i, n, r = [],
						a = 0;
					if (null != e) return w(t, this, -1, T(e, 1)), this;
					for (i = ne.length; a < i; a++)
						if ((n = ne[a]).el.id == this.id && (!t || n.anim == t)) {
							if (t) return n.status;
							r.push({
								anim: n.anim,
								status: n.status
							})
						} return t ? 0 : r
				}, qt.pause = function (t) {
					for (var e = 0; e < ne.length; e++) ne[e].el.id != this.id || t && ne[e].anim != t || !1 !== O("raphael.anim.pause." + this.id, this, ne[e].anim) && (ne[e].paused = !0);
					return this
				}, qt.resume = function (t) {
					for (var e = 0; e < ne.length; e++)
						if (ne[e].el.id == this.id && (!t || ne[e].anim == t)) {
							var i = ne[e];
							!1 !== O("raphael.anim.resume." + this.id, this, i.anim) && (delete i.paused, this.status(i.anim, i.status))
						} return this
				}, qt.stop = function (t) {
					for (var e = 0; e < ne.length; e++) ne[e].el.id != this.id || t && ne[e].anim != t || !1 !== O("raphael.anim.stop." + this.id, this, ne[e].anim) && ne.splice(e--, 1);
					return this
				}, O.on("raphael.remove", t), O.on("raphael.clear", t), qt.toString = function () {
					return "Rapha√´l‚Äôs object"
				};
				var se, le, he, ue, de, ce = function (t) {
						if (this.items = [], this.length = 0, this.type = "set", t)
							for (var e = 0, i = t.length; e < i; e++) !t[e] || t[e].constructor != qt.constructor && t[e].constructor != ce || (this[this.items.length] = this.items[this.items.length] = t[e], this.length++)
					},
					fe = ce.prototype;
				for (var pe in fe.push = function () {
						for (var t, e, i = 0, n = arguments.length; i < n; i++) !(t = arguments[i]) || t.constructor != qt.constructor && t.constructor != ce || (this[e = this.items.length] = this.items[e] = t, this.length++);
						return this
					}, fe.pop = function () {
						return this.length && delete this[this.length--], this.items.pop()
					}, fe.forEach = function (t, e) {
						for (var i = 0, n = this.items.length; i < n; i++)
							if (!1 === t.call(e, this.items[i], i)) return this;
						return this
					}, qt) qt[N](pe) && (fe[pe] = function (i) {
					return function () {
						var e = arguments;
						return this.forEach(function (t) {
							t[i][b](t, e)
						})
					}
				}(pe));
				return fe.attr = function (t, e) {
						if (t && R.is(t, A) && R.is(t[0], "object"))
							for (var i = 0, n = t.length; i < n; i++) this.items[i].attr(t[i]);
						else
							for (var r = 0, a = this.items.length; r < a; r++) this.items[r].attr(t, e);
						return this
					}, fe.clear = function () {
						for (; this.length;) this.pop()
					}, fe.splice = function (t, e, i) {
						t = t < 0 ? D(this.length + t, 0) : t, e = D(0, T(this.length - t, e));
						var n, r = [],
							a = [],
							o = [];
						for (n = 2; n < arguments.length; n++) o.push(arguments[n]);
						for (n = 0; n < e; n++) a.push(this[t + n]);
						for (; n < this.length - t; n++) r.push(this[t + n]);
						var s = o.length;
						for (n = 0; n < s + r.length; n++) this.items[t + n] = this[t + n] = n < s ? o[n] : r[n - s];
						for (n = this.items.length = this.length -= e - s; this[n];) delete this[n++];
						return new ce(a)
					}, fe.exclude = function (t) {
						for (var e = 0, i = this.length; e < i; e++)
							if (this[e] == t) return this.splice(e, 1), !0
					}, fe.animate = function (t, e, i, n) {
						(R.is(i, "function") || !i) && (n = i || null);
						var r, a, o = this.items.length,
							s = o,
							l = this;
						if (!o) return this;
						n && (a = function () {
							!--o && n.call(l)
						}), i = R.is(i, f) ? i : a;
						var h = R.animation(t, e, i, a);
						for (r = this.items[--s].animate(h); s--;) this.items[s] && !this.items[s].removed && this.items[s].animateWith(r, h, h), this.items[s] && !this.items[s].removed || o--;
						return this
					}, fe.insertAfter = function (t) {
						for (var e = this.items.length; e--;) this.items[e].insertAfter(t);
						return this
					}, fe.getBBox = function () {
						for (var t = [], e = [], i = [], n = [], r = this.items.length; r--;)
							if (!this.items[r].removed) {
								var a = this.items[r].getBBox();
								t.push(a.x), e.push(a.y), i.push(a.x + a.width), n.push(a.y + a.height)
							} return {
							x: t = T[b](0, t),
							y: e = T[b](0, e),
							x2: i = D[b](0, i),
							y2: n = D[b](0, n),
							width: i - t,
							height: n - e
						}
					}, fe.clone = function (t) {
						t = this.paper.set();
						for (var e = 0, i = this.items.length; e < i; e++) t.push(this.items[e].clone());
						return t
					}, fe.toString = function () {
						return "Rapha√´l‚Äòs set"
					}, fe.glow = function (n) {
						var r = this.paper.set();
						return this.forEach(function (t, e) {
							var i = t.glow(n);
							null != i && i.forEach(function (t, e) {
								r.push(t)
							})
						}), r
					}, fe.isPointInside = function (e, i) {
						var n = !1;
						return this.forEach(function (t) {
							if (t.isPointInside(e, i)) return !(n = !0)
						}), n
					}, R.registerFont = function (t) {
						if (!t.face) return t;
						this.fonts = this.fonts || {};
						var e = {
								w: t.w,
								face: {},
								glyphs: {}
							},
							i = t.face["font-family"];
						for (var n in t.face) t.face[N](n) && (e.face[n] = t.face[n]);
						if (this.fonts[i] ? this.fonts[i].push(e) : this.fonts[i] = [e], !t.svg)
							for (var r in e.face["units-per-em"] = Z(t.face["units-per-em"], 10), t.glyphs)
								if (t.glyphs[N](r)) {
									var a = t.glyphs[r];
									if (e.glyphs[r] = {
											w: a.w,
											k: {},
											d: a.d && "M" + a.d.replace(/[mlcxtrv]/g, function (t) {
												return {
													l: "L",
													c: "C",
													x: "z",
													t: "m",
													r: "l",
													v: "c"
												} [t] || "M"
											}) + "z"
										}, a.k)
										for (var o in a.k) a[N](o) && (e.glyphs[r].k[o] = a.k[o])
								} return t
					}, e.getFont = function (t, e, i, n) {
						if (n = n || "normal", i = i || "normal", e = +e || {
								normal: 400,
								bold: 700,
								lighter: 300,
								bolder: 800
							} [e] || 400, R.fonts) {
							var r, a = R.fonts[t];
							if (!a) {
								var o = new RegExp("(^|\\s)" + t.replace(/[^\w\d\s+!~.:_-]/g, "") + "(\\s|$)", "i");
								for (var s in R.fonts)
									if (R.fonts[N](s) && o.test(s)) {
										a = R.fonts[s];
										break
									}
							}
							if (a)
								for (var l = 0, h = a.length; l < h && ((r = a[l]).face["font-weight"] != e || r.face["font-style"] != i && r.face["font-style"] || r.face["font-stretch"] != n); l++);
							return r
						}
					}, e.print = function (t, e, i, n, r, a, o, s) {
						a = a || "middle", o = D(T(o || 0, 1), -1), s = D(T(s || 1, 3), 1);
						var l, h = Y(i)[U](""),
							u = 0,
							d = 0,
							c = "";
						if (R.is(n, "string") && (n = this.getFont(n)), n) {
							l = (r || 16) / n.face["units-per-em"];
							for (var f = n.face.bbox[U](z), p = +f[0], g = f[3] - f[1], m = 0, v = +f[1] + ("baseline" == a ? g + +n.face.descent : g / 2), y = 0, x = h.length; y < x; y++) {
								if ("\n" == h[y]) d = _ = u = 0, m += g * s;
								else {
									var b = d && n.glyphs[h[y - 1]] || {},
										_ = n.glyphs[h[y]];
									u += d ? (b.w || n.w) + (b.k && b.k[h[y]] || 0) + n.w * o : 0, d = 1
								}
								_ && _.d && (c += R.transformPath(_.d, ["t", u * l, m * l, "s", l, l, p, v, "t", (t - p) / l, (e - v) / l]))
							}
						}
						return this.path(c).attr({
							fill: "#000",
							stroke: "none"
						})
					}, e.add = function (t) {
						if (R.is(t, "array"))
							for (var e, i = this.set(), n = 0, r = t.length; n < r; n++) e = t[n] || {}, a[N](e.type) && i.push(this[e.type]().attr(e));
						return i
					}, R.format = function (t, e) {
						var i = R.is(e, A) ? [0][j](e) : arguments;
						return t && R.is(t, f) && i.length - 1 && (t = t.replace(o, function (t, e) {
							return null == i[++e] ? "" : i[e]
						})), t || ""
					}, R.fullfill = (ue = /\{([^\}]+)\}/g, de = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, function (t, r) {
						return String(t).replace(ue, function (t, e) {
							return i = t, a = n = r, e.replace(de, function (t, e, i, n, r) {
								e = e || n, a && (e in a && (a = a[e]), "function" == typeof a && r && (a = a()))
							}), a = (null == a || a == n ? i : a) + "";
							var i, n, a
						})
					}), R.ninja = function () {
						if (s.was) p.win.Raphael = s.is;
						else {
							window.Raphael = void 0;
							try {
								delete window.Raphael
							} catch (t) {}
						}
						return R
					}, R.st = fe, O.on("raphael.DOMload", function () {
						n = !0
					}), se = document, le = "DOMContentLoaded", null == se.readyState && se.addEventListener && (se.addEventListener(le, he = function () {
						se.removeEventListener(le, he, !1), se.readyState = "complete"
					}, !1), se.readyState = "loading"),
					function t() {
						/in/.test(se.readyState) ? setTimeout(t, 9) : R.eve("raphael.DOMload")
					}(), R
			}.apply(e, n)) || (t.exports = r)
		}, function (t, e, i) {
			var n, f, p, c, g, m, v, y, x, b, r, _, w;
			c = "hasOwnProperty", g = /[\.\/]/, m = /\s*,\s*/, v = function (t, e) {
				return t - e
			}, y = {
				n: {}
			}, x = function () {
				for (var t = 0, e = this.length; t < e; t++)
					if (void 0 !== this[t]) return this[t]
			}, b = function () {
				for (var t = this.length; --t;)
					if (void 0 !== this[t]) return this[t]
			}, r = Object.prototype.toString, _ = String, w = Array.isArray || function (t) {
				return t instanceof Array || "[object Array]" == r.call(t)
			}, eve = function (t, e) {
				var i, n = p,
					r = Array.prototype.slice.call(arguments, 2),
					a = eve.listeners(t),
					o = 0,
					s = [],
					l = {},
					h = [],
					u = f;
				h.firstDefined = x, h.lastDefined = b, f = t;
				for (var d = p = 0, c = a.length; d < c; d++) "zIndex" in a[d] && (s.push(a[d].zIndex), a[d].zIndex < 0 && (l[a[d].zIndex] = a[d]));
				for (s.sort(v); s[o] < 0;)
					if (i = l[s[o++]], h.push(i.apply(e, r)), p) return p = n, h;
				for (d = 0; d < c; d++)
					if ("zIndex" in (i = a[d]))
						if (i.zIndex == s[o]) {
							if (h.push(i.apply(e, r)), p) break;
							do {
								if ((i = l[s[++o]]) && h.push(i.apply(e, r)), p) break
							} while (i)
						} else l[i.zIndex] = i;
				else if (h.push(i.apply(e, r)), p) break;
				return p = n, f = u, h
			}, eve._events = y, eve.listeners = function (t) {
				var e, i, n, r, a, o, s, l, h = w(t) ? t : t.split(g),
					u = y,
					d = [u],
					c = [];
				for (r = 0, a = h.length; r < a; r++) {
					for (l = [], o = 0, s = d.length; o < s; o++)
						for (i = [(u = d[o].n)[h[r]], u["*"]], n = 2; n--;)(e = i[n]) && (l.push(e), c = c.concat(e.f || []));
					d = l
				}
				return c
			}, eve.separator = function (t) {
				g = t ? (t = "[" + (t = _(t).replace(/(?=[\.\^\]\[\-])/g, "\\")) + "]", new RegExp(t)) : /[\.\/]/
			}, eve.on = function (t, o) {
				if ("function" != typeof o) return function () {};
				for (var e = w(t) ? w(t[0]) ? t : [t] : _(t).split(m), i = 0, n = e.length; i < n; i++) ! function (t) {
					for (var e, i = w(t) ? t : _(t).split(g), n = y, r = 0, a = i.length; r < a; r++) n = (n = n.n).hasOwnProperty(i[r]) && n[i[r]] || (n[i[r]] = {
						n: {}
					});
					for (n.f = n.f || [], r = 0, a = n.f.length; r < a; r++)
						if (n.f[r] == o) {
							e = !0;
							break
						}! e && n.f.push(o)
				}(e[i]);
				return function (t) {
					+t == +t && (o.zIndex = +t)
				}
			}, eve.f = function (t) {
				var e = [].slice.call(arguments, 1);
				return function () {
					eve.apply(null, [t, null].concat(e).concat([].slice.call(arguments, 0)))
				}
			}, eve.stop = function () {
				p = 1
			}, eve.nt = function (t) {
				var e = w(f) ? f.join(".") : f;
				return t ? new RegExp("(?:\\.|\\/|^)" + t + "(?:\\.|\\/|$)").test(e) : e
			}, eve.nts = function () {
				return w(f) ? f : f.split(g)
			}, eve.off = eve.unbind = function (t, e) {
				if (t) {
					var i = w(t) ? w(t[0]) ? t : [t] : _(t).split(m);
					if (1 < i.length)
						for (var n = 0, r = i.length; n < r; n++) eve.off(i[n], e);
					else {
						i = w(t) ? t : _(t).split(g);
						var a, o, s, l, h, u = [y];
						for (n = 0, r = i.length; n < r; n++)
							for (l = 0; l < u.length; l += s.length - 2) {
								if (s = [l, 1], a = u[l].n, "*" != i[n]) a[i[n]] && s.push(a[i[n]]);
								else
									for (o in a) a[c](o) && s.push(a[o]);
								u.splice.apply(u, s)
							}
						for (n = 0, r = u.length; n < r; n++)
							for (a = u[n]; a.n;) {
								if (e) {
									if (a.f) {
										for (l = 0, h = a.f.length; l < h; l++)
											if (a.f[l] == e) {
												a.f.splice(l, 1);
												break
											}! a.f.length && delete a.f
									}
									for (o in a.n)
										if (a.n[c](o) && a.n[o].f) {
											var d = a.n[o].f;
											for (l = 0, h = d.length; l < h; l++)
												if (d[l] == e) {
													d.splice(l, 1);
													break
												}! d.length && delete a.n[o].f
										}
								} else
									for (o in delete a.f, a.n) a.n[c](o) && a.n[o].f && delete a.n[o].f;
								a = a.n
							}
					}
				} else eve._events = y = {
					n: {}
				}
			}, eve.once = function (t, e) {
				var i = function () {
					return eve.off(t, i), e.apply(this, arguments)
				};
				return eve.on(t, i)
			}, eve.version = "0.5.0", eve.toString = function () {
				return "You are running Eve 0.5.0"
			}, void 0 !== t && t.exports ? t.exports = eve : void 0 === (n = function () {
				return eve
			}.apply(e, [])) || (t.exports = n)
		}, function (t, e, i) {
			var n, r;
			n = [i(1)], void 0 === (r = function (S) {
				if (!S || S.svg) {
					var C = "hasOwnProperty",
						D = String,
						m = parseFloat,
						w = parseInt,
						v = Math,
						k = v.max,
						M = v.abs,
						y = v.pow,
						T = /[, ]+/,
						c = S.eve,
						P = "http://www.w3.org/1999/xlink",
						A = {
							block: "M5,0 0,2.5 5,5z",
							classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
							diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
							open: "M6,1 1,3.5 6,6",
							oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
						},
						F = {};
					S.toString = function () {
						return "Your browser supports SVG.\nYou are running Rapha√´l " + this.version
					};
					var I = function (t, e) {
							if (e)
								for (var i in "string" == typeof t && (t = I(t)), e) e[C](i) && ("xlink:" == i.substring(0, 6) ? t.setAttributeNS(P, i.substring(6), D(e[i])) : t.setAttribute(i, D(e[i])));
							else(t = S._g.doc.createElementNS("http://www.w3.org/2000/svg", t)).style && (t.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
							return t
						},
						L = function (t, e) {
							var r = "linear",
								i = t.id + e,
								a = .5,
								o = .5,
								n = t.node,
								s = t.paper,
								l = n.style,
								h = S._g.doc.getElementById(i);
							if (!h) {
								if (e = (e = D(e).replace(S._radial_gradient, function (t, e, i) {
										if (r = "radial", e && i) {
											a = m(e);
											var n = 2 * (.5 < (o = m(i))) - 1;
											.25 < y(a - .5, 2) + y(o - .5, 2) && (o = v.sqrt(.25 - y(a - .5, 2)) * n + .5) && .5 != o && (o = o.toFixed(5) - 1e-5 * n)
										}
										return ""
									})).split(/\s*\-\s*/), "linear" == r) {
									var u = e.shift();
									if (u = -m(u), isNaN(u)) return null;
									var d = [0, 0, v.cos(S.rad(u)), v.sin(S.rad(u))],
										c = 1 / (k(M(d[2]), M(d[3])) || 1);
									d[2] *= c, d[3] *= c, d[2] < 0 && (d[0] = -d[2], d[2] = 0), d[3] < 0 && (d[1] = -d[3], d[3] = 0)
								}
								var f = S._parseDots(e);
								if (!f) return null;
								if (i = i.replace(/[\(\)\s,\xb0#]/g, "_"), t.gradient && i != t.gradient.id && (s.defs.removeChild(t.gradient), delete t.gradient), !t.gradient) {
									h = I(r + "Gradient", {
										id: i
									}), t.gradient = h, I(h, "radial" == r ? {
										fx: a,
										fy: o
									} : {
										x1: d[0],
										y1: d[1],
										x2: d[2],
										y2: d[3],
										gradientTransform: t.matrix.invert()
									}), s.defs.appendChild(h);
									for (var p = 0, g = f.length; p < g; p++) h.appendChild(I("stop", {
										offset: f[p].offset ? f[p].offset : p ? "100%" : "0%",
										"stop-color": f[p].color || "#fff",
										"stop-opacity": isFinite(f[p].opacity) ? f[p].opacity : 1
									}))
								}
							}
							return I(n, {
								fill: x(i),
								opacity: 1,
								"fill-opacity": 1
							}), l.fill = "", l.opacity = 1, l.fillOpacity = 1
						},
						x = function (t) {
							if ((e = document.documentMode) && (9 === e || 10 === e)) return "url('#" + t + "')";
							var e, i = document.location;
							return "url('" + (i.protocol + "//" + i.host + i.pathname + i.search) + "#" + t + "')"
						},
						O = function (t) {
							var e = t.getBBox(1);
							I(t.pattern, {
								patternTransform: t.matrix.invert() + " translate(" + e.x + "," + e.y + ")"
							})
						},
						R = function (t, e, i) {
							if ("path" == t.type) {
								for (var n, r, a, o, s, l = D(e).toLowerCase().split("-"), h = t.paper, u = i ? "end" : "start", d = t.node, c = t.attrs, f = c["stroke-width"], p = l.length, g = "classic", m = 3, v = 3, y = 5; p--;) switch (l[p]) {
									case "block":
									case "classic":
									case "oval":
									case "diamond":
									case "open":
									case "none":
										g = l[p];
										break;
									case "wide":
										v = 5;
										break;
									case "narrow":
										v = 2;
										break;
									case "long":
										m = 5;
										break;
									case "short":
										m = 2
								}
								if (s = "open" == g ? (m += 2, v += 2, y += 2, a = 1, o = i ? 4 : 1, {
										fill: "none",
										stroke: c.stroke
									}) : (o = a = m / 2, {
										fill: c.stroke,
										stroke: "none"
									}), t._.arrows ? i ? (t._.arrows.endPath && F[t._.arrows.endPath]--, t._.arrows.endMarker && F[t._.arrows.endMarker]--) : (t._.arrows.startPath && F[t._.arrows.startPath]--, t._.arrows.startMarker && F[t._.arrows.startMarker]--) : t._.arrows = {}, "none" != g) {
									var x = "raphael-marker-" + g,
										b = "raphael-marker-" + u + g + m + v + "-obj" + t.id;
									S._g.doc.getElementById(x) ? F[x]++ : (h.defs.appendChild(I(I("path"), {
										"stroke-linecap": "round",
										d: A[g],
										id: x
									})), F[x] = 1);
									var _, w = S._g.doc.getElementById(b);
									w ? (F[b]++, _ = w.getElementsByTagName("use")[0]) : (w = I(I("marker"), {
										id: b,
										markerHeight: v,
										markerWidth: m,
										orient: "auto",
										refX: o,
										refY: v / 2
									}), _ = I(I("use"), {
										"xlink:href": "#" + x,
										transform: (i ? "rotate(180 " + m / 2 + " " + v / 2 + ") " : "") + "scale(" + m / y + "," + v / y + ")",
										"stroke-width": (1 / ((m / y + v / y) / 2)).toFixed(4)
									}), w.appendChild(_), h.defs.appendChild(w), F[b] = 1), I(_, s);
									var k = a * ("diamond" != g && "oval" != g);
									r = i ? (n = t._.arrows.startdx * f || 0, S.getTotalLength(c.path) - k * f) : (n = k * f, S.getTotalLength(c.path) - (t._.arrows.enddx * f || 0)), (s = {})["marker-" + u] = "url(#" + b + ")", (r || n) && (s.d = S.getSubpath(c.path, n, r)), I(d, s), t._.arrows[u + "Path"] = x, t._.arrows[u + "Marker"] = b, t._.arrows[u + "dx"] = k, t._.arrows[u + "Type"] = g, t._.arrows[u + "String"] = e
								} else r = i ? (n = t._.arrows.startdx * f || 0, S.getTotalLength(c.path) - n) : (n = 0, S.getTotalLength(c.path) - (t._.arrows.enddx * f || 0)), t._.arrows[u + "Path"] && I(d, {
									d: S.getSubpath(c.path, n, r)
								}), delete t._.arrows[u + "Path"], delete t._.arrows[u + "Marker"], delete t._.arrows[u + "dx"], delete t._.arrows[u + "Type"], delete t._.arrows[u + "String"];
								for (s in F)
									if (F[C](s) && !F[s]) {
										var M = S._g.doc.getElementById(s);
										M && M.parentNode.removeChild(M)
									}
							}
						},
						s = {
							"-": [3, 1],
							".": [1, 1],
							"-.": [3, 1, 1, 1],
							"-..": [3, 1, 1, 1, 1, 1],
							". ": [1, 3],
							"- ": [4, 3],
							"--": [8, 3],
							"- .": [4, 3, 1, 3],
							"--.": [8, 3, 1, 3],
							"--..": [8, 3, 1, 3, 1, 3]
						},
						B = function (t, e, i) {
							if (e = s[D(e).toLowerCase()]) {
								for (var n = t.attrs["stroke-width"] || "1", r = {
										round: n,
										square: n,
										butt: 0
									} [t.attrs["stroke-linecap"] || i["stroke-linecap"]] || 0, a = [], o = e.length; o--;) a[o] = e[o] * n + (o % 2 ? 1 : -1) * r;
								I(t.node, {
									"stroke-dasharray": a.join(",")
								})
							} else I(t.node, {
								"stroke-dasharray": "none"
							})
						},
						f = function (t, e) {
							var i = t.node,
								n = t.attrs,
								r = i.style.visibility;
							for (var a in i.style.visibility = "hidden", e)
								if (e[C](a)) {
									if (!S._availableAttrs[C](a)) continue;
									var o = e[a];
									switch (n[a] = o, a) {
										case "blur":
											t.blur(o);
											break;
										case "title":
											var s = i.getElementsByTagName("title");
											if (s.length && (s = s[0])) s.firstChild.nodeValue = o;
											else {
												s = I("title");
												var l = S._g.doc.createTextNode(o);
												s.appendChild(l), i.appendChild(s)
											}
											break;
										case "href":
										case "target":
											var h = i.parentNode;
											if ("a" != h.tagName.toLowerCase()) {
												var u = I("a");
												h.insertBefore(u, i), u.appendChild(i), h = u
											}
											"target" == a ? h.setAttributeNS(P, "show", "blank" == o ? "new" : o) : h.setAttributeNS(P, a, o);
											break;
										case "cursor":
											i.style.cursor = o;
											break;
										case "transform":
											t.transform(o);
											break;
										case "arrow-start":
											R(t, o);
											break;
										case "arrow-end":
											R(t, o, 1);
											break;
										case "clip-rect":
											var d = D(o).split(T);
											if (4 == d.length) {
												t.clip && t.clip.parentNode.parentNode.removeChild(t.clip.parentNode);
												var c = I("clipPath"),
													f = I("rect");
												c.id = S.createUUID(), I(f, {
													x: d[0],
													y: d[1],
													width: d[2],
													height: d[3]
												}), c.appendChild(f), t.paper.defs.appendChild(c), I(i, {
													"clip-path": "url(#" + c.id + ")"
												}), t.clip = f
											}
											if (!o) {
												var p = i.getAttribute("clip-path");
												if (p) {
													var g = S._g.doc.getElementById(p.replace(/(^url\(#|\)$)/g, ""));
													g && g.parentNode.removeChild(g), I(i, {
														"clip-path": ""
													}), delete t.clip
												}
											}
											break;
										case "path":
											"path" == t.type && (I(i, {
												d: o ? n.path = S._pathToAbsolute(o) : "M0,0"
											}), t._.dirty = 1, t._.arrows && ("startString" in t._.arrows && R(t, t._.arrows.startString), "endString" in t._.arrows && R(t, t._.arrows.endString, 1)));
											break;
										case "width":
											if (i.setAttribute(a, o), t._.dirty = 1, !n.fx) break;
											a = "x", o = n.x;
										case "x":
											n.fx && (o = -n.x - (n.width || 0));
										case "rx":
											if ("rx" == a && "rect" == t.type) break;
										case "cx":
											i.setAttribute(a, o), t.pattern && O(t), t._.dirty = 1;
											break;
										case "height":
											if (i.setAttribute(a, o), t._.dirty = 1, !n.fy) break;
											a = "y", o = n.y;
										case "y":
											n.fy && (o = -n.y - (n.height || 0));
										case "ry":
											if ("ry" == a && "rect" == t.type) break;
										case "cy":
											i.setAttribute(a, o), t.pattern && O(t), t._.dirty = 1;
											break;
										case "r":
											"rect" == t.type ? I(i, {
												rx: o,
												ry: o
											}) : i.setAttribute(a, o), t._.dirty = 1;
											break;
										case "src":
											"image" == t.type && i.setAttributeNS(P, "href", o);
											break;
										case "stroke-width":
											1 == t._.sx && 1 == t._.sy || (o /= k(M(t._.sx), M(t._.sy)) || 1), i.setAttribute(a, o), n["stroke-dasharray"] && B(t, n["stroke-dasharray"], e), t._.arrows && ("startString" in t._.arrows && R(t, t._.arrows.startString), "endString" in t._.arrows && R(t, t._.arrows.endString, 1));
											break;
										case "stroke-dasharray":
											B(t, o, e);
											break;
										case "fill":
											var m = D(o).match(S._ISURL);
											if (m) {
												c = I("pattern");
												var v = I("image");
												c.id = S.createUUID(), I(c, {
														x: 0,
														y: 0,
														patternUnits: "userSpaceOnUse",
														height: 1,
														width: 1
													}), I(v, {
														x: 0,
														y: 0,
														"xlink:href": m[1]
													}), c.appendChild(v),
													function (i) {
														S._preload(m[1], function () {
															var t = this.offsetWidth,
																e = this.offsetHeight;
															I(i, {
																width: t,
																height: e
															}), I(v, {
																width: t,
																height: e
															})
														})
													}(c), t.paper.defs.appendChild(c), I(i, {
														fill: "url(#" + c.id + ")"
													}), t.pattern = c, t.pattern && O(t);
												break
											}
											var y = S.getRGB(o);
											if (y.error) {
												if (("circle" == t.type || "ellipse" == t.type || "r" != D(o).charAt()) && L(t, o)) {
													if ("opacity" in n || "fill-opacity" in n) {
														var x = S._g.doc.getElementById(i.getAttribute("fill").replace(/^url\(#|\)$/g, ""));
														if (x) {
															var b = x.getElementsByTagName("stop");
															I(b[b.length - 1], {
																"stop-opacity": ("opacity" in n ? n.opacity : 1) * ("fill-opacity" in n ? n["fill-opacity"] : 1)
															})
														}
													}
													n.gradient = o, n.fill = "none";
													break
												}
											} else delete e.gradient, delete n.gradient, !S.is(n.opacity, "undefined") && S.is(e.opacity, "undefined") && I(i, {
												opacity: n.opacity
											}), !S.is(n["fill-opacity"], "undefined") && S.is(e["fill-opacity"], "undefined") && I(i, {
												"fill-opacity": n["fill-opacity"]
											});
											y[C]("opacity") && I(i, {
												"fill-opacity": 1 < y.opacity ? y.opacity / 100 : y.opacity
											});
										case "stroke":
											y = S.getRGB(o), i.setAttribute(a, y.hex), "stroke" == a && y[C]("opacity") && I(i, {
												"stroke-opacity": 1 < y.opacity ? y.opacity / 100 : y.opacity
											}), "stroke" == a && t._.arrows && ("startString" in t._.arrows && R(t, t._.arrows.startString), "endString" in t._.arrows && R(t, t._.arrows.endString, 1));
											break;
										case "gradient":
											("circle" == t.type || "ellipse" == t.type || "r" != D(o).charAt()) && L(t, o);
											break;
										case "opacity":
											n.gradient && !n[C]("stroke-opacity") && I(i, {
												"stroke-opacity": 1 < o ? o / 100 : o
											});
										case "fill-opacity":
											if (n.gradient) {
												(x = S._g.doc.getElementById(i.getAttribute("fill").replace(/^url\(#|\)$/g, ""))) && (b = x.getElementsByTagName("stop"), I(b[b.length - 1], {
													"stop-opacity": o
												}));
												break
											}
											default:
												"font-size" == a && (o = w(o, 10) + "px");
												var _ = a.replace(/(\-.)/g, function (t) {
													return t.substring(1).toUpperCase()
												});
												i.style[_] = o, t._.dirty = 1, i.setAttribute(a, o)
									}
								} W(t, e), i.style.visibility = r
						},
						W = function (t, e) {
							if ("text" == t.type && (e[C]("text") || e[C]("font") || e[C]("font-size") || e[C]("x") || e[C]("y"))) {
								var i = t.attrs,
									n = t.node,
									r = n.firstChild ? w(S._g.doc.defaultView.getComputedStyle(n.firstChild, "").getPropertyValue("font-size"), 10) : 10;
								if (e[C]("text")) {
									for (i.text = e.text; n.firstChild;) n.removeChild(n.firstChild);
									for (var a, o = D(e.text).split("\n"), s = [], l = 0, h = o.length; l < h; l++) a = I("tspan"), l && I(a, {
										dy: 1.2 * r,
										x: i.x
									}), a.appendChild(S._g.doc.createTextNode(o[l])), n.appendChild(a), s[l] = a
								} else
									for (l = 0, h = (s = n.getElementsByTagName("tspan")).length; l < h; l++) l ? I(s[l], {
										dy: 1.2 * r,
										x: i.x
									}) : I(s[0], {
										dy: 0
									});
								I(n, {
									x: i.x,
									y: i.y
								}), t._.dirty = 1;
								var u = t._getBBox(),
									d = i.y - (u.y + u.height / 2);
								d && S.is(d, "finite") && I(s[0], {
									dy: d
								})
							}
						},
						n = function (t) {
							return t.parentNode && "a" === t.parentNode.tagName.toLowerCase() ? t.parentNode : t
						},
						l = function (t, e) {
							this[0] = this.node = t, t.raphael = !0, this.id = ("0000" + (Math.random() * Math.pow(36, 5) << 0).toString(36)).slice(-5), t.raphaelid = this.id, this.matrix = S.matrix(), this.realPath = null, this.paper = e, this.attrs = this.attrs || {}, this._ = {
								transform: [],
								sx: 1,
								sy: 1,
								deg: 0,
								dx: 0,
								dy: 0,
								dirty: 1
							}, !e.bottom && (e.bottom = this), this.prev = e.top, e.top && (e.top.next = this), (e.top = this).next = null
						},
						t = S.el;
					(l.prototype = t).constructor = l, S._engine.path = function (t, e) {
						var i = I("path");
						e.canvas && e.canvas.appendChild(i);
						var n = new l(i, e);
						return n.type = "path", f(n, {
							fill: "none",
							stroke: "#000",
							path: t
						}), n
					}, t.rotate = function (t, e, i) {
						if (this.removed) return this;
						if ((t = D(t).split(T)).length - 1 && (e = m(t[1]), i = m(t[2])), t = m(t[0]), null == i && (e = i), null == e || null == i) {
							var n = this.getBBox(1);
							e = n.x + n.width / 2, i = n.y + n.height / 2
						}
						return this.transform(this._.transform.concat([["r", t, e, i]])), this
					}, t.scale = function (t, e, i, n) {
						if (this.removed) return this;
						if ((t = D(t).split(T)).length - 1 && (e = m(t[1]), i = m(t[2]), n = m(t[3])), t = m(t[0]), null == e && (e = t), null == n && (i = n), null == i || null == n) var r = this.getBBox(1);
						return i = null == i ? r.x + r.width / 2 : i, n = null == n ? r.y + r.height / 2 : n, this.transform(this._.transform.concat([["s", t, e, i, n]])), this
					}, t.translate = function (t, e) {
						return this.removed || ((t = D(t).split(T)).length - 1 && (e = m(t[1])), t = m(t[0]) || 0, e = +e || 0, this.transform(this._.transform.concat([["t", t, e]]))), this
					}, t.transform = function (t) {
						var e = this._;
						if (null == t) return e.transform;
						if (S._extractTransform(this, t), this.clip && I(this.clip, {
								transform: this.matrix.invert()
							}), this.pattern && O(this), this.node && I(this.node, {
								transform: this.matrix
							}), 1 != e.sx || 1 != e.sy) {
							var i = this.attrs[C]("stroke-width") ? this.attrs["stroke-width"] : 1;
							this.attr({
								"stroke-width": i
							})
						}
						return this
					}, t.hide = function () {
						return this.removed || (this.node.style.display = "none"), this
					}, t.show = function () {
						return this.removed || (this.node.style.display = ""), this
					}, t.remove = function () {
						var t = n(this.node);
						if (!this.removed && t.parentNode) {
							var e = this.paper;
							for (var i in e.__set__ && e.__set__.exclude(this), c.unbind("raphael.*.*." + this.id), this.gradient && e.defs.removeChild(this.gradient), S._tear(this, e), t.parentNode.removeChild(t), this.removeData(), this) this[i] = "function" == typeof this[i] ? S._removedFactory(i) : null;
							this.removed = !0
						}
					}, t._getBBox = function () {
						if ("none" == this.node.style.display) {
							this.show();
							var t = !0
						}
						var e, i = !1;
						this.paper.canvas.parentElement ? e = this.paper.canvas.parentElement.style : this.paper.canvas.parentNode && (e = this.paper.canvas.parentNode.style), e && "none" == e.display && (i = !0, e.display = "");
						var n = {};
						try {
							n = this.node.getBBox()
						} catch (t) {
							n = {
								x: this.node.clientLeft,
								y: this.node.clientTop,
								width: this.node.clientWidth,
								height: this.node.clientHeight
							}
						} finally {
							n = n || {}, i && (e.display = "none")
						}
						return t && this.hide(), n
					}, t.attr = function (t, e) {
						if (this.removed) return this;
						if (null == t) {
							var i = {};
							for (var n in this.attrs) this.attrs[C](n) && (i[n] = this.attrs[n]);
							return i.gradient && "none" == i.fill && (i.fill = i.gradient) && delete i.gradient, i.transform = this._.transform, i
						}
						if (null == e && S.is(t, "string")) {
							if ("fill" == t && "none" == this.attrs.fill && this.attrs.gradient) return this.attrs.gradient;
							if ("transform" == t) return this._.transform;
							for (var r = t.split(T), a = {}, o = 0, s = r.length; o < s; o++)(t = r[o]) in this.attrs ? a[t] = this.attrs[t] : S.is(this.paper.customAttributes[t], "function") ? a[t] = this.paper.customAttributes[t].def : a[t] = S._availableAttrs[t];
							return s - 1 ? a : a[r[0]]
						}
						if (null == e && S.is(t, "array")) {
							for (a = {}, o = 0, s = t.length; o < s; o++) a[t[o]] = this.attr(t[o]);
							return a
						}
						if (null != e) {
							var l = {};
							l[t] = e
						} else null != t && S.is(t, "object") && (l = t);
						for (var h in l) c("raphael.attr." + h + "." + this.id, this, l[h]);
						for (h in this.paper.customAttributes)
							if (this.paper.customAttributes[C](h) && l[C](h) && S.is(this.paper.customAttributes[h], "function")) {
								var u = this.paper.customAttributes[h].apply(this, [].concat(l[h]));
								for (var d in this.attrs[h] = l[h], u) u[C](d) && (l[d] = u[d])
							} return f(this, l), this
					}, t.toFront = function () {
						if (this.removed) return this;
						var t = n(this.node);
						t.parentNode.appendChild(t);
						var e = this.paper;
						return e.top != this && S._tofront(this, e), this
					}, t.toBack = function () {
						if (this.removed) return this;
						var t = n(this.node),
							e = t.parentNode;
						e.insertBefore(t, e.firstChild), S._toback(this, this.paper);
						this.paper;
						return this
					}, t.insertAfter = function (t) {
						if (this.removed || !t) return this;
						var e = n(this.node),
							i = n(t.node || t[t.length - 1].node);
						return i.nextSibling ? i.parentNode.insertBefore(e, i.nextSibling) : i.parentNode.appendChild(e), S._insertafter(this, t, this.paper), this
					}, t.insertBefore = function (t) {
						if (this.removed || !t) return this;
						var e = n(this.node),
							i = n(t.node || t[0].node);
						return i.parentNode.insertBefore(e, i), S._insertbefore(this, t, this.paper), this
					}, t.blur = function (t) {
						var e = this;
						if (0 != +t) {
							var i = I("filter"),
								n = I("feGaussianBlur");
							e.attrs.blur = t, i.id = S.createUUID(), I(n, {
								stdDeviation: +t || 1.5
							}), i.appendChild(n), e.paper.defs.appendChild(i), e._blur = i, I(e.node, {
								filter: "url(#" + i.id + ")"
							})
						} else e._blur && (e._blur.parentNode.removeChild(e._blur), delete e._blur, delete e.attrs.blur), e.node.removeAttribute("filter");
						return e
					}, S._engine.circle = function (t, e, i, n) {
						var r = I("circle");
						t.canvas && t.canvas.appendChild(r);
						var a = new l(r, t);
						return a.attrs = {
							cx: e,
							cy: i,
							r: n,
							fill: "none",
							stroke: "#000"
						}, a.type = "circle", I(r, a.attrs), a
					}, S._engine.rect = function (t, e, i, n, r, a) {
						var o = I("rect");
						t.canvas && t.canvas.appendChild(o);
						var s = new l(o, t);
						return s.attrs = {
							x: e,
							y: i,
							width: n,
							height: r,
							rx: a || 0,
							ry: a || 0,
							fill: "none",
							stroke: "#000"
						}, s.type = "rect", I(o, s.attrs), s
					}, S._engine.ellipse = function (t, e, i, n, r) {
						var a = I("ellipse");
						t.canvas && t.canvas.appendChild(a);
						var o = new l(a, t);
						return o.attrs = {
							cx: e,
							cy: i,
							rx: n,
							ry: r,
							fill: "none",
							stroke: "#000"
						}, o.type = "ellipse", I(a, o.attrs), o
					}, S._engine.image = function (t, e, i, n, r, a) {
						var o = I("image");
						I(o, {
							x: i,
							y: n,
							width: r,
							height: a,
							preserveAspectRatio: "none"
						}), o.setAttributeNS(P, "href", e), t.canvas && t.canvas.appendChild(o);
						var s = new l(o, t);
						return s.attrs = {
							x: i,
							y: n,
							width: r,
							height: a,
							src: e
						}, s.type = "image", s
					}, S._engine.text = function (t, e, i, n) {
						var r = I("text");
						t.canvas && t.canvas.appendChild(r);
						var a = new l(r, t);
						return a.attrs = {
							x: e,
							y: i,
							"text-anchor": "middle",
							text: n,
							"font-family": S._availableAttrs["font-family"],
							"font-size": S._availableAttrs["font-size"],
							stroke: "none",
							fill: "#000"
						}, a.type = "text", f(a, a.attrs), a
					}, S._engine.setSize = function (t, e) {
						return this.width = t || this.width, this.height = e || this.height, this.canvas.setAttribute("width", this.width), this.canvas.setAttribute("height", this.height), this._viewBox && this.setViewBox.apply(this, this._viewBox), this
					}, S._engine.create = function () {
						var t = S._getContainer.apply(0, arguments),
							e = t && t.container,
							i = t.x,
							n = t.y,
							r = t.width,
							a = t.height;
						if (!e) throw new Error("SVG container not found.");
						var o, s = I("svg"),
							l = "overflow:hidden;";
						return i = i || 0, n = n || 0, I(s, {
							height: a = a || 342,
							version: 1.1,
							width: r = r || 512,
							xmlns: "http://www.w3.org/2000/svg",
							"xmlns:xlink": "http://www.w3.org/1999/xlink"
						}), 1 == e ? (s.style.cssText = l + "position:absolute;left:" + i + "px;top:" + n + "px", S._g.doc.body.appendChild(s), o = 1) : (s.style.cssText = l + "position:relative", e.firstChild ? e.insertBefore(s, e.firstChild) : e.appendChild(s)), (e = new S._Paper).width = r, e.height = a, e.canvas = s, e.clear(), e._left = e._top = 0, o && (e.renderfix = function () {}), e.renderfix(), e
					}, S._engine.setViewBox = function (t, e, i, n, r) {
						c("raphael.setViewBox", this, this._viewBox, [t, e, i, n, r]);
						var a, o, s = this.getSize(),
							l = k(i / s.width, n / s.height),
							h = this.top,
							u = r ? "xMidYMid meet" : "xMinYMin";
						for (a = null == t ? (this._vbSize && (l = 1), delete this._vbSize, "0 0 " + this.width + " " + this.height) : (this._vbSize = l, t + " " + e + " " + i + " " + n), I(this.canvas, {
								viewBox: a,
								preserveAspectRatio: u
							}); l && h;) o = "stroke-width" in h.attrs ? h.attrs["stroke-width"] : 1, h.attr({
							"stroke-width": o
						}), h._.dirty = 1, h._.dirtyT = 1, h = h.prev;
						return this._viewBox = [t, e, i, n, !!r], this
					}, S.prototype.renderfix = function () {
						var e, i = this.canvas,
							t = i.style;
						try {
							e = i.getScreenCTM() || i.createSVGMatrix()
						} catch (t) {
							e = i.createSVGMatrix()
						}
						var n = -e.e % 1,
							r = -e.f % 1;
						(n || r) && (n && (this._left = (this._left + n) % 1, t.left = this._left + "px"), r && (this._top = (this._top + r) % 1, t.top = this._top + "px"))
					}, S.prototype.clear = function () {
						S.eve("raphael.clear", this);
						for (var t = this.canvas; t.firstChild;) t.removeChild(t.firstChild);
						this.bottom = this.top = null, (this.desc = I("desc")).appendChild(S._g.doc.createTextNode("Created with Rapha√´l " + S.version)), t.appendChild(this.desc), t.appendChild(this.defs = I("defs"))
					}, S.prototype.remove = function () {
						for (var t in c("raphael.remove", this), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this) this[t] = "function" == typeof this[t] ? S._removedFactory(t) : null
					};
					var e = S.st;
					for (var i in t) t[C](i) && !e[C](i) && (e[i] = function (i) {
						return function () {
							var e = arguments;
							return this.forEach(function (t) {
								t[i].apply(t, e)
							})
						}
					}(i))
				}
			}.apply(e, n)) || (t.exports = r)
		}, function (t, e, i) {
			var n, r;
			n = [i(1)], void 0 === (r = function (I) {
				if (!I || I.vml) {
					var L = "hasOwnProperty",
						O = String,
						R = parseFloat,
						d = Math,
						B = d.round,
						W = d.max,
						z = d.min,
						v = d.abs,
						N = "fill",
						Y = /[, ]+/,
						c = I.eve,
						E = " ",
						H = {
							M: "m",
							L: "l",
							C: "c",
							Z: "x",
							m: "t",
							l: "r",
							c: "v",
							z: "x"
						},
						V = /([clmz]),?([^clmz]*)/gi,
						n = / progid:\S+Blur\([^\)]+\)/g,
						j = /-?[^,\s-]+/g,
						u = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",
						U = 21600,
						G = {
							path: 1,
							rect: 1,
							image: 1
						},
						$ = {
							circle: 1,
							ellipse: 1
						},
						y = function (t, e, i) {
							var n = I.matrix();
							return n.rotate(-t, .5, .5), {
								dx: n.x(e, i),
								dy: n.y(e, i)
							}
						},
						q = function (t, e, i, n, r, a) {
							var o = t._,
								s = t.matrix,
								l = o.fillpos,
								h = t.node,
								u = h.style,
								d = 1,
								c = "",
								f = U / e,
								p = U / i;
							if (u.visibility = "hidden", e && i) {
								if (h.coordsize = v(f) + E + v(p), u.rotation = a * (e * i < 0 ? -1 : 1), a) {
									var g = y(a, n, r);
									n = g.dx, r = g.dy
								}
								if (e < 0 && (c += "x"), i < 0 && (c += " y") && (d = -1), u.flip = c, h.coordorigin = n * -f + E + r * -p, l || o.fillsize) {
									var m = h.getElementsByTagName(N);
									m = m && m[0], h.removeChild(m), l && (g = y(a, s.x(l[0], l[1]), s.y(l[0], l[1])), m.position = g.dx * d + E + g.dy * d), o.fillsize && (m.size = o.fillsize[0] * v(e) + E + o.fillsize[1] * v(i)), h.appendChild(m)
								}
								u.visibility = "visible"
							}
						};
					I.toString = function () {
						return "Your browser doesn‚Äôt support SVG. Falling down to VML.\nYou are running Rapha√´l " + this.version
					};
					var X, Z = function (t, e, i) {
							for (var n = O(e).toLowerCase().split("-"), r = i ? "end" : "start", a = n.length, o = "classic", s = "medium", l = "medium"; a--;) switch (n[a]) {
								case "block":
								case "classic":
								case "oval":
								case "diamond":
								case "open":
								case "none":
									o = n[a];
									break;
								case "wide":
								case "narrow":
									l = n[a];
									break;
								case "long":
								case "short":
									s = n[a]
							}
							var h = t.node.getElementsByTagName("stroke")[0];
							h[r + "arrow"] = o, h[r + "arrowlength"] = s, h[r + "arrowwidth"] = l
						},
						f = function (t, e) {
							t.attrs = t.attrs || {};
							var i = t.node,
								n = t.attrs,
								r = i.style,
								a = G[t.type] && (e.x != n.x || e.y != n.y || e.width != n.width || e.height != n.height || e.cx != n.cx || e.cy != n.cy || e.rx != n.rx || e.ry != n.ry || e.r != n.r),
								o = $[t.type] && (n.cx != e.cx || n.cy != e.cy || n.r != e.r || n.rx != e.rx || n.ry != e.ry),
								s = t;
							for (var l in e) e[L](l) && (n[l] = e[l]);
							if (a && (n.path = I._getPath[t.type](t), t._.dirty = 1), e.href && (i.href = e.href), e.title && (i.title = e.title), e.target && (i.target = e.target), e.cursor && (r.cursor = e.cursor), "blur" in e && t.blur(e.blur), (e.path && "path" == t.type || a) && (i.path = function (t) {
									var e = /[ahqstv]/gi,
										i = I._pathToAbsolute;
									if (O(t).match(e) && (i = I._path2curve), e = /[clmz]/g, i == I._pathToAbsolute && !O(t).match(e)) {
										var n = O(t).replace(V, function (t, e, i) {
											var n = [],
												r = "m" == e.toLowerCase(),
												a = H[e];
											return i.replace(j, function (t) {
												r && 2 == n.length && (a += n + H["m" == e ? "l" : "L"], n = []), n.push(B(t * U))
											}), a + n
										});
										return n
									}
									var r, a, o = i(t);
									n = [];
									for (var s = 0, l = o.length; s < l; s++) {
										r = o[s], "z" == (a = o[s][0].toLowerCase()) && (a = "x");
										for (var h = 1, u = r.length; h < u; h++) a += B(r[h] * U) + (h != u - 1 ? "," : "");
										n.push(a)
									}
									return n.join(E)
								}(~O(n.path).toLowerCase().indexOf("r") ? I._pathToAbsolute(n.path) : n.path), t._.dirty = 1, "image" == t.type && (t._.fillpos = [n.x, n.y], t._.fillsize = [n.width, n.height], q(t, 1, 1, 0, 0, 0))), "transform" in e && t.transform(e.transform), o) {
								var h = +n.cx,
									u = +n.cy,
									d = +n.rx || +n.r || 0,
									c = +n.ry || +n.r || 0;
								i.path = I.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", B((h - d) * U), B((u - c) * U), B((h + d) * U), B((u + c) * U), B(h * U)), t._.dirty = 1
							}
							if ("clip-rect" in e) {
								var f = O(e["clip-rect"]).split(Y);
								if (4 == f.length) {
									f[2] = +f[2] + +f[0], f[3] = +f[3] + +f[1];
									var p = i.clipRect || I._g.doc.createElement("div"),
										g = p.style;
									g.clip = I.format("rect({1}px {2}px {3}px {0}px)", f), i.clipRect || (g.position = "absolute", g.top = 0, g.left = 0, g.width = t.paper.width + "px", g.height = t.paper.height + "px", i.parentNode.insertBefore(p, i), p.appendChild(i), i.clipRect = p)
								}
								e["clip-rect"] || i.clipRect && (i.clipRect.style.clip = "auto")
							}
							if (t.textpath) {
								var m = t.textpath.style;
								e.font && (m.font = e.font), e["font-family"] && (m.fontFamily = '"' + e["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, "") + '"'), e["font-size"] && (m.fontSize = e["font-size"]), e["font-weight"] && (m.fontWeight = e["font-weight"]), e["font-style"] && (m.fontStyle = e["font-style"])
							}
							if ("arrow-start" in e && Z(s, e["arrow-start"]), "arrow-end" in e && Z(s, e["arrow-end"], 1), null != e.opacity || null != e.fill || null != e.src || null != e.stroke || null != e["stroke-width"] || null != e["stroke-opacity"] || null != e["fill-opacity"] || null != e["stroke-dasharray"] || null != e["stroke-miterlimit"] || null != e["stroke-linejoin"] || null != e["stroke-linecap"]) {
								var v = i.getElementsByTagName(N);
								if (!(v = v && v[0]) && (v = X(N)), "image" == t.type && e.src && (v.src = e.src), e.fill && (v.on = !0), null != v.on && "none" != e.fill && null !== e.fill || (v.on = !1), v.on && e.fill) {
									var y = O(e.fill).match(I._ISURL);
									if (y) {
										v.parentNode == i && i.removeChild(v), v.rotate = !0, v.src = y[1], v.type = "tile";
										var x = t.getBBox(1);
										v.position = x.x + E + x.y, t._.fillpos = [x.x, x.y], I._preload(y[1], function () {
											t._.fillsize = [this.offsetWidth, this.offsetHeight]
										})
									} else v.color = I.getRGB(e.fill).hex, v.src = "", v.type = "solid", I.getRGB(e.fill).error && (s.type in {
										circle: 1,
										ellipse: 1
									} || "r" != O(e.fill).charAt()) && Q(s, e.fill, v) && (n.fill = "none", n.gradient = e.fill, v.rotate = !1)
								}
								if ("fill-opacity" in e || "opacity" in e) {
									var b = ((+n["fill-opacity"] + 1 || 2) - 1) * ((+n.opacity + 1 || 2) - 1) * ((+I.getRGB(e.fill).o + 1 || 2) - 1);
									b = z(W(b, 0), 1), v.opacity = b, v.src && (v.color = "none")
								}
								i.appendChild(v);
								var _ = i.getElementsByTagName("stroke") && i.getElementsByTagName("stroke")[0],
									w = !1;
								!_ && (w = _ = X("stroke")), (e.stroke && "none" != e.stroke || e["stroke-width"] || null != e["stroke-opacity"] || e["stroke-dasharray"] || e["stroke-miterlimit"] || e["stroke-linejoin"] || e["stroke-linecap"]) && (_.on = !0), ("none" == e.stroke || null === e.stroke || null == _.on || 0 == e.stroke || 0 == e["stroke-width"]) && (_.on = !1);
								var k = I.getRGB(e.stroke);
								_.on && e.stroke && (_.color = k.hex), b = ((+n["stroke-opacity"] + 1 || 2) - 1) * ((+n.opacity + 1 || 2) - 1) * ((+k.o + 1 || 2) - 1);
								var M = .75 * (R(e["stroke-width"]) || 1);
								if (b = z(W(b, 0), 1), null == e["stroke-width"] && (M = n["stroke-width"]), e["stroke-width"] && (_.weight = M), M && M < 1 && (b *= M) && (_.weight = 1), _.opacity = b, e["stroke-linejoin"] && (_.joinstyle = e["stroke-linejoin"] || "miter"), _.miterlimit = e["stroke-miterlimit"] || 8, e["stroke-linecap"] && (_.endcap = "butt" == e["stroke-linecap"] ? "flat" : "square" == e["stroke-linecap"] ? "square" : "round"), "stroke-dasharray" in e) {
									var S = {
										"-": "shortdash",
										".": "shortdot",
										"-.": "shortdashdot",
										"-..": "shortdashdotdot",
										". ": "dot",
										"- ": "dash",
										"--": "longdash",
										"- .": "dashdot",
										"--.": "longdashdot",
										"--..": "longdashdotdot"
									};
									_.dashstyle = S[L](e["stroke-dasharray"]) ? S[e["stroke-dasharray"]] : ""
								}
								w && i.appendChild(_)
							}
							if ("text" == s.type) {
								s.paper.canvas.style.display = "";
								var C = s.paper.span,
									D = n.font && n.font.match(/\d+(?:\.\d*)?(?=px)/);
								r = C.style, n.font && (r.font = n.font), n["font-family"] && (r.fontFamily = n["font-family"]), n["font-weight"] && (r.fontWeight = n["font-weight"]), n["font-style"] && (r.fontStyle = n["font-style"]), D = R(n["font-size"] || D && D[0]) || 10, r.fontSize = 100 * D + "px", s.textpath.string && (C.innerHTML = O(s.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
								var T = C.getBoundingClientRect();
								s.W = n.w = (T.right - T.left) / 100, s.H = n.h = (T.bottom - T.top) / 100, s.X = n.x, s.Y = n.y + s.H / 2, ("x" in e || "y" in e) && (s.path.v = I.format("m{0},{1}l{2},{1}", B(n.x * U), B(n.y * U), B(n.x * U) + 1));
								for (var P = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"], A = 0, F = P.length; A < F; A++)
									if (P[A] in e) {
										s._.dirty = 1;
										break
									} switch (n["text-anchor"]) {
									case "start":
										s.textpath.style["v-text-align"] = "left", s.bbx = s.W / 2;
										break;
									case "end":
										s.textpath.style["v-text-align"] = "right", s.bbx = -s.W / 2;
										break;
									default:
										s.textpath.style["v-text-align"] = "center", s.bbx = 0
								}
								s.textpath.style["v-text-kern"] = !0
							}
						},
						Q = function (t, e, i) {
							t.attrs = t.attrs || {};
							t.attrs;
							var n = Math.pow,
								r = "linear",
								a = ".5 .5";
							if (t.attrs.gradient = e, e = (e = O(e).replace(I._radial_gradient, function (t, e, i) {
									return r = "radial", e && i && (e = R(e), i = R(i), .25 < n(e - .5, 2) + n(i - .5, 2) && (i = d.sqrt(.25 - n(e - .5, 2)) * (2 * (.5 < i) - 1) + .5), a = e + E + i), ""
								})).split(/\s*\-\s*/), "linear" == r) {
								var o = e.shift();
								if (o = -R(o), isNaN(o)) return null
							}
							var s = I._parseDots(e);
							if (!s) return null;
							if (t = t.shape || t.node, s.length) {
								t.removeChild(i), i.on = !0, i.method = "none", i.color = s[0].color, i.color2 = s[s.length - 1].color;
								for (var l = [], h = 0, u = s.length; h < u; h++) s[h].offset && l.push(s[h].offset + E + s[h].color);
								i.colors = l.length ? l.join() : "0% " + i.color, i.angle = "radial" == r ? (i.type = "gradientTitle", i.focus = "100%", i.focussize = "0 0", i.focusposition = a, 0) : (i.type = "gradient", (270 - o) % 360), t.appendChild(i)
							}
							return 1
						},
						p = function (t, e) {
							this[0] = this.node = t, t.raphael = !0, this.id = I._oid++, t.raphaelid = this.id, this.X = 0, this.Y = 0, this.attrs = {}, this.paper = e, this.matrix = I.matrix(), this._ = {
								transform: [],
								sx: 1,
								sy: 1,
								dx: 0,
								dy: 0,
								deg: 0,
								dirty: 1,
								dirtyT: 1
							}, !e.bottom && (e.bottom = this), this.prev = e.top, e.top && (e.top.next = this), (e.top = this).next = null
						},
						t = I.el;
					(p.prototype = t).constructor = p, t.transform = function (t) {
						if (null == t) return this._.transform;
						var e, i = this.paper._viewBoxShift,
							n = i ? "s" + [i.scale, i.scale] + "-1-1t" + [i.dx, i.dy] : "";
						i && (e = t = O(t).replace(/\.{3}|\u2026/g, this._.transform || "")), I._extractTransform(this, n + t);
						var r, a = this.matrix.clone(),
							o = this.skew,
							s = this.node,
							l = ~O(this.attrs.fill).indexOf("-"),
							h = !O(this.attrs.fill).indexOf("url(");
						if (a.translate(1, 1), h || l || "image" == this.type)
							if (o.matrix = "1 0 0 1", o.offset = "0 0", r = a.split(), l && r.noRotation || !r.isSimple) {
								s.style.filter = a.toFilter();
								var u = this.getBBox(),
									d = this.getBBox(1),
									c = u.x - d.x,
									f = u.y - d.y;
								s.coordorigin = c * -U + E + f * -U, q(this, 1, 1, c, f, 0)
							} else s.style.filter = "", q(this, r.scalex, r.scaley, r.dx, r.dy, r.rotate);
						else s.style.filter = "", o.matrix = O(a), o.offset = a.offset();
						return null !== e && (this._.transform = e, I._extractTransform(this, e)), this
					}, t.rotate = function (t, e, i) {
						if (this.removed) return this;
						if (null != t) {
							if ((t = O(t).split(Y)).length - 1 && (e = R(t[1]), i = R(t[2])), t = R(t[0]), null == i && (e = i), null == e || null == i) {
								var n = this.getBBox(1);
								e = n.x + n.width / 2, i = n.y + n.height / 2
							}
							return this._.dirtyT = 1, this.transform(this._.transform.concat([["r", t, e, i]])), this
						}
					}, t.translate = function (t, e) {
						return this.removed || ((t = O(t).split(Y)).length - 1 && (e = R(t[1])), t = R(t[0]) || 0, e = +e || 0, this._.bbox && (this._.bbox.x += t, this._.bbox.y += e), this.transform(this._.transform.concat([["t", t, e]]))), this
					}, t.scale = function (t, e, i, n) {
						if (this.removed) return this;
						if ((t = O(t).split(Y)).length - 1 && (e = R(t[1]), i = R(t[2]), n = R(t[3]), isNaN(i) && (i = null), isNaN(n) && (n = null)), t = R(t[0]), null == e && (e = t), null == n && (i = n), null == i || null == n) var r = this.getBBox(1);
						return i = null == i ? r.x + r.width / 2 : i, n = null == n ? r.y + r.height / 2 : n, this.transform(this._.transform.concat([["s", t, e, i, n]])), this._.dirtyT = 1, this
					}, t.hide = function () {
						return !this.removed && (this.node.style.display = "none"), this
					}, t.show = function () {
						return !this.removed && (this.node.style.display = ""), this
					}, t.auxGetBBox = I.el.getBBox, t.getBBox = function () {
						var t = this.auxGetBBox();
						if (this.paper && this.paper._viewBoxShift) {
							var e = {},
								i = 1 / this.paper._viewBoxShift.scale;
							return e.x = t.x - this.paper._viewBoxShift.dx, e.x *= i, e.y = t.y - this.paper._viewBoxShift.dy, e.y *= i, e.width = t.width * i, e.height = t.height * i, e.x2 = e.x + e.width, e.y2 = e.y + e.height, e
						}
						return t
					}, t._getBBox = function () {
						return this.removed ? {} : {
							x: this.X + (this.bbx || 0) - this.W / 2,
							y: this.Y - this.H,
							width: this.W,
							height: this.H
						}
					}, t.remove = function () {
						if (!this.removed && this.node.parentNode) {
							for (var t in this.paper.__set__ && this.paper.__set__.exclude(this), I.eve.unbind("raphael.*.*." + this.id), I._tear(this, this.paper), this.node.parentNode.removeChild(this.node), this.shape && this.shape.parentNode.removeChild(this.shape), this) this[t] = "function" == typeof this[t] ? I._removedFactory(t) : null;
							this.removed = !0
						}
					}, t.attr = function (t, e) {
						if (this.removed) return this;
						if (null == t) {
							var i = {};
							for (var n in this.attrs) this.attrs[L](n) && (i[n] = this.attrs[n]);
							return i.gradient && "none" == i.fill && (i.fill = i.gradient) && delete i.gradient, i.transform = this._.transform, i
						}
						if (null == e && I.is(t, "string")) {
							if (t == N && "none" == this.attrs.fill && this.attrs.gradient) return this.attrs.gradient;
							for (var r = t.split(Y), a = {}, o = 0, s = r.length; o < s; o++)(t = r[o]) in this.attrs ? a[t] = this.attrs[t] : I.is(this.paper.customAttributes[t], "function") ? a[t] = this.paper.customAttributes[t].def : a[t] = I._availableAttrs[t];
							return s - 1 ? a : a[r[0]]
						}
						if (this.attrs && null == e && I.is(t, "array")) {
							for (a = {}, o = 0, s = t.length; o < s; o++) a[t[o]] = this.attr(t[o]);
							return a
						}
						var l;
						for (var h in null != e && ((l = {})[t] = e), null == e && I.is(t, "object") && (l = t), l) c("raphael.attr." + h + "." + this.id, this, l[h]);
						if (l) {
							for (h in this.paper.customAttributes)
								if (this.paper.customAttributes[L](h) && l[L](h) && I.is(this.paper.customAttributes[h], "function")) {
									var u = this.paper.customAttributes[h].apply(this, [].concat(l[h]));
									for (var d in this.attrs[h] = l[h], u) u[L](d) && (l[d] = u[d])
								} l.text && "text" == this.type && (this.textpath.string = l.text), f(this, l)
						}
						return this
					}, t.toFront = function () {
						return !this.removed && this.node.parentNode.appendChild(this.node), this.paper && this.paper.top != this && I._tofront(this, this.paper), this
					}, t.toBack = function () {
						return this.removed || this.node.parentNode.firstChild != this.node && (this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild), I._toback(this, this.paper)), this
					}, t.insertAfter = function (t) {
						return this.removed || (t.constructor == I.st.constructor && (t = t[t.length - 1]), t.node.nextSibling ? t.node.parentNode.insertBefore(this.node, t.node.nextSibling) : t.node.parentNode.appendChild(this.node), I._insertafter(this, t, this.paper)), this
					}, t.insertBefore = function (t) {
						return this.removed || (t.constructor == I.st.constructor && (t = t[0]), t.node.parentNode.insertBefore(this.node, t.node), I._insertbefore(this, t, this.paper)), this
					}, t.blur = function (t) {
						var e = this.node.runtimeStyle,
							i = e.filter;
						return i = i.replace(n, ""), 0 != +t ? (this.attrs.blur = t, e.filter = i + E + " progid:DXImageTransform.Microsoft.Blur(pixelradius=" + (+t || 1.5) + ")", e.margin = I.format("-{0}px 0 0 -{0}px", B(+t || 1.5))) : (e.filter = i, e.margin = 0, delete this.attrs.blur), this
					}, I._engine.path = function (t, e) {
						var i = X("shape");
						i.style.cssText = u, i.coordsize = U + E + U, i.coordorigin = e.coordorigin;
						var n = new p(i, e),
							r = {
								fill: "none",
								stroke: "#000"
							};
						t && (r.path = t), n.type = "path", n.path = [], n.Path = "", f(n, r), e.canvas && e.canvas.appendChild(i);
						var a = X("skew");
						return a.on = !0, i.appendChild(a), n.skew = a, n.transform(""), n
					}, I._engine.rect = function (t, e, i, n, r, a) {
						var o = I._rectPath(e, i, n, r, a),
							s = t.path(o),
							l = s.attrs;
						return s.X = l.x = e, s.Y = l.y = i, s.W = l.width = n, s.H = l.height = r, l.r = a, l.path = o, s.type = "rect", s
					}, I._engine.ellipse = function (t, e, i, n, r) {
						var a = t.path();
						a.attrs;
						return a.X = e - n, a.Y = i - r, a.W = 2 * n, a.H = 2 * r, a.type = "ellipse", f(a, {
							cx: e,
							cy: i,
							rx: n,
							ry: r
						}), a
					}, I._engine.circle = function (t, e, i, n) {
						var r = t.path();
						r.attrs;
						return r.X = e - n, r.Y = i - n, r.W = r.H = 2 * n, r.type = "circle", f(r, {
							cx: e,
							cy: i,
							r: n
						}), r
					}, I._engine.image = function (t, e, i, n, r, a) {
						var o = I._rectPath(i, n, r, a),
							s = t.path(o).attr({
								stroke: "none"
							}),
							l = s.attrs,
							h = s.node,
							u = h.getElementsByTagName(N)[0];
						return l.src = e, s.X = l.x = i, s.Y = l.y = n, s.W = l.width = r, s.H = l.height = a, l.path = o, s.type = "image", u.parentNode == h && h.removeChild(u), u.rotate = !0, u.src = e, u.type = "tile", s._.fillpos = [i, n], s._.fillsize = [r, a], h.appendChild(u), q(s, 1, 1, 0, 0, 0), s
					}, I._engine.text = function (t, e, i, n) {
						var r = X("shape"),
							a = X("path"),
							o = X("textpath");
						e = e || 0, i = i || 0, n = n || "", a.v = I.format("m{0},{1}l{2},{1}", B(e * U), B(i * U), B(e * U) + 1), a.textpathok = !0, o.string = O(n), o.on = !0, r.style.cssText = u, r.coordsize = U + E + U, r.coordorigin = "0 0";
						var s = new p(r, t),
							l = {
								fill: "#000",
								stroke: "none",
								font: I._availableAttrs.font,
								text: n
							};
						s.shape = r, s.path = a, s.textpath = o, s.type = "text", s.attrs.text = O(n), s.attrs.x = e, s.attrs.y = i, s.attrs.w = 1, s.attrs.h = 1, f(s, l), r.appendChild(o), r.appendChild(a), t.canvas.appendChild(r);
						var h = X("skew");
						return h.on = !0, r.appendChild(h), s.skew = h, s.transform(""), s
					}, I._engine.setSize = function (t, e) {
						var i = this.canvas.style;
						return (this.width = t) == +t && (t += "px"), (this.height = e) == +e && (e += "px"), i.width = t, i.height = e, i.clip = "rect(0 " + t + " " + e + " 0)", this._viewBox && I._engine.setViewBox.apply(this, this._viewBox), this
					}, I._engine.setViewBox = function (t, e, i, n, r) {
						I.eve("raphael.setViewBox", this, this._viewBox, [t, e, i, n, r]);
						var a, o, s = this.getSize(),
							l = s.width,
							h = s.height;
						return r && (i * (a = h / n) < l && (t -= (l - i * a) / 2 / a), n * (o = l / i) < h && (e -= (h - n * o) / 2 / o)), this._viewBox = [t, e, i, n, !!r], this._viewBoxShift = {
							dx: -t,
							dy: -e,
							scale: s
						}, this.forEach(function (t) {
							t.transform("...")
						}), this
					}, I._engine.initWin = function (t) {
						var e = t.document;
						e.styleSheets.length < 31 ? e.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)") : e.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
						try {
							!e.namespaces.rvml && e.namespaces.add("rvml", "urn:schemas-microsoft-com:vml"), X = function (t) {
								return e.createElement("<rvml:" + t + ' class="rvml">')
							}
						} catch (t) {
							X = function (t) {
								return e.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">')
							}
						}
					}, I._engine.initWin(I._g.win), I._engine.create = function () {
						var t = I._getContainer.apply(0, arguments),
							e = t.container,
							i = t.height,
							n = t.width,
							r = t.x,
							a = t.y;
						if (!e) throw new Error("VML container not found.");
						var o = new I._Paper,
							s = o.canvas = I._g.doc.createElement("div"),
							l = s.style;
						return r = r || 0, a = a || 0, n = n || 512, i = i || 342, (o.width = n) == +n && (n += "px"), (o.height = i) == +i && (i += "px"), o.coordsize = 216e5 + E + 216e5, o.coordorigin = "0 0", o.span = I._g.doc.createElement("span"), o.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;", s.appendChild(o.span), l.cssText = I.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", n, i), 1 == e ? (I._g.doc.body.appendChild(s), l.left = r + "px", l.top = a + "px", l.position = "absolute") : e.firstChild ? e.insertBefore(s, e.firstChild) : e.appendChild(s), o.renderfix = function () {}, o
					}, I.prototype.clear = function () {
						I.eve("raphael.clear", this), this.canvas.innerHTML = "", this.span = I._g.doc.createElement("span"), this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;", this.canvas.appendChild(this.span), this.bottom = this.top = null
					}, I.prototype.remove = function () {
						for (var t in I.eve("raphael.remove", this), this.canvas.parentNode.removeChild(this.canvas), this) this[t] = "function" == typeof this[t] ? I._removedFactory(t) : null;
						return !0
					};
					var e = I.st;
					for (var i in t) t[L](i) && !e[L](i) && (e[i] = function (i) {
						return function () {
							var e = arguments;
							return this.forEach(function (t) {
								t[i].apply(t, e)
							})
						}
					}(i))
				}
			}.apply(e, n)) || (t.exports = r)
		}])
	}),
	function (t, e) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.Chart = e()
	}(this, function () {
		"use strict";
		var a = {
			rgb2hsl: o,
			rgb2hsv: e,
			rgb2hwb: i,
			rgb2cmyk: n,
			rgb2keyword: s,
			rgb2xyz: l,
			rgb2lab: h,
			rgb2lch: function (t) {
				return y(h(t))
			},
			hsl2rgb: u,
			hsl2hsv: function (t) {
				var e = t[0],
					i = t[1] / 100,
					n = t[2] / 100;
				return 0 !== n ? [e, 100 * (2 * (i *= (n *= 2) <= 1 ? n : 2 - n) / (n + i)), 100 * ((n + i) / 2)] : [0, 0, 0]
			},
			hsl2hwb: function (t) {
				return i(u(t))
			},
			hsl2cmyk: function (t) {
				return n(u(t))
			},
			hsl2keyword: function (t) {
				return s(u(t))
			},
			hsv2rgb: d,
			hsv2hsl: function (t) {
				var e, i, n = t[0],
					r = t[1] / 100,
					a = t[2] / 100;
				return e = r * a, [n, 100 * (e = (e /= (i = (2 - r) * a) <= 1 ? i : 2 - i) || 0), 100 * (i /= 2)]
			},
			hsv2hwb: function (t) {
				return i(d(t))
			},
			hsv2cmyk: function (t) {
				return n(d(t))
			},
			hsv2keyword: function (t) {
				return s(d(t))
			},
			hwb2rgb: c,
			hwb2hsl: function (t) {
				return o(c(t))
			},
			hwb2hsv: function (t) {
				return e(c(t))
			},
			hwb2cmyk: function (t) {
				return n(c(t))
			},
			hwb2keyword: function (t) {
				return s(c(t))
			},
			cmyk2rgb: f,
			cmyk2hsl: function (t) {
				return o(f(t))
			},
			cmyk2hsv: function (t) {
				return e(f(t))
			},
			cmyk2hwb: function (t) {
				return i(f(t))
			},
			cmyk2keyword: function (t) {
				return s(f(t))
			},
			keyword2rgb: w,
			keyword2hsl: function (t) {
				return o(w(t))
			},
			keyword2hsv: function (t) {
				return e(w(t))
			},
			keyword2hwb: function (t) {
				return i(w(t))
			},
			keyword2cmyk: function (t) {
				return n(w(t))
			},
			keyword2lab: function (t) {
				return h(w(t))
			},
			keyword2xyz: function (t) {
				return l(w(t))
			},
			xyz2rgb: p,
			xyz2lab: m,
			xyz2lch: function (t) {
				return y(m(t))
			},
			lab2xyz: v,
			lab2rgb: x,
			lab2lch: y,
			lch2lab: _,
			lch2xyz: function (t) {
				return v(_(t))
			},
			lch2rgb: function (t) {
				return x(_(t))
			}
		};

		function o(t) {
			var e, i, n = t[0] / 255,
				r = t[1] / 255,
				a = t[2] / 255,
				o = Math.min(n, r, a),
				s = Math.max(n, r, a),
				l = s - o;
			return s == o ? e = 0 : n == s ? e = (r - a) / l : r == s ? e = 2 + (a - n) / l : a == s && (e = 4 + (n - r) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = (o + s) / 2, [e, 100 * (s == o ? 0 : i <= .5 ? l / (s + o) : l / (2 - s - o)), 100 * i]
		}

		function e(t) {
			var e, i, n = t[0],
				r = t[1],
				a = t[2],
				o = Math.min(n, r, a),
				s = Math.max(n, r, a),
				l = s - o;
			return i = 0 == s ? 0 : l / s * 1e3 / 10, s == o ? e = 0 : n == s ? e = (r - a) / l : r == s ? e = 2 + (a - n) / l : a == s && (e = 4 + (n - r) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), [e, i, s / 255 * 1e3 / 10]
		}

		function i(t) {
			var e = t[0],
				i = t[1],
				n = t[2];
			return [o(t)[0], 100 * (1 / 255 * Math.min(e, Math.min(i, n))), 100 * (n = 1 - 1 / 255 * Math.max(e, Math.max(i, n)))]
		}

		function n(t) {
			var e, i = t[0] / 255,
				n = t[1] / 255,
				r = t[2] / 255;
			return [100 * ((1 - i - (e = Math.min(1 - i, 1 - n, 1 - r))) / (1 - e) || 0), 100 * ((1 - n - e) / (1 - e) || 0), 100 * ((1 - r - e) / (1 - e) || 0), 100 * e]
		}

		function s(t) {
			return M[JSON.stringify(t)]
		}

		function l(t) {
			var e = t[0] / 255,
				i = t[1] / 255,
				n = t[2] / 255;
			return [100 * (.4124 * (e = .04045 < e ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .3576 * (i = .04045 < i ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .1805 * (n = .04045 < n ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92)), 100 * (.2126 * e + .7152 * i + .0722 * n), 100 * (.0193 * e + .1192 * i + .9505 * n)]
		}

		function h(t) {
			var e = l(t),
				i = e[0],
				n = e[1],
				r = e[2];
			return n /= 100, r /= 108.883, i = .008856 < (i /= 95.047) ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, [116 * (n = .008856 < n ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (i - n), 200 * (n - (r = .008856 < r ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))]
		}

		function u(t) {
			var e, i, n, r, a, o = t[0] / 360,
				s = t[1] / 100,
				l = t[2] / 100;
			if (0 == s) return [a = 255 * l, a, a];
			e = 2 * l - (i = l < .5 ? l * (1 + s) : l + s - l * s), r = [0, 0, 0];
			for (var h = 0; h < 3; h++)(n = o + 1 / 3 * -(h - 1)) < 0 && n++, 1 < n && n--, a = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e, r[h] = 255 * a;
			return r
		}

		function d(t) {
			var e = t[0] / 60,
				i = t[1] / 100,
				n = t[2] / 100,
				r = Math.floor(e) % 6,
				a = e - Math.floor(e),
				o = 255 * n * (1 - i),
				s = 255 * n * (1 - i * a),
				l = 255 * n * (1 - i * (1 - a));
			n *= 255;
			switch (r) {
				case 0:
					return [n, l, o];
				case 1:
					return [s, n, o];
				case 2:
					return [o, n, l];
				case 3:
					return [o, s, n];
				case 4:
					return [l, o, n];
				case 5:
					return [n, o, s]
			}
		}

		function c(t) {
			var e, i, n, a, o = t[0] / 360,
				s = t[1] / 100,
				l = t[2] / 100,
				h = s + l;
			switch (1 < h && (s /= h, l /= h), n = 6 * o - (e = Math.floor(6 * o)), 0 != (1 & e) && (n = 1 - n), a = s + n * ((i = 1 - l) - s), e) {
				default:
				case 6:
				case 0:
					r = i, g = a, b = s;
					break;
				case 1:
					r = a, g = i, b = s;
					break;
				case 2:
					r = s, g = i, b = a;
					break;
				case 3:
					r = s, g = a, b = i;
					break;
				case 4:
					r = a, g = s, b = i;
					break;
				case 5:
					r = i, g = s, b = a
			}
			return [255 * r, 255 * g, 255 * b]
		}

		function f(t) {
			var e = t[0] / 100,
				i = t[1] / 100,
				n = t[2] / 100,
				r = t[3] / 100;
			return [255 * (1 - Math.min(1, e * (1 - r) + r)), 255 * (1 - Math.min(1, i * (1 - r) + r)), 255 * (1 - Math.min(1, n * (1 - r) + r))]
		}

		function p(t) {
			var e, i, n, r = t[0] / 100,
				a = t[1] / 100,
				o = t[2] / 100;
			return i = -.9689 * r + 1.8758 * a + .0415 * o, n = .0557 * r + -.204 * a + 1.057 * o, e = .0031308 < (e = 3.2406 * r + -1.5372 * a + -.4986 * o) ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e *= 12.92, i = .0031308 < i ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i *= 12.92, n = .0031308 < n ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : n *= 12.92, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (n = Math.min(Math.max(0, n), 1))]
		}

		function m(t) {
			var e = t[0],
				i = t[1],
				n = t[2];
			return i /= 100, n /= 108.883, e = .008856 < (e /= 95.047) ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, [116 * (i = .008856 < i ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (e - i), 200 * (i - (n = .008856 < n ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116))]
		}

		function v(t) {
			var e, i, n, r, a = t[0],
				o = t[1],
				s = t[2];
			return r = a <= 8 ? (i = 100 * a / 903.3) / 100 * 7.787 + 16 / 116 : (i = 100 * Math.pow((a + 16) / 116, 3), Math.pow(i / 100, 1 / 3)), [e = e / 95.047 <= .008856 ? e = 95.047 * (o / 500 + r - 16 / 116) / 7.787 : 95.047 * Math.pow(o / 500 + r, 3), i, n = n / 108.883 <= .008859 ? n = 108.883 * (r - s / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(r - s / 200, 3)]
		}

		function y(t) {
			var e, i = t[0],
				n = t[1],
				r = t[2];
			return (e = 360 * Math.atan2(r, n) / 2 / Math.PI) < 0 && (e += 360), [i, Math.sqrt(n * n + r * r), e]
		}

		function x(t) {
			return p(v(t))
		}

		function _(t) {
			var e, i = t[0],
				n = t[1];
			return e = t[2] / 360 * 2 * Math.PI, [i, n * Math.cos(e), n * Math.sin(e)]
		}

		function w(t) {
			return k[t]
		}
		var k = {
				aliceblue: [240, 248, 255],
				antiquewhite: [250, 235, 215],
				aqua: [0, 255, 255],
				aquamarine: [127, 255, 212],
				azure: [240, 255, 255],
				beige: [245, 245, 220],
				bisque: [255, 228, 196],
				black: [0, 0, 0],
				blanchedalmond: [255, 235, 205],
				blue: [0, 0, 255],
				blueviolet: [138, 43, 226],
				brown: [165, 42, 42],
				burlywood: [222, 184, 135],
				cadetblue: [95, 158, 160],
				chartreuse: [127, 255, 0],
				chocolate: [210, 105, 30],
				coral: [255, 127, 80],
				cornflowerblue: [100, 149, 237],
				cornsilk: [255, 248, 220],
				crimson: [220, 20, 60],
				cyan: [0, 255, 255],
				darkblue: [0, 0, 139],
				darkcyan: [0, 139, 139],
				darkgoldenrod: [184, 134, 11],
				darkgray: [169, 169, 169],
				darkgreen: [0, 100, 0],
				darkgrey: [169, 169, 169],
				darkkhaki: [189, 183, 107],
				darkmagenta: [139, 0, 139],
				darkolivegreen: [85, 107, 47],
				darkorange: [255, 140, 0],
				darkorchid: [153, 50, 204],
				darkred: [139, 0, 0],
				darksalmon: [233, 150, 122],
				darkseagreen: [143, 188, 143],
				darkslateblue: [72, 61, 139],
				darkslategray: [47, 79, 79],
				darkslategrey: [47, 79, 79],
				darkturquoise: [0, 206, 209],
				darkviolet: [148, 0, 211],
				deeppink: [255, 20, 147],
				deepskyblue: [0, 191, 255],
				dimgray: [105, 105, 105],
				dimgrey: [105, 105, 105],
				dodgerblue: [30, 144, 255],
				firebrick: [178, 34, 34],
				floralwhite: [255, 250, 240],
				forestgreen: [34, 139, 34],
				fuchsia: [255, 0, 255],
				gainsboro: [220, 220, 220],
				ghostwhite: [248, 248, 255],
				gold: [255, 215, 0],
				goldenrod: [218, 165, 32],
				gray: [128, 128, 128],
				green: [0, 128, 0],
				greenyellow: [173, 255, 47],
				grey: [128, 128, 128],
				honeydew: [240, 255, 240],
				hotpink: [255, 105, 180],
				indianred: [205, 92, 92],
				indigo: [75, 0, 130],
				ivory: [255, 255, 240],
				khaki: [240, 230, 140],
				lavender: [230, 230, 250],
				lavenderblush: [255, 240, 245],
				lawngreen: [124, 252, 0],
				lemonchiffon: [255, 250, 205],
				lightblue: [173, 216, 230],
				lightcoral: [240, 128, 128],
				lightcyan: [224, 255, 255],
				lightgoldenrodyellow: [250, 250, 210],
				lightgray: [211, 211, 211],
				lightgreen: [144, 238, 144],
				lightgrey: [211, 211, 211],
				lightpink: [255, 182, 193],
				lightsalmon: [255, 160, 122],
				lightseagreen: [32, 178, 170],
				lightskyblue: [135, 206, 250],
				lightslategray: [119, 136, 153],
				lightslategrey: [119, 136, 153],
				lightsteelblue: [176, 196, 222],
				lightyellow: [255, 255, 224],
				lime: [0, 255, 0],
				limegreen: [50, 205, 50],
				linen: [250, 240, 230],
				magenta: [255, 0, 255],
				maroon: [128, 0, 0],
				mediumaquamarine: [102, 205, 170],
				mediumblue: [0, 0, 205],
				mediumorchid: [186, 85, 211],
				mediumpurple: [147, 112, 219],
				mediumseagreen: [60, 179, 113],
				mediumslateblue: [123, 104, 238],
				mediumspringgreen: [0, 250, 154],
				mediumturquoise: [72, 209, 204],
				mediumvioletred: [199, 21, 133],
				midnightblue: [25, 25, 112],
				mintcream: [245, 255, 250],
				mistyrose: [255, 228, 225],
				moccasin: [255, 228, 181],
				navajowhite: [255, 222, 173],
				navy: [0, 0, 128],
				oldlace: [253, 245, 230],
				olive: [128, 128, 0],
				olivedrab: [107, 142, 35],
				orange: [255, 165, 0],
				orangered: [255, 69, 0],
				orchid: [218, 112, 214],
				palegoldenrod: [238, 232, 170],
				palegreen: [152, 251, 152],
				paleturquoise: [175, 238, 238],
				palevioletred: [219, 112, 147],
				papayawhip: [255, 239, 213],
				peachpuff: [255, 218, 185],
				peru: [205, 133, 63],
				pink: [255, 192, 203],
				plum: [221, 160, 221],
				powderblue: [176, 224, 230],
				purple: [128, 0, 128],
				rebeccapurple: [102, 51, 153],
				red: [255, 0, 0],
				rosybrown: [188, 143, 143],
				royalblue: [65, 105, 225],
				saddlebrown: [139, 69, 19],
				salmon: [250, 128, 114],
				sandybrown: [244, 164, 96],
				seagreen: [46, 139, 87],
				seashell: [255, 245, 238],
				sienna: [160, 82, 45],
				silver: [192, 192, 192],
				skyblue: [135, 206, 235],
				slateblue: [106, 90, 205],
				slategray: [112, 128, 144],
				slategrey: [112, 128, 144],
				snow: [255, 250, 250],
				springgreen: [0, 255, 127],
				steelblue: [70, 130, 180],
				tan: [210, 180, 140],
				teal: [0, 128, 128],
				thistle: [216, 191, 216],
				tomato: [255, 99, 71],
				turquoise: [64, 224, 208],
				violet: [238, 130, 238],
				wheat: [245, 222, 179],
				white: [255, 255, 255],
				whitesmoke: [245, 245, 245],
				yellow: [255, 255, 0],
				yellowgreen: [154, 205, 50]
			},
			M = {};
		for (var t in k) M[JSON.stringify(k[t])] = t;
		var S = function () {
			return new A
		};
		for (var C in a) {
			S[C + "Raw"] = function (e) {
				return function (t) {
					return "number" == typeof t && (t = Array.prototype.slice.call(arguments)), a[e](t)
				}
			}(C);
			var D = /(\w+)2(\w+)/.exec(C),
				T = D[1],
				P = D[2];
			(S[T] = S[T] || {})[P] = S[C] = function (n) {
				return function (t) {
					"number" == typeof t && (t = Array.prototype.slice.call(arguments));
					var e = a[n](t);
					if ("string" == typeof e || void 0 === e) return e;
					for (var i = 0; i < e.length; i++) e[i] = Math.round(e[i]);
					return e
				}
			}(C)
		}
		var A = function () {
			this.convs = {}
		};
		A.prototype.routeSpace = function (t, e) {
			var i = e[0];
			return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i))
		}, A.prototype.setValues = function (t, e) {
			return this.space = t, this.convs = {}, this.convs[t] = e, this
		}, A.prototype.getValues = function (t) {
			var e = this.convs[t];
			if (!e) {
				var i = this.space,
					n = this.convs[i];
				e = S[i][t](n), this.convs[t] = e
			}
			return e
		}, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (e) {
			A.prototype[e] = function (t) {
				return this.routeSpace(e, arguments)
			}
		});
		var F = S,
			I = {
				aliceblue: [240, 248, 255],
				antiquewhite: [250, 235, 215],
				aqua: [0, 255, 255],
				aquamarine: [127, 255, 212],
				azure: [240, 255, 255],
				beige: [245, 245, 220],
				bisque: [255, 228, 196],
				black: [0, 0, 0],
				blanchedalmond: [255, 235, 205],
				blue: [0, 0, 255],
				blueviolet: [138, 43, 226],
				brown: [165, 42, 42],
				burlywood: [222, 184, 135],
				cadetblue: [95, 158, 160],
				chartreuse: [127, 255, 0],
				chocolate: [210, 105, 30],
				coral: [255, 127, 80],
				cornflowerblue: [100, 149, 237],
				cornsilk: [255, 248, 220],
				crimson: [220, 20, 60],
				cyan: [0, 255, 255],
				darkblue: [0, 0, 139],
				darkcyan: [0, 139, 139],
				darkgoldenrod: [184, 134, 11],
				darkgray: [169, 169, 169],
				darkgreen: [0, 100, 0],
				darkgrey: [169, 169, 169],
				darkkhaki: [189, 183, 107],
				darkmagenta: [139, 0, 139],
				darkolivegreen: [85, 107, 47],
				darkorange: [255, 140, 0],
				darkorchid: [153, 50, 204],
				darkred: [139, 0, 0],
				darksalmon: [233, 150, 122],
				darkseagreen: [143, 188, 143],
				darkslateblue: [72, 61, 139],
				darkslategray: [47, 79, 79],
				darkslategrey: [47, 79, 79],
				darkturquoise: [0, 206, 209],
				darkviolet: [148, 0, 211],
				deeppink: [255, 20, 147],
				deepskyblue: [0, 191, 255],
				dimgray: [105, 105, 105],
				dimgrey: [105, 105, 105],
				dodgerblue: [30, 144, 255],
				firebrick: [178, 34, 34],
				floralwhite: [255, 250, 240],
				forestgreen: [34, 139, 34],
				fuchsia: [255, 0, 255],
				gainsboro: [220, 220, 220],
				ghostwhite: [248, 248, 255],
				gold: [255, 215, 0],
				goldenrod: [218, 165, 32],
				gray: [128, 128, 128],
				green: [0, 128, 0],
				greenyellow: [173, 255, 47],
				grey: [128, 128, 128],
				honeydew: [240, 255, 240],
				hotpink: [255, 105, 180],
				indianred: [205, 92, 92],
				indigo: [75, 0, 130],
				ivory: [255, 255, 240],
				khaki: [240, 230, 140],
				lavender: [230, 230, 250],
				lavenderblush: [255, 240, 245],
				lawngreen: [124, 252, 0],
				lemonchiffon: [255, 250, 205],
				lightblue: [173, 216, 230],
				lightcoral: [240, 128, 128],
				lightcyan: [224, 255, 255],
				lightgoldenrodyellow: [250, 250, 210],
				lightgray: [211, 211, 211],
				lightgreen: [144, 238, 144],
				lightgrey: [211, 211, 211],
				lightpink: [255, 182, 193],
				lightsalmon: [255, 160, 122],
				lightseagreen: [32, 178, 170],
				lightskyblue: [135, 206, 250],
				lightslategray: [119, 136, 153],
				lightslategrey: [119, 136, 153],
				lightsteelblue: [176, 196, 222],
				lightyellow: [255, 255, 224],
				lime: [0, 255, 0],
				limegreen: [50, 205, 50],
				linen: [250, 240, 230],
				magenta: [255, 0, 255],
				maroon: [128, 0, 0],
				mediumaquamarine: [102, 205, 170],
				mediumblue: [0, 0, 205],
				mediumorchid: [186, 85, 211],
				mediumpurple: [147, 112, 219],
				mediumseagreen: [60, 179, 113],
				mediumslateblue: [123, 104, 238],
				mediumspringgreen: [0, 250, 154],
				mediumturquoise: [72, 209, 204],
				mediumvioletred: [199, 21, 133],
				midnightblue: [25, 25, 112],
				mintcream: [245, 255, 250],
				mistyrose: [255, 228, 225],
				moccasin: [255, 228, 181],
				navajowhite: [255, 222, 173],
				navy: [0, 0, 128],
				oldlace: [253, 245, 230],
				olive: [128, 128, 0],
				olivedrab: [107, 142, 35],
				orange: [255, 165, 0],
				orangered: [255, 69, 0],
				orchid: [218, 112, 214],
				palegoldenrod: [238, 232, 170],
				palegreen: [152, 251, 152],
				paleturquoise: [175, 238, 238],
				palevioletred: [219, 112, 147],
				papayawhip: [255, 239, 213],
				peachpuff: [255, 218, 185],
				peru: [205, 133, 63],
				pink: [255, 192, 203],
				plum: [221, 160, 221],
				powderblue: [176, 224, 230],
				purple: [128, 0, 128],
				rebeccapurple: [102, 51, 153],
				red: [255, 0, 0],
				rosybrown: [188, 143, 143],
				royalblue: [65, 105, 225],
				saddlebrown: [139, 69, 19],
				salmon: [250, 128, 114],
				sandybrown: [244, 164, 96],
				seagreen: [46, 139, 87],
				seashell: [255, 245, 238],
				sienna: [160, 82, 45],
				silver: [192, 192, 192],
				skyblue: [135, 206, 235],
				slateblue: [106, 90, 205],
				slategray: [112, 128, 144],
				slategrey: [112, 128, 144],
				snow: [255, 250, 250],
				springgreen: [0, 255, 127],
				steelblue: [70, 130, 180],
				tan: [210, 180, 140],
				teal: [0, 128, 128],
				thistle: [216, 191, 216],
				tomato: [255, 99, 71],
				turquoise: [64, 224, 208],
				violet: [238, 130, 238],
				wheat: [245, 222, 179],
				white: [255, 255, 255],
				whitesmoke: [245, 245, 245],
				yellow: [255, 255, 0],
				yellowgreen: [154, 205, 50]
			},
			L = {
				getRgba: O,
				getHsla: R,
				getRgb: function (t) {
					var e = O(t);
					return e && e.slice(0, 3)
				},
				getHsl: function (t) {
					var e = R(t);
					return e && e.slice(0, 3)
				},
				getHwb: B,
				getAlpha: function (t) {
					var e = O(t); {
						if (e) return e[3];
						if (e = R(t)) return e[3];
						if (e = B(t)) return e[3]
					}
				},
				hexString: function (t, e) {
					var e = void 0 !== e && 3 === t.length ? e : t[3];
					return "#" + E(t[0]) + E(t[1]) + E(t[2]) + (0 <= e && e < 1 ? E(Math.round(255 * e)) : "")
				},
				rgbString: function (t, e) {
					if (e < 1 || t[3] && t[3] < 1) return W(t, e);
					return "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
				},
				rgbaString: W,
				percentString: function (t, e) {
					if (e < 1 || t[3] && t[3] < 1) return z(t, e);
					var i = Math.round(t[0] / 255 * 100),
						n = Math.round(t[1] / 255 * 100),
						r = Math.round(t[2] / 255 * 100);
					return "rgb(" + i + "%, " + n + "%, " + r + "%)"
				},
				percentaString: z,
				hslString: function (t, e) {
					if (e < 1 || t[3] && t[3] < 1) return N(t, e);
					return "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)"
				},
				hslaString: N,
				hwbString: function (t, e) {
					void 0 === e && (e = void 0 !== t[3] ? t[3] : 1);
					return "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")"
				},
				keyword: function (t) {
					return H[t.slice(0, 3)]
				}
			};

		function O(t) {
			if (t) {
				var e = [0, 0, 0],
					i = 1,
					n = t.match(/^#([a-fA-F0-9]{3,4})$/i),
					r = "";
				if (n) {
					r = (n = n[1])[3];
					for (var a = 0; a < e.length; a++) e[a] = parseInt(n[a] + n[a], 16);
					r && (i = Math.round(parseInt(r + r, 16) / 255 * 100) / 100)
				} else if (n = t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)) {
					r = n[2], n = n[1];
					for (a = 0; a < e.length; a++) e[a] = parseInt(n.slice(2 * a, 2 * a + 2), 16);
					r && (i = Math.round(parseInt(r, 16) / 255 * 100) / 100)
				} else if (n = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
					for (a = 0; a < e.length; a++) e[a] = parseInt(n[a + 1]);
					i = parseFloat(n[4])
				} else if (n = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
					for (a = 0; a < e.length; a++) e[a] = Math.round(2.55 * parseFloat(n[a + 1]));
					i = parseFloat(n[4])
				} else if (n = t.match(/(\w+)/)) {
					if ("transparent" == n[1]) return [0, 0, 0, 0];
					if (!(e = I[n[1]])) return
				}
				for (a = 0; a < e.length; a++) e[a] = Y(e[a], 0, 255);
				return i = i || 0 == i ? Y(i, 0, 1) : 1, e[3] = i, e
			}
		}

		function R(t) {
			if (t) {
				var e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
				if (e) {
					var i = parseFloat(e[4]);
					return [Y(parseInt(e[1]), 0, 360), Y(parseFloat(e[2]), 0, 100), Y(parseFloat(e[3]), 0, 100), Y(isNaN(i) ? 1 : i, 0, 1)]
				}
			}
		}

		function B(t) {
			if (t) {
				var e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
				if (e) {
					var i = parseFloat(e[4]);
					return [Y(parseInt(e[1]), 0, 360), Y(parseFloat(e[2]), 0, 100), Y(parseFloat(e[3]), 0, 100), Y(isNaN(i) ? 1 : i, 0, 1)]
				}
			}
		}

		function W(t, e) {
			return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")"
		}

		function z(t, e) {
			return "rgba(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")"
		}

		function N(t, e) {
			return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")"
		}

		function Y(t, e, i) {
			return Math.min(Math.max(e, t), i)
		}

		function E(t) {
			var e = t.toString(16).toUpperCase();
			return e.length < 2 ? "0" + e : e
		}
		var H = {};
		for (var V in I) H[I[V]] = V;
		var j = function (t) {
			return t instanceof j ? t : this instanceof j ? (this.valid = !1, this.values = {
				rgb: [0, 0, 0],
				hsl: [0, 0, 0],
				hsv: [0, 0, 0],
				hwb: [0, 0, 0],
				cmyk: [0, 0, 0, 0],
				alpha: 1
			}, void("string" == typeof t ? (e = L.getRgba(t)) ? this.setValues("rgb", e) : (e = L.getHsla(t)) ? this.setValues("hsl", e) : (e = L.getHwb(t)) && this.setValues("hwb", e) : "object" == typeof t && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e)))) : new j(t);
			var e
		};
		j.prototype = {
			isValid: function () {
				return this.valid
			},
			rgb: function () {
				return this.setSpace("rgb", arguments)
			},
			hsl: function () {
				return this.setSpace("hsl", arguments)
			},
			hsv: function () {
				return this.setSpace("hsv", arguments)
			},
			hwb: function () {
				return this.setSpace("hwb", arguments)
			},
			cmyk: function () {
				return this.setSpace("cmyk", arguments)
			},
			rgbArray: function () {
				return this.values.rgb
			},
			hslArray: function () {
				return this.values.hsl
			},
			hsvArray: function () {
				return this.values.hsv
			},
			hwbArray: function () {
				var t = this.values;
				return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb
			},
			cmykArray: function () {
				return this.values.cmyk
			},
			rgbaArray: function () {
				var t = this.values;
				return t.rgb.concat([t.alpha])
			},
			hslaArray: function () {
				var t = this.values;
				return t.hsl.concat([t.alpha])
			},
			alpha: function (t) {
				return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this)
			},
			red: function (t) {
				return this.setChannel("rgb", 0, t)
			},
			green: function (t) {
				return this.setChannel("rgb", 1, t)
			},
			blue: function (t) {
				return this.setChannel("rgb", 2, t)
			},
			hue: function (t) {
				return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t)
			},
			saturation: function (t) {
				return this.setChannel("hsl", 1, t)
			},
			lightness: function (t) {
				return this.setChannel("hsl", 2, t)
			},
			saturationv: function (t) {
				return this.setChannel("hsv", 1, t)
			},
			whiteness: function (t) {
				return this.setChannel("hwb", 1, t)
			},
			blackness: function (t) {
				return this.setChannel("hwb", 2, t)
			},
			value: function (t) {
				return this.setChannel("hsv", 2, t)
			},
			cyan: function (t) {
				return this.setChannel("cmyk", 0, t)
			},
			magenta: function (t) {
				return this.setChannel("cmyk", 1, t)
			},
			yellow: function (t) {
				return this.setChannel("cmyk", 2, t)
			},
			black: function (t) {
				return this.setChannel("cmyk", 3, t)
			},
			hexString: function () {
				return L.hexString(this.values.rgb)
			},
			rgbString: function () {
				return L.rgbString(this.values.rgb, this.values.alpha)
			},
			rgbaString: function () {
				return L.rgbaString(this.values.rgb, this.values.alpha)
			},
			percentString: function () {
				return L.percentString(this.values.rgb, this.values.alpha)
			},
			hslString: function () {
				return L.hslString(this.values.hsl, this.values.alpha)
			},
			hslaString: function () {
				return L.hslaString(this.values.hsl, this.values.alpha)
			},
			hwbString: function () {
				return L.hwbString(this.values.hwb, this.values.alpha)
			},
			keyword: function () {
				return L.keyword(this.values.rgb, this.values.alpha)
			},
			rgbNumber: function () {
				var t = this.values.rgb;
				return t[0] << 16 | t[1] << 8 | t[2]
			},
			luminosity: function () {
				for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) {
					var n = t[i] / 255;
					e[i] = n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
				}
				return .2126 * e[0] + .7152 * e[1] + .0722 * e[2]
			},
			contrast: function (t) {
				var e = this.luminosity(),
					i = t.luminosity();
				return i < e ? (e + .05) / (i + .05) : (i + .05) / (e + .05)
			},
			level: function (t) {
				var e = this.contrast(t);
				return 7.1 <= e ? "AAA" : 4.5 <= e ? "AA" : ""
			},
			dark: function () {
				var t = this.values.rgb;
				return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128
			},
			light: function () {
				return !this.dark()
			},
			negate: function () {
				for (var t = [], e = 0; e < 3; e++) t[e] = 255 - this.values.rgb[e];
				return this.setValues("rgb", t), this
			},
			lighten: function (t) {
				var e = this.values.hsl;
				return e[2] += e[2] * t, this.setValues("hsl", e), this
			},
			darken: function (t) {
				var e = this.values.hsl;
				return e[2] -= e[2] * t, this.setValues("hsl", e), this
			},
			saturate: function (t) {
				var e = this.values.hsl;
				return e[1] += e[1] * t, this.setValues("hsl", e), this
			},
			desaturate: function (t) {
				var e = this.values.hsl;
				return e[1] -= e[1] * t, this.setValues("hsl", e), this
			},
			whiten: function (t) {
				var e = this.values.hwb;
				return e[1] += e[1] * t, this.setValues("hwb", e), this
			},
			blacken: function (t) {
				var e = this.values.hwb;
				return e[2] += e[2] * t, this.setValues("hwb", e), this
			},
			greyscale: function () {
				var t = this.values.rgb,
					e = .3 * t[0] + .59 * t[1] + .11 * t[2];
				return this.setValues("rgb", [e, e, e]), this
			},
			clearer: function (t) {
				var e = this.values.alpha;
				return this.setValues("alpha", e - e * t), this
			},
			opaquer: function (t) {
				var e = this.values.alpha;
				return this.setValues("alpha", e + e * t), this
			},
			rotate: function (t) {
				var e = this.values.hsl,
					i = (e[0] + t) % 360;
				return e[0] = i < 0 ? 360 + i : i, this.setValues("hsl", e), this
			},
			mix: function (t, e) {
				var i = this,
					n = t,
					r = void 0 === e ? .5 : e,
					a = 2 * r - 1,
					o = i.alpha() - n.alpha(),
					s = ((a * o == -1 ? a : (a + o) / (1 + a * o)) + 1) / 2,
					l = 1 - s;
				return this.rgb(s * i.red() + l * n.red(), s * i.green() + l * n.green(), s * i.blue() + l * n.blue()).alpha(i.alpha() * r + n.alpha() * (1 - r))
			},
			toJSON: function () {
				return this.rgb()
			},
			clone: function () {
				var t, e, i = new j,
					n = this.values,
					r = i.values;
				for (var a in n) n.hasOwnProperty(a) && (t = n[a], "[object Array]" === (e = {}.toString.call(t)) ? r[a] = t.slice(0) : "[object Number]" === e ? r[a] = t : console.error("unexpected color value:", t));
				return i
			}
		}, j.prototype.spaces = {
			rgb: ["red", "green", "blue"],
			hsl: ["hue", "saturation", "lightness"],
			hsv: ["hue", "saturation", "value"],
			hwb: ["hue", "whiteness", "blackness"],
			cmyk: ["cyan", "magenta", "yellow", "black"]
		}, j.prototype.maxes = {
			rgb: [255, 255, 255],
			hsl: [360, 100, 100],
			hsv: [360, 100, 100],
			hwb: [360, 100, 100],
			cmyk: [100, 100, 100, 100]
		}, j.prototype.getValues = function (t) {
			for (var e = this.values, i = {}, n = 0; n < t.length; n++) i[t.charAt(n)] = e[t][n];
			return 1 !== e.alpha && (i.a = e.alpha), i
		}, j.prototype.setValues = function (t, e) {
			var i, n, r = this.values,
				a = this.spaces,
				o = this.maxes,
				s = 1;
			if (this.valid = !0, "alpha" === t) s = e;
			else if (e.length) r[t] = e.slice(0, t.length), s = e[t.length];
			else if (void 0 !== e[t.charAt(0)]) {
				for (i = 0; i < t.length; i++) r[t][i] = e[t.charAt(i)];
				s = e.a
			} else if (void 0 !== e[a[t][0]]) {
				var l = a[t];
				for (i = 0; i < t.length; i++) r[t][i] = e[l[i]];
				s = e.alpha
			}
			if (r.alpha = Math.max(0, Math.min(1, void 0 === s ? r.alpha : s)), "alpha" === t) return !1;
			for (i = 0; i < t.length; i++) n = Math.max(0, Math.min(o[t][i], r[t][i])), r[t][i] = Math.round(n);
			for (var h in a) h !== t && (r[h] = F[t][h](r[t]));
			return !0
		}, j.prototype.setSpace = function (t, e) {
			var i = e[0];
			return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i), this)
		}, j.prototype.setChannel = function (t, e, i) {
			var n = this.values[t];
			return void 0 === i ? n[e] : (i === n[e] || (n[e] = i, this.setValues(t, n)), this)
		}, "undefined" != typeof window && (window.Color = j);
		var U, G = j,
			$ = {
				noop: function () {},
				uid: (U = 0, function () {
					return U++
				}),
				isNullOrUndef: function (t) {
					return null == t
				},
				isArray: function (t) {
					if (Array.isArray && Array.isArray(t)) return !0;
					var e = Object.prototype.toString.call(t);
					return "[object" === e.substr(0, 7) && "Array]" === e.substr(-6)
				},
				isObject: function (t) {
					return null !== t && "[object Object]" === Object.prototype.toString.call(t)
				},
				isFinite: function (t) {
					return ("number" == typeof t || t instanceof Number) && isFinite(t)
				},
				valueOrDefault: function (t, e) {
					return void 0 === t ? e : t
				},
				valueAtIndexOrDefault: function (t, e, i) {
					return $.valueOrDefault($.isArray(t) ? t[e] : t, i)
				},
				callback: function (t, e, i) {
					if (t && "function" == typeof t.call) return t.apply(i, e)
				},
				each: function (t, e, i, n) {
					var r, a, o;
					if ($.isArray(t))
						if (a = t.length, n)
							for (r = a - 1; 0 <= r; r--) e.call(i, t[r], r);
						else
							for (r = 0; r < a; r++) e.call(i, t[r], r);
					else if ($.isObject(t))
						for (a = (o = Object.keys(t)).length, r = 0; r < a; r++) e.call(i, t[o[r]], o[r])
				},
				arrayEquals: function (t, e) {
					var i, n, r, a;
					if (!t || !e || t.length !== e.length) return !1;
					for (i = 0, n = t.length; i < n; ++i)
						if (r = t[i], a = e[i], r instanceof Array && a instanceof Array) {
							if (!$.arrayEquals(r, a)) return !1
						} else if (r !== a) return !1;
					return !0
				},
				clone: function (t) {
					if ($.isArray(t)) return t.map($.clone);
					if ($.isObject(t)) {
						for (var e = {}, i = Object.keys(t), n = i.length, r = 0; r < n; ++r) e[i[r]] = $.clone(t[i[r]]);
						return e
					}
					return t
				},
				_merger: function (t, e, i, n) {
					var r = e[t],
						a = i[t];
					$.isObject(r) && $.isObject(a) ? $.merge(r, a, n) : e[t] = $.clone(a)
				},
				_mergerIf: function (t, e, i) {
					var n = e[t],
						r = i[t];
					$.isObject(n) && $.isObject(r) ? $.mergeIf(n, r) : e.hasOwnProperty(t) || (e[t] = $.clone(r))
				},
				merge: function (t, e, i) {
					var n, r, a, o, s, l = $.isArray(e) ? e : [e],
						h = l.length;
					if (!$.isObject(t)) return t;
					for (n = (i = i || {}).merger || $._merger, r = 0; r < h; ++r)
						if (e = l[r], $.isObject(e))
							for (s = 0, o = (a = Object.keys(e)).length; s < o; ++s) n(a[s], t, e, i);
					return t
				},
				mergeIf: function (t, e) {
					return $.merge(t, e, {
						merger: $._mergerIf
					})
				},
				extend: function (i) {
					for (var t = function (t, e) {
							i[e] = t
						}, e = 1, n = arguments.length; e < n; ++e) $.each(arguments[e], t);
					return i
				},
				inherits: function (t) {
					var e = this,
						i = t && t.hasOwnProperty("constructor") ? t.constructor : function () {
							return e.apply(this, arguments)
						},
						n = function () {
							this.constructor = i
						};
					return n.prototype = e.prototype, i.prototype = new n, i.extend = $.inherits, t && $.extend(i.prototype, t), i.__super__ = e.prototype, i
				}
			},
			q = $;
		$.callCallback = $.callback, $.indexOf = function (t, e, i) {
			return Array.prototype.indexOf.call(t, e, i)
		}, $.getValueOrDefault = $.valueOrDefault, $.getValueAtIndexOrDefault = $.valueAtIndexOrDefault;
		var X = {
				linear: function (t) {
					return t
				},
				easeInQuad: function (t) {
					return t * t
				},
				easeOutQuad: function (t) {
					return -t * (t - 2)
				},
				easeInOutQuad: function (t) {
					return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
				},
				easeInCubic: function (t) {
					return t * t * t
				},
				easeOutCubic: function (t) {
					return (t -= 1) * t * t + 1
				},
				easeInOutCubic: function (t) {
					return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
				},
				easeInQuart: function (t) {
					return t * t * t * t
				},
				easeOutQuart: function (t) {
					return -((t -= 1) * t * t * t - 1)
				},
				easeInOutQuart: function (t) {
					return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
				},
				easeInQuint: function (t) {
					return t * t * t * t * t
				},
				easeOutQuint: function (t) {
					return (t -= 1) * t * t * t * t + 1
				},
				easeInOutQuint: function (t) {
					return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
				},
				easeInSine: function (t) {
					return 1 - Math.cos(t * (Math.PI / 2))
				},
				easeOutSine: function (t) {
					return Math.sin(t * (Math.PI / 2))
				},
				easeInOutSine: function (t) {
					return -.5 * (Math.cos(Math.PI * t) - 1)
				},
				easeInExpo: function (t) {
					return 0 === t ? 0 : Math.pow(2, 10 * (t - 1))
				},
				easeOutExpo: function (t) {
					return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
				},
				easeInOutExpo: function (t) {
					return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * --t))
				},
				easeInCirc: function (t) {
					return 1 <= t ? t : -(Math.sqrt(1 - t * t) - 1)
				},
				easeOutCirc: function (t) {
					return Math.sqrt(1 - (t -= 1) * t)
				},
				easeInOutCirc: function (t) {
					return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
				},
				easeInElastic: function (t) {
					var e = 1.70158,
						i = 0,
						n = 1;
					return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), e = n < 1 ? (n = 1, i / 4) : i / (2 * Math.PI) * Math.asin(1 / n), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i))
				},
				easeOutElastic: function (t) {
					var e = 1.70158,
						i = 0,
						n = 1;
					return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), e = n < 1 ? (n = 1, i / 4) : i / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / i) + 1)
				},
				easeInOutElastic: function (t) {
					var e = 1.70158,
						i = 0,
						n = 1;
					return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (i || (i = .45), e = n < 1 ? (n = 1, i / 4) : i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * -.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * .5 + 1)
				},
				easeInBack: function (t) {
					return t * t * (2.70158 * t - 1.70158)
				},
				easeOutBack: function (t) {
					return (t -= 1) * t * (2.70158 * t + 1.70158) + 1
				},
				easeInOutBack: function (t) {
					var e = 1.70158;
					return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
				},
				easeInBounce: function (t) {
					return 1 - X.easeOutBounce(1 - t)
				},
				easeOutBounce: function (t) {
					return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
				},
				easeInOutBounce: function (t) {
					return t < .5 ? .5 * X.easeInBounce(2 * t) : .5 * X.easeOutBounce(2 * t - 1) + .5
				}
			},
			Z = {
				effects: X
			};
		q.easingEffects = X;
		var Q = Math.PI,
			K = Q / 180,
			J = 2 * Q,
			tt = Q / 2,
			et = Q / 4,
			it = 2 * Q / 3,
			nt = {
				clear: function (t) {
					t.ctx.clearRect(0, 0, t.width, t.height)
				},
				roundedRect: function (t, e, i, n, r, a) {
					if (a) {
						var o = Math.min(a, r / 2, n / 2),
							s = e + o,
							l = i + o,
							h = e + n - o,
							u = i + r - o;
						t.moveTo(e, l), s < h && l < u ? (t.arc(s, l, o, -Q, -tt), t.arc(h, l, o, -tt, 0), t.arc(h, u, o, 0, tt), t.arc(s, u, o, tt, Q)) : s < h ? (t.moveTo(s, i), t.arc(h, l, o, -tt, tt), t.arc(s, l, o, tt, Q + tt)) : l < u ? (t.arc(s, l, o, -Q, 0), t.arc(s, u, o, 0, Q)) : t.arc(s, l, o, -Q, Q), t.closePath(), t.moveTo(e, i)
					} else t.rect(e, i, n, r)
				},
				drawPoint: function (t, e, i, n, r, a) {
					var o, s, l, h, u, d = (a || 0) * K;
					if (!e || "object" != typeof e || "[object HTMLImageElement]" !== (o = e.toString()) && "[object HTMLCanvasElement]" !== o) {
						if (!(isNaN(i) || i <= 0)) {
							switch (t.beginPath(), e) {
								default:
									t.arc(n, r, i, 0, J), t.closePath();
									break;
								case "triangle":
									t.moveTo(n + Math.sin(d) * i, r - Math.cos(d) * i), d += it, t.lineTo(n + Math.sin(d) * i, r - Math.cos(d) * i), d += it, t.lineTo(n + Math.sin(d) * i, r - Math.cos(d) * i), t.closePath();
									break;
								case "rectRounded":
									h = i - (u = .516 * i), s = Math.cos(d + et) * h, l = Math.sin(d + et) * h, t.arc(n - s, r - l, u, d - Q, d - tt), t.arc(n + l, r - s, u, d - tt, d), t.arc(n + s, r + l, u, d, d + tt), t.arc(n - l, r + s, u, d + tt, d + Q), t.closePath();
									break;
								case "rect":
									if (!a) {
										h = Math.SQRT1_2 * i, t.rect(n - h, r - h, 2 * h, 2 * h);
										break
									}
									d += et;
								case "rectRot":
									s = Math.cos(d) * i, l = Math.sin(d) * i, t.moveTo(n - s, r - l), t.lineTo(n + l, r - s), t.lineTo(n + s, r + l), t.lineTo(n - l, r + s), t.closePath();
									break;
								case "crossRot":
									d += et;
								case "cross":
									s = Math.cos(d) * i, l = Math.sin(d) * i, t.moveTo(n - s, r - l), t.lineTo(n + s, r + l), t.moveTo(n + l, r - s), t.lineTo(n - l, r + s);
									break;
								case "star":
									s = Math.cos(d) * i, l = Math.sin(d) * i, t.moveTo(n - s, r - l), t.lineTo(n + s, r + l), t.moveTo(n + l, r - s), t.lineTo(n - l, r + s), d += et, s = Math.cos(d) * i, l = Math.sin(d) * i, t.moveTo(n - s, r - l), t.lineTo(n + s, r + l), t.moveTo(n + l, r - s), t.lineTo(n - l, r + s);
									break;
								case "line":
									s = Math.cos(d) * i, l = Math.sin(d) * i, t.moveTo(n - s, r - l), t.lineTo(n + s, r + l);
									break;
								case "dash":
									t.moveTo(n, r), t.lineTo(n + Math.cos(d) * i, r + Math.sin(d) * i)
							}
							t.fill(), t.stroke()
						}
					} else t.drawImage(e, n - e.width / 2, r - e.height / 2, e.width, e.height)
				},
				_isPointInArea: function (t, e) {
					return t.x > e.left - 1e-6 && t.x < e.right + 1e-6 && t.y > e.top - 1e-6 && t.y < e.bottom + 1e-6
				},
				clipArea: function (t, e) {
					t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()
				},
				unclipArea: function (t) {
					t.restore()
				},
				lineTo: function (t, e, i, n) {
					var r = i.steppedLine;
					if (r) {
						if ("middle" === r) {
							var a = (e.x + i.x) / 2;
							t.lineTo(a, n ? i.y : e.y), t.lineTo(a, n ? e.y : i.y)
						} else "after" === r && !n || "after" !== r && n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
						t.lineTo(i.x, i.y)
					} else i.tension ? t.bezierCurveTo(n ? e.controlPointPreviousX : e.controlPointNextX, n ? e.controlPointPreviousY : e.controlPointNextY, n ? i.controlPointNextX : i.controlPointPreviousX, n ? i.controlPointNextY : i.controlPointPreviousY, i.x, i.y) : t.lineTo(i.x, i.y)
				}
			},
			rt = nt;
		q.clear = nt.clear, q.drawRoundedRectangle = function (t) {
			t.beginPath(), nt.roundedRect.apply(nt, arguments)
		};
		var at = {
			_set: function (t, e) {
				return q.merge(this[t] || (this[t] = {}), e)
			}
		};
		at._set("global", {
			defaultColor: "rgba(0,0,0,0.1)",
			defaultFontColor: "#666",
			defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Shabnam', sans-serif",
			defaultFontSize: 12,
			defaultFontStyle: "normal",
			defaultLineHeight: 1.2,
			showLines: !0
		});
		var ot = at,
			st = q.valueOrDefault;
		var lt = {
				toLineHeight: function (t, e) {
					var i = ("" + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
					if (!i || "normal" === i[1]) return 1.2 * e;
					switch (t = +i[2], i[3]) {
						case "px":
							return t;
						case "%":
							t /= 100
					}
					return e * t
				},
				toPadding: function (t) {
					var e, i, n, r;
					return q.isObject(t) ? (e = +t.top || 0, i = +t.right || 0, n = +t.bottom || 0, r = +t.left || 0) : e = i = n = r = +t || 0, {
						top: e,
						right: i,
						bottom: n,
						left: r,
						height: e + n,
						width: r + i
					}
				},
				_parseFont: function (t) {
					var e, i = ot.global,
						n = st(t.fontSize, i.defaultFontSize),
						r = {
							family: st(t.fontFamily, i.defaultFontFamily),
							lineHeight: q.options.toLineHeight(st(t.lineHeight, i.defaultLineHeight), n),
							size: n,
							style: st(t.fontStyle, i.defaultFontStyle),
							weight: null,
							string: ""
						};
					return r.string = !(e = r) || q.isNullOrUndef(e.size) || q.isNullOrUndef(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family, r
				},
				resolve: function (t, e, i) {
					var n, r, a;
					for (n = 0, r = t.length; n < r; ++n)
						if (void 0 !== (a = t[n]) && (void 0 !== e && "function" == typeof a && (a = a(e)), void 0 !== i && q.isArray(a) && (a = a[i]), void 0 !== a)) return a
				}
			},
			ht = q,
			ut = Z,
			dt = rt,
			ct = lt;
		ht.easing = ut, ht.canvas = dt, ht.options = ct;
		var ft = function (t) {
			ht.extend(this, t), this.initialize.apply(this, arguments)
		};
		ht.extend(ft.prototype, {
			initialize: function () {
				this.hidden = !1
			},
			pivot: function () {
				var t = this;
				return t._view || (t._view = ht.clone(t._model)), t._start = {}, t
			},
			transition: function (t) {
				var e = this,
					i = e._model,
					n = e._start,
					r = e._view;
				return i && 1 !== t ? (r || (r = e._view = {}), n || (n = e._start = {}), function (t, e, i, n) {
					var r, a, o, s, l, h, u, d, c, f = Object.keys(i);
					for (r = 0, a = f.length; r < a; ++r)
						if (h = i[o = f[r]], e.hasOwnProperty(o) || (e[o] = h), (s = e[o]) !== h && "_" !== o[0]) {
							if (t.hasOwnProperty(o) || (t[o] = s), (u = typeof h) == typeof (l = t[o]))
								if ("string" === u) {
									if ((d = G(l)).valid && (c = G(h)).valid) {
										e[o] = c.mix(d, n).rgbString();
										continue
									}
								} else if (ht.isFinite(l) && ht.isFinite(h)) {
								e[o] = l + (h - l) * n;
								continue
							}
							e[o] = h
						}
				}(n, r, i, t)) : (e._view = i, e._start = null), e
			},
			tooltipPosition: function () {
				return {
					x: this._model.x,
					y: this._model.y
				}
			},
			hasValue: function () {
				return ht.isNumber(this._model.x) && ht.isNumber(this._model.y)
			}
		}), ft.extend = ht.inherits;
		var pt = ft,
			gt = pt.extend({
				chart: null,
				currentStep: 0,
				numSteps: 60,
				easing: "",
				render: null,
				onAnimationProgress: null,
				onAnimationComplete: null
			}),
			mt = gt;
		Object.defineProperty(gt.prototype, "animationObject", {
			get: function () {
				return this
			}
		}), Object.defineProperty(gt.prototype, "chartInstance", {
			get: function () {
				return this.chart
			},
			set: function (t) {
				this.chart = t
			}
		}), ot._set("global", {
			animation: {
				duration: 1e3,
				easing: "easeOutQuart",
				onProgress: ht.noop,
				onComplete: ht.noop
			}
		});
		var vt = {
				animations: [],
				request: null,
				addAnimation: function (t, e, i, n) {
					var r, a, o = this.animations;
					for (e.chart = t, e.startTime = Date.now(), e.duration = i, n || (t.animating = !0), r = 0, a = o.length; r < a; ++r)
						if (o[r].chart === t) return void(o[r] = e);
					o.push(e), 1 === o.length && this.requestAnimationFrame()
				},
				cancelAnimation: function (e) {
					var t = ht.findIndex(this.animations, function (t) {
						return t.chart === e
					}); - 1 !== t && (this.animations.splice(t, 1), e.animating = !1)
				},
				requestAnimationFrame: function () {
					var t = this;
					null === t.request && (t.request = ht.requestAnimFrame.call(window, function () {
						t.request = null, t.startDigest()
					}))
				},
				startDigest: function () {
					this.advance(), 0 < this.animations.length && this.requestAnimationFrame()
				},
				advance: function () {
					for (var t, e, i, n, r = this.animations, a = 0; a < r.length;) e = (t = r[a]).chart, i = t.numSteps, n = Math.floor((Date.now() - t.startTime) / t.duration * i) + 1, t.currentStep = Math.min(n, i), ht.callback(t.render, [e, t], e), ht.callback(t.onAnimationProgress, [t], e), t.currentStep >= i ? (ht.callback(t.onAnimationComplete, [t], e), e.animating = !1, r.splice(a, 1)) : ++a
				}
			},
			yt = ht.options.resolve,
			xt = ["push", "pop", "shift", "splice", "unshift"];

		function bt(e, t) {
			var i = e._chartjs;
			if (i) {
				var n = i.listeners,
					r = n.indexOf(t); - 1 !== r && n.splice(r, 1), 0 < n.length || (xt.forEach(function (t) {
					delete e[t]
				}), delete e._chartjs)
			}
		}
		var _t = function (t, e) {
			this.initialize(t, e)
		};
		ht.extend(_t.prototype, {
			datasetElementType: null,
			dataElementType: null,
			initialize: function (t, e) {
				this.chart = t, this.index = e, this.linkScales(), this.addElements()
			},
			updateIndex: function (t) {
				this.index = t
			},
			linkScales: function () {
				var t = this,
					e = t.getMeta(),
					i = t.getDataset();
				null !== e.xAxisID && e.xAxisID in t.chart.scales || (e.xAxisID = i.xAxisID || t.chart.options.scales.xAxes[0].id), null !== e.yAxisID && e.yAxisID in t.chart.scales || (e.yAxisID = i.yAxisID || t.chart.options.scales.yAxes[0].id)
			},
			getDataset: function () {
				return this.chart.data.datasets[this.index]
			},
			getMeta: function () {
				return this.chart.getDatasetMeta(this.index)
			},
			getScaleForId: function (t) {
				return this.chart.scales[t]
			},
			_getValueScaleId: function () {
				return this.getMeta().yAxisID
			},
			_getIndexScaleId: function () {
				return this.getMeta().xAxisID
			},
			_getValueScale: function () {
				return this.getScaleForId(this._getValueScaleId())
			},
			_getIndexScale: function () {
				return this.getScaleForId(this._getIndexScaleId())
			},
			reset: function () {
				this.update(!0)
			},
			destroy: function () {
				this._data && bt(this._data, this)
			},
			createMetaDataset: function () {
				var t = this.datasetElementType;
				return t && new t({
					_chart: this.chart,
					_datasetIndex: this.index
				})
			},
			createMetaData: function (t) {
				var e = this.dataElementType;
				return e && new e({
					_chart: this.chart,
					_datasetIndex: this.index,
					_index: t
				})
			},
			addElements: function () {
				var t, e, i = this.getMeta(),
					n = this.getDataset().data || [],
					r = i.data;
				for (t = 0, e = n.length; t < e; ++t) r[t] = r[t] || this.createMetaData(t);
				i.dataset = i.dataset || this.createMetaDataset()
			},
			addElementAndReset: function (t) {
				var e = this.createMetaData(t);
				this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0)
			},
			buildOrUpdateElements: function () {
				var r, t, e = this,
					i = e.getDataset(),
					n = i.data || (i.data = []);
				e._data !== n && (e._data && bt(e._data, e), n && Object.isExtensible(n) && (t = e, (r = n)._chartjs ? r._chartjs.listeners.push(t) : (Object.defineProperty(r, "_chartjs", {
					configurable: !0,
					enumerable: !1,
					value: {
						listeners: [t]
					}
				}), xt.forEach(function (t) {
					var i = "onData" + t.charAt(0).toUpperCase() + t.slice(1),
						n = r[t];
					Object.defineProperty(r, t, {
						configurable: !0,
						enumerable: !1,
						value: function () {
							var e = Array.prototype.slice.call(arguments),
								t = n.apply(this, e);
							return ht.each(r._chartjs.listeners, function (t) {
								"function" == typeof t[i] && t[i].apply(t, e)
							}), t
						}
					})
				}))), e._data = n), e.resyncElements()
			},
			update: ht.noop,
			transition: function (t) {
				for (var e = this.getMeta(), i = e.data || [], n = i.length, r = 0; r < n; ++r) i[r].transition(t);
				e.dataset && e.dataset.transition(t)
			},
			draw: function () {
				var t = this.getMeta(),
					e = t.data || [],
					i = e.length,
					n = 0;
				for (t.dataset && t.dataset.draw(); n < i; ++n) e[n].draw()
			},
			removeHoverStyle: function (t) {
				ht.merge(t._model, t.$previousStyle || {}), delete t.$previousStyle
			},
			setHoverStyle: function (t) {
				var e = this.chart.data.datasets[t._datasetIndex],
					i = t._index,
					n = t.custom || {},
					r = t._model,
					a = ht.getHoverColor;
				t.$previousStyle = {
					backgroundColor: r.backgroundColor,
					borderColor: r.borderColor,
					borderWidth: r.borderWidth
				}, r.backgroundColor = yt([n.hoverBackgroundColor, e.hoverBackgroundColor, a(r.backgroundColor)], void 0, i), r.borderColor = yt([n.hoverBorderColor, e.hoverBorderColor, a(r.borderColor)], void 0, i), r.borderWidth = yt([n.hoverBorderWidth, e.hoverBorderWidth, r.borderWidth], void 0, i)
			},
			resyncElements: function () {
				var t = this.getMeta(),
					e = this.getDataset().data,
					i = t.data.length,
					n = e.length;
				n < i ? t.data.splice(n, i - n) : i < n && this.insertElements(i, n - i)
			},
			insertElements: function (t, e) {
				for (var i = 0; i < e; ++i) this.addElementAndReset(t + i)
			},
			onDataPush: function () {
				var t = arguments.length;
				this.insertElements(this.getDataset().data.length - t, t)
			},
			onDataPop: function () {
				this.getMeta().data.pop()
			},
			onDataShift: function () {
				this.getMeta().data.shift()
			},
			onDataSplice: function (t, e) {
				this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2)
			},
			onDataUnshift: function () {
				this.insertElements(0, arguments.length)
			}
		}), _t.extend = ht.inherits;
		var wt = _t;
		ot._set("global", {
			elements: {
				arc: {
					backgroundColor: ot.global.defaultColor,
					borderColor: "#fff",
					borderWidth: 2,
					borderAlign: "center"
				}
			}
		});
		var kt = pt.extend({
				inLabelRange: function (t) {
					var e = this._view;
					return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2)
				},
				inRange: function (t, e) {
					var i = this._view;
					if (i) {
						for (var n = ht.getAngleFromPoint(i, {
								x: t,
								y: e
							}), r = n.angle, a = n.distance, o = i.startAngle, s = i.endAngle; s < o;) s += 2 * Math.PI;
						for (; s < r;) r -= 2 * Math.PI;
						for (; r < o;) r += 2 * Math.PI;
						var l = o <= r && r <= s,
							h = a >= i.innerRadius && a <= i.outerRadius;
						return l && h
					}
					return !1
				},
				getCenterPoint: function () {
					var t = this._view,
						e = (t.startAngle + t.endAngle) / 2,
						i = (t.innerRadius + t.outerRadius) / 2;
					return {
						x: t.x + Math.cos(e) * i,
						y: t.y + Math.sin(e) * i
					}
				},
				getArea: function () {
					var t = this._view;
					return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2))
				},
				tooltipPosition: function () {
					var t = this._view,
						e = t.startAngle + (t.endAngle - t.startAngle) / 2,
						i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius;
					return {
						x: t.x + Math.cos(e) * i,
						y: t.y + Math.sin(e) * i
					}
				},
				draw: function () {
					var t, e = this._chart.ctx,
						i = this._view,
						n = i.startAngle,
						r = i.endAngle,
						a = "inner" === i.borderAlign ? .33 : 0;
					e.save(), e.beginPath(), e.arc(i.x, i.y, Math.max(i.outerRadius - a, 0), n, r), e.arc(i.x, i.y, i.innerRadius, r, n, !0), e.closePath(), e.fillStyle = i.backgroundColor, e.fill(), i.borderWidth && ("inner" === i.borderAlign ? (e.beginPath(), t = a / i.outerRadius, e.arc(i.x, i.y, i.outerRadius, n - t, r + t), i.innerRadius > a ? (t = a / i.innerRadius, e.arc(i.x, i.y, i.innerRadius - a, r + t, n - t, !0)) : e.arc(i.x, i.y, a, r + Math.PI / 2, n - Math.PI / 2), e.closePath(), e.clip(), e.beginPath(), e.arc(i.x, i.y, i.outerRadius, n, r), e.arc(i.x, i.y, i.innerRadius, r, n, !0), e.closePath(), e.lineWidth = 2 * i.borderWidth, e.lineJoin = "round") : (e.lineWidth = i.borderWidth, e.lineJoin = "bevel"), e.strokeStyle = i.borderColor, e.stroke()), e.restore()
				}
			}),
			Mt = ht.valueOrDefault,
			St = ot.global.defaultColor;
		ot._set("global", {
			elements: {
				line: {
					tension: .4,
					backgroundColor: St,
					borderWidth: 3,
					borderColor: St,
					borderCapStyle: "butt",
					borderDash: [],
					borderDashOffset: 0,
					borderJoinStyle: "miter",
					capBezierPoints: !0,
					fill: !0
				}
			}
		});
		var Ct = pt.extend({
				draw: function () {
					var t, e, i, n, r = this._view,
						a = this._chart.ctx,
						o = r.spanGaps,
						s = this._children.slice(),
						l = ot.global,
						h = l.elements.line,
						u = -1;
					for (this._loop && s.length && s.push(s[0]), a.save(), a.lineCap = r.borderCapStyle || h.borderCapStyle, a.setLineDash && a.setLineDash(r.borderDash || h.borderDash), a.lineDashOffset = Mt(r.borderDashOffset, h.borderDashOffset), a.lineJoin = r.borderJoinStyle || h.borderJoinStyle, a.lineWidth = Mt(r.borderWidth, h.borderWidth), a.strokeStyle = r.borderColor || l.defaultColor, a.beginPath(), u = -1, t = 0; t < s.length; ++t) e = s[t], i = ht.previousItem(s, t), n = e._view, 0 === t ? n.skip || (a.moveTo(n.x, n.y), u = t) : (i = -1 === u ? i : s[u], n.skip || (u !== t - 1 && !o || -1 === u ? a.moveTo(n.x, n.y) : ht.canvas.lineTo(a, i._view, e._view), u = t));
					a.stroke(), a.restore()
				}
			}),
			Dt = ht.valueOrDefault,
			Tt = ot.global.defaultColor;

		function Pt(t) {
			var e = this._view;
			return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius
		}
		ot._set("global", {
			elements: {
				point: {
					radius: 3,
					pointStyle: "circle",
					backgroundColor: Tt,
					borderColor: Tt,
					borderWidth: 1,
					hitRadius: 1,
					hoverRadius: 4,
					hoverBorderWidth: 1
				}
			}
		});
		var At = pt.extend({
				inRange: function (t, e) {
					var i = this._view;
					return !!i && Math.pow(t - i.x, 2) + Math.pow(e - i.y, 2) < Math.pow(i.hitRadius + i.radius, 2)
				},
				inLabelRange: Pt,
				inXRange: Pt,
				inYRange: function (t) {
					var e = this._view;
					return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius
				},
				getCenterPoint: function () {
					var t = this._view;
					return {
						x: t.x,
						y: t.y
					}
				},
				getArea: function () {
					return Math.PI * Math.pow(this._view.radius, 2)
				},
				tooltipPosition: function () {
					var t = this._view;
					return {
						x: t.x,
						y: t.y,
						padding: t.radius + t.borderWidth
					}
				},
				draw: function (t) {
					var e = this._view,
						i = this._chart.ctx,
						n = e.pointStyle,
						r = e.rotation,
						a = e.radius,
						o = e.x,
						s = e.y,
						l = ot.global,
						h = l.defaultColor;
					e.skip || (void 0 === t || ht.canvas._isPointInArea(e, t)) && (i.strokeStyle = e.borderColor || h, i.lineWidth = Dt(e.borderWidth, l.elements.point.borderWidth), i.fillStyle = e.backgroundColor || h, ht.canvas.drawPoint(i, n, a, o, s, r))
				}
			}),
			Ft = ot.global.defaultColor;

		function It(t) {
			return t && void 0 !== t.width
		}

		function Lt(t) {
			var e, i, n, r, a;
			return r = It(t) ? (a = t.width / 2, e = t.x - a, i = t.x + a, n = Math.min(t.y, t.base), Math.max(t.y, t.base)) : (a = t.height / 2, e = Math.min(t.x, t.base), i = Math.max(t.x, t.base), n = t.y - a, t.y + a), {
				left: e,
				top: n,
				right: i,
				bottom: r
			}
		}

		function Ot(t, e, i) {
			return t === e ? i : t === i ? e : t
		}

		function Rt(t, e, i) {
			var n, r, a, o, s, l, h, u = t.borderWidth,
				d = (r = (n = t).borderSkipped, a = {}, r && (n.horizontal ? n.base > n.x && (r = Ot(r, "left", "right")) : n.base < n.y && (r = Ot(r, "bottom", "top")), a[r] = !0), a);
			return ht.isObject(u) ? (o = +u.top || 0, s = +u.right || 0, l = +u.bottom || 0, h = +u.left || 0) : o = s = l = h = +u || 0, {
				t: d.top || o < 0 ? 0 : i < o ? i : o,
				r: d.right || s < 0 ? 0 : e < s ? e : s,
				b: d.bottom || l < 0 ? 0 : i < l ? i : l,
				l: d.left || h < 0 ? 0 : e < h ? e : h
			}
		}

		function Bt(t, e, i) {
			var n = null === e,
				r = null === i,
				a = !(!t || n && r) && Lt(t);
			return a && (n || e >= a.left && e <= a.right) && (r || i >= a.top && i <= a.bottom)
		}
		ot._set("global", {
			elements: {
				rectangle: {
					backgroundColor: Ft,
					borderColor: Ft,
					borderSkipped: "bottom",
					borderWidth: 0
				}
			}
		});
		var Wt = pt.extend({
				draw: function () {
					var t, e, i, n, r, a = this._chart.ctx,
						o = this._view,
						s = (e = Lt(t = o), i = e.right - e.left, n = e.bottom - e.top, r = Rt(t, i / 2, n / 2), {
							outer: {
								x: e.left,
								y: e.top,
								w: i,
								h: n
							},
							inner: {
								x: e.left + r.l,
								y: e.top + r.t,
								w: i - r.l - r.r,
								h: n - r.t - r.b
							}
						}),
						l = s.outer,
						h = s.inner;
					a.fillStyle = o.backgroundColor, a.fillRect(l.x, l.y, l.w, l.h), l.w === h.w && l.h === h.h || (a.save(), a.beginPath(), a.rect(l.x, l.y, l.w, l.h), a.clip(), a.fillStyle = o.borderColor, a.rect(h.x, h.y, h.w, h.h), a.fill("evenodd"), a.restore())
				},
				height: function () {
					var t = this._view;
					return t.base - t.y
				},
				inRange: function (t, e) {
					return Bt(this._view, t, e)
				},
				inLabelRange: function (t, e) {
					var i = this._view;
					return It(i) ? Bt(i, t, null) : Bt(i, null, e)
				},
				inXRange: function (t) {
					return Bt(this._view, t, null)
				},
				inYRange: function (t) {
					return Bt(this._view, null, t)
				},
				getCenterPoint: function () {
					var t, e, i = this._view;
					return e = It(i) ? (t = i.x, (i.y + i.base) / 2) : (t = (i.x + i.base) / 2, i.y), {
						x: t,
						y: e
					}
				},
				getArea: function () {
					var t = this._view;
					return It(t) ? t.width * Math.abs(t.y - t.base) : t.height * Math.abs(t.x - t.base)
				},
				tooltipPosition: function () {
					var t = this._view;
					return {
						x: t.x,
						y: t.y
					}
				}
			}),
			zt = {},
			Nt = kt,
			Yt = Ct,
			Et = At,
			Ht = Wt;
		zt.Arc = Nt, zt.Line = Yt, zt.Point = Et, zt.Rectangle = Ht;
		var Vt = ht.options.resolve;
		ot._set("bar", {
			hover: {
				mode: "label"
			},
			scales: {
				xAxes: [{
					type: "category",
					categoryPercentage: .8,
					barPercentage: .9,
					offset: !0,
					gridLines: {
						offsetGridLines: !0
					}
				}],
				yAxes: [{
					type: "linear"
				}]
			}
		});
		var jt = wt.extend({
				dataElementType: zt.Rectangle,
				initialize: function () {
					var t;
					wt.prototype.initialize.apply(this, arguments), (t = this.getMeta()).stack = this.getDataset().stack, t.bar = !0
				},
				update: function (t) {
					var e, i, n = this.getMeta().data;
					for (this._ruler = this.getRuler(), e = 0, i = n.length; e < i; ++e) this.updateElement(n[e], e, t)
				},
				updateElement: function (t, e, i) {
					var n = this.getMeta(),
						r = this.getDataset(),
						a = this._resolveElementOptions(t, e);
					t._xScale = this.getScaleForId(n.xAxisID), t._yScale = this.getScaleForId(n.yAxisID), t._datasetIndex = this.index, t._index = e, t._model = {
						backgroundColor: a.backgroundColor,
						borderColor: a.borderColor,
						borderSkipped: a.borderSkipped,
						borderWidth: a.borderWidth,
						datasetLabel: r.label,
						label: this.chart.data.labels[e]
					}, this._updateElementGeometry(t, e, i), t.pivot()
				},
				_updateElementGeometry: function (t, e, i) {
					var n = t._model,
						r = this._getValueScale(),
						a = r.getBasePixel(),
						o = r.isHorizontal(),
						s = this._ruler || this.getRuler(),
						l = this.calculateBarValuePixels(this.index, e),
						h = this.calculateBarIndexPixels(this.index, e, s);
					n.horizontal = o, n.base = i ? a : l.base, n.x = o ? i ? a : l.head : h.center, n.y = o ? h.center : i ? a : l.head, n.height = o ? h.size : void 0, n.width = o ? void 0 : h.size
				},
				_getStacks: function (t) {
					var e, i, n = this.chart,
						r = this._getIndexScale().options.stacked,
						a = void 0 === t ? n.data.datasets.length : t + 1,
						o = [];
					for (e = 0; e < a; ++e)(i = n.getDatasetMeta(e)).bar && n.isDatasetVisible(e) && (!1 === r || !0 === r && -1 === o.indexOf(i.stack) || void 0 === r && (void 0 === i.stack || -1 === o.indexOf(i.stack))) && o.push(i.stack);
					return o
				},
				getStackCount: function () {
					return this._getStacks().length
				},
				getStackIndex: function (t, e) {
					var i = this._getStacks(t),
						n = void 0 !== e ? i.indexOf(e) : -1;
					return -1 === n ? i.length - 1 : n
				},
				getRuler: function () {
					var t, e, i = this._getIndexScale(),
						n = this.getStackCount(),
						r = this.index,
						a = i.isHorizontal(),
						o = a ? i.left : i.top,
						s = o + (a ? i.width : i.height),
						l = [];
					for (t = 0, e = this.getMeta().data.length; t < e; ++t) l.push(i.getPixelForValue(null, t, r));
					return {
						min: ht.isNullOrUndef(i.options.barThickness) ? function (t, e) {
							var i, n, r, a, o = t.isHorizontal() ? t.width : t.height,
								s = t.getTicks();
							for (r = 1, a = e.length; r < a; ++r) o = Math.min(o, Math.abs(e[r] - e[r - 1]));
							for (r = 0, a = s.length; r < a; ++r) n = t.getPixelForTick(r), o = 0 < r ? Math.min(o, n - i) : o, i = n;
							return o
						}(i, l) : -1,
						pixels: l,
						start: o,
						end: s,
						stackCount: n,
						scale: i
					}
				},
				calculateBarValuePixels: function (t, e) {
					var i, n, r, a, o, s, l = this.chart,
						h = this.getMeta(),
						u = this._getValueScale(),
						d = u.isHorizontal(),
						c = l.data.datasets,
						f = +u.getRightValue(c[t].data[e]),
						p = u.options.minBarLength,
						g = u.options.stacked,
						m = h.stack,
						v = 0;
					if (g || void 0 === g && void 0 !== m)
						for (i = 0; i < t; ++i)(n = l.getDatasetMeta(i)).bar && n.stack === m && n.controller._getValueScaleId() === u.id && l.isDatasetVisible(i) && (r = +u.getRightValue(c[i].data[e]), (f < 0 && r < 0 || 0 <= f && 0 < r) && (v += r));
					return a = u.getPixelForValue(v), s = (o = u.getPixelForValue(v + f)) - a, void 0 !== p && Math.abs(s) < p && (s = p, o = 0 <= f && !d || f < 0 && d ? a - p : a + p), {
						size: s,
						base: a,
						head: o,
						center: o + s / 2
					}
				},
				calculateBarIndexPixels: function (t, e, i) {
					var n, r, a, o, s, l, h, u, d, c, f, p, g, m, v, y, x, b = i.scale.options,
						_ = "flex" === b.barThickness ? (d = e, f = b, g = (c = i).pixels, m = g[d], v = 0 < d ? g[d - 1] : null, y = d < g.length - 1 ? g[d + 1] : null, x = f.categoryPercentage, null === v && (v = m - (null === y ? c.end - c.start : y - m)), null === y && (y = m + m - v), p = m - (m - Math.min(v, y)) / 2 * x, {
							chunk: Math.abs(y - v) / 2 * x / c.stackCount,
							ratio: f.barPercentage,
							start: p
						}) : (n = e, r = i, l = (a = b).barThickness, h = r.stackCount, u = r.pixels[n], s = ht.isNullOrUndef(l) ? (o = r.min * a.categoryPercentage, a.barPercentage) : (o = l * h, 1), {
							chunk: o / h,
							ratio: s,
							start: u - o / 2
						}),
						w = this.getStackIndex(t, this.getMeta().stack),
						k = _.start + _.chunk * w + _.chunk / 2,
						M = Math.min(ht.valueOrDefault(b.maxBarThickness, 1 / 0), _.chunk * _.ratio);
					return {
						base: k - M / 2,
						head: k + M / 2,
						center: k,
						size: M
					}
				},
				draw: function () {
					var t = this.chart,
						e = this._getValueScale(),
						i = this.getMeta().data,
						n = this.getDataset(),
						r = i.length,
						a = 0;
					for (ht.canvas.clipArea(t.ctx, t.chartArea); a < r; ++a) isNaN(e.getRightValue(n.data[a])) || i[a].draw();
					ht.canvas.unclipArea(t.ctx)
				},
				_resolveElementOptions: function (t, e) {
					var i, n, r, a = this.chart,
						o = a.data.datasets[this.index],
						s = t.custom || {},
						l = a.options.elements.rectangle,
						h = {},
						u = {
							chart: a,
							dataIndex: e,
							dataset: o,
							datasetIndex: this.index
						},
						d = ["backgroundColor", "borderColor", "borderSkipped", "borderWidth"];
					for (i = 0, n = d.length; i < n; ++i) h[r = d[i]] = Vt([s[r], o[r], l[r]], u, e);
					return h
				}
			}),
			Ut = ht.valueOrDefault,
			Gt = ht.options.resolve;
		ot._set("bubble", {
			hover: {
				mode: "single"
			},
			scales: {
				xAxes: [{
					type: "linear",
					position: "bottom",
					id: "x-axis-0"
				}],
				yAxes: [{
					type: "linear",
					position: "left",
					id: "y-axis-0"
				}]
			},
			tooltips: {
				callbacks: {
					title: function () {
						return ""
					},
					label: function (t, e) {
						var i = e.datasets[t.datasetIndex].label || "",
							n = e.datasets[t.datasetIndex].data[t.index];
						return i + ": (" + t.xLabel + ", " + t.yLabel + ", " + n.r + ")"
					}
				}
			}
		});
		var $t = wt.extend({
				dataElementType: zt.Point,
				update: function (i) {
					var n = this,
						t = n.getMeta().data;
					ht.each(t, function (t, e) {
						n.updateElement(t, e, i)
					})
				},
				updateElement: function (t, e, i) {
					var n = this.getMeta(),
						r = t.custom || {},
						a = this.getScaleForId(n.xAxisID),
						o = this.getScaleForId(n.yAxisID),
						s = this._resolveElementOptions(t, e),
						l = this.getDataset().data[e],
						h = this.index,
						u = i ? a.getPixelForDecimal(.5) : a.getPixelForValue("object" == typeof l ? l : NaN, e, h),
						d = i ? o.getBasePixel() : o.getPixelForValue(l, e, h);
					t._xScale = a, t._yScale = o, t._options = s, t._datasetIndex = h, t._index = e, t._model = {
						backgroundColor: s.backgroundColor,
						borderColor: s.borderColor,
						borderWidth: s.borderWidth,
						hitRadius: s.hitRadius,
						pointStyle: s.pointStyle,
						rotation: s.rotation,
						radius: i ? 0 : s.radius,
						skip: r.skip || isNaN(u) || isNaN(d),
						x: u,
						y: d
					}, t.pivot()
				},
				setHoverStyle: function (t) {
					var e = t._model,
						i = t._options,
						n = ht.getHoverColor;
					t.$previousStyle = {
						backgroundColor: e.backgroundColor,
						borderColor: e.borderColor,
						borderWidth: e.borderWidth,
						radius: e.radius
					}, e.backgroundColor = Ut(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = Ut(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = Ut(i.hoverBorderWidth, i.borderWidth), e.radius = i.radius + i.hoverRadius
				},
				_resolveElementOptions: function (t, e) {
					var i, n, r, a = this.chart,
						o = a.data.datasets[this.index],
						s = t.custom || {},
						l = a.options.elements.point,
						h = o.data[e],
						u = {},
						d = {
							chart: a,
							dataIndex: e,
							dataset: o,
							datasetIndex: this.index
						},
						c = ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation"];
					for (i = 0, n = c.length; i < n; ++i) u[r = c[i]] = Gt([s[r], o[r], l[r]], d, e);
					return u.radius = Gt([s.radius, h ? h.r : void 0, o.radius, l.radius], d, e), u
				}
			}),
			qt = ht.options.resolve,
			Xt = ht.valueOrDefault;
		ot._set("doughnut", {
			animation: {
				animateRotate: !0,
				animateScale: !1
			},
			hover: {
				mode: "single"
			},
			legendCallback: function (t) {
				var e = [];
				e.push('<ul class="' + t.id + '-legend">');
				var i = t.data,
					n = i.datasets,
					r = i.labels;
				if (n.length)
					for (var a = 0; a < n[0].data.length; ++a) e.push('<li><span style="background-color:' + n[0].backgroundColor[a] + '"></span>'), r[a] && e.push(r[a]), e.push("</li>");
				return e.push("</ul>"), e.join("")
			},
			legend: {
				labels: {
					generateLabels: function (s) {
						var l = s.data;
						return l.labels.length && l.datasets.length ? l.labels.map(function (t, e) {
							var i = s.getDatasetMeta(0),
								n = l.datasets[0],
								r = i.data[e],
								a = r && r.custom || {},
								o = s.options.elements.arc;
							return {
								text: t,
								fillStyle: qt([a.backgroundColor, n.backgroundColor, o.backgroundColor], void 0, e),
								strokeStyle: qt([a.borderColor, n.borderColor, o.borderColor], void 0, e),
								lineWidth: qt([a.borderWidth, n.borderWidth, o.borderWidth], void 0, e),
								hidden: isNaN(n.data[e]) || i.data[e].hidden,
								index: e
							}
						}) : []
					}
				},
				onClick: function (t, e) {
					var i, n, r, a = e.index,
						o = this.chart;
					for (i = 0, n = (o.data.datasets || []).length; i < n; ++i)(r = o.getDatasetMeta(i)).data[a] && (r.data[a].hidden = !r.data[a].hidden);
					o.update()
				}
			},
			cutoutPercentage: 50,
			rotation: -.5 * Math.PI,
			circumference: 2 * Math.PI,
			tooltips: {
				callbacks: {
					title: function () {
						return ""
					},
					label: function (t, e) {
						var i = e.labels[t.index],
							n = ": " + e.datasets[t.datasetIndex].data[t.index];
						return ht.isArray(i) ? (i = i.slice())[0] += n : i += n, i
					}
				}
			}
		});
		var Zt = wt.extend({
			dataElementType: zt.Arc,
			linkScales: ht.noop,
			getRingIndex: function (t) {
				for (var e = 0, i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && ++e;
				return e
			},
			update: function (t) {
				var e, i, n = this,
					r = n.chart,
					a = r.chartArea,
					o = r.options,
					s = a.right - a.left,
					l = a.bottom - a.top,
					h = Math.min(s, l),
					u = {
						x: 0,
						y: 0
					},
					d = n.getMeta(),
					c = d.data,
					f = o.cutoutPercentage,
					p = o.circumference,
					g = n._getRingWeight(n.index);
				if (p < 2 * Math.PI) {
					var m = o.rotation % (2 * Math.PI),
						v = (m += 2 * Math.PI * (m >= Math.PI ? -1 : m < -Math.PI ? 1 : 0)) + p,
						y = Math.cos(m),
						x = Math.sin(m),
						b = Math.cos(v),
						_ = Math.sin(v),
						w = m <= 0 && 0 <= v || m <= 2 * Math.PI && 2 * Math.PI <= v,
						k = m <= .5 * Math.PI && .5 * Math.PI <= v || m <= 2.5 * Math.PI && 2.5 * Math.PI <= v,
						M = m <= -Math.PI && -Math.PI <= v || m <= Math.PI && Math.PI <= v,
						S = m <= .5 * -Math.PI && .5 * -Math.PI <= v || m <= 1.5 * Math.PI && 1.5 * Math.PI <= v,
						C = f / 100,
						D = M ? -1 : Math.min(y * (y < 0 ? 1 : C), b * (b < 0 ? 1 : C)),
						T = S ? -1 : Math.min(x * (x < 0 ? 1 : C), _ * (_ < 0 ? 1 : C)),
						P = w ? 1 : Math.max(y * (0 < y ? 1 : C), b * (0 < b ? 1 : C)),
						A = k ? 1 : Math.max(x * (0 < x ? 1 : C), _ * (0 < _ ? 1 : C)),
						F = .5 * (P - D),
						I = .5 * (A - T);
					h = Math.min(s / F, l / I), u = {
						x: -.5 * (P + D),
						y: -.5 * (A + T)
					}
				}
				for (e = 0, i = c.length; e < i; ++e) c[e]._options = n._resolveElementOptions(c[e], e);
				for (r.borderWidth = n.getMaxBorderWidth(), r.outerRadius = Math.max((h - r.borderWidth) / 2, 0), r.innerRadius = Math.max(f ? r.outerRadius / 100 * f : 0, 0), r.radiusLength = (r.outerRadius - r.innerRadius) / (n._getVisibleDatasetWeightTotal() || 1), r.offsetX = u.x * r.outerRadius, r.offsetY = u.y * r.outerRadius, d.total = n.calculateTotal(), n.outerRadius = r.outerRadius - r.radiusLength * n._getRingWeightOffset(n.index), n.innerRadius = Math.max(n.outerRadius - r.radiusLength * g, 0), e = 0, i = c.length; e < i; ++e) n.updateElement(c[e], e, t)
			},
			updateElement: function (t, e, i) {
				var n = this.chart,
					r = n.chartArea,
					a = n.options,
					o = a.animation,
					s = (r.left + r.right) / 2,
					l = (r.top + r.bottom) / 2,
					h = a.rotation,
					u = a.rotation,
					d = this.getDataset(),
					c = i && o.animateRotate ? 0 : t.hidden ? 0 : this.calculateCircumference(d.data[e]) * (a.circumference / (2 * Math.PI)),
					f = i && o.animateScale ? 0 : this.innerRadius,
					p = i && o.animateScale ? 0 : this.outerRadius,
					g = t._options || {};
				ht.extend(t, {
					_datasetIndex: this.index,
					_index: e,
					_model: {
						backgroundColor: g.backgroundColor,
						borderColor: g.borderColor,
						borderWidth: g.borderWidth,
						borderAlign: g.borderAlign,
						x: s + n.offsetX,
						y: l + n.offsetY,
						startAngle: h,
						endAngle: u,
						circumference: c,
						outerRadius: p,
						innerRadius: f,
						label: ht.valueAtIndexOrDefault(d.label, e, n.data.labels[e])
					}
				});
				var m = t._model;
				i && o.animateRotate || (m.startAngle = 0 === e ? a.rotation : this.getMeta().data[e - 1]._model.endAngle, m.endAngle = m.startAngle + m.circumference), t.pivot()
			},
			calculateTotal: function () {
				var i, n = this.getDataset(),
					t = this.getMeta(),
					r = 0;
				return ht.each(t.data, function (t, e) {
					i = n.data[e], isNaN(i) || t.hidden || (r += Math.abs(i))
				}), r
			},
			calculateCircumference: function (t) {
				var e = this.getMeta().total;
				return 0 < e && !isNaN(t) ? 2 * Math.PI * (Math.abs(t) / e) : 0
			},
			getMaxBorderWidth: function (t) {
				var e, i, n, r, a, o, s, l, h = 0,
					u = this.chart;
				if (!t)
					for (e = 0, i = u.data.datasets.length; e < i; ++e)
						if (u.isDatasetVisible(e)) {
							t = (n = u.getDatasetMeta(e)).data, e !== this.index && (a = n.controller);
							break
						} if (!t) return 0;
				for (e = 0, i = t.length; e < i; ++e) r = t[e], "inner" !== (o = a ? a._resolveElementOptions(r, e) : r._options).borderAlign && (h = (h = h < (s = o.borderWidth) ? s : h) < (l = o.hoverBorderWidth) ? l : h);
				return h
			},
			setHoverStyle: function (t) {
				var e = t._model,
					i = t._options,
					n = ht.getHoverColor;
				t.$previousStyle = {
					backgroundColor: e.backgroundColor,
					borderColor: e.borderColor,
					borderWidth: e.borderWidth
				}, e.backgroundColor = Xt(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = Xt(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = Xt(i.hoverBorderWidth, i.borderWidth)
			},
			_resolveElementOptions: function (t, e) {
				var i, n, r, a = this.chart,
					o = this.getDataset(),
					s = t.custom || {},
					l = a.options.elements.arc,
					h = {},
					u = {
						chart: a,
						dataIndex: e,
						dataset: o,
						datasetIndex: this.index
					},
					d = ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"];
				for (i = 0, n = d.length; i < n; ++i) h[r = d[i]] = qt([s[r], o[r], l[r]], u, e);
				return h
			},
			_getRingWeightOffset: function (t) {
				for (var e = 0, i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
				return e
			},
			_getRingWeight: function (t) {
				return Math.max(Xt(this.chart.data.datasets[t].weight, 1), 0)
			},
			_getVisibleDatasetWeightTotal: function () {
				return this._getRingWeightOffset(this.chart.data.datasets.length)
			}
		});
		ot._set("horizontalBar", {
			hover: {
				mode: "index",
				axis: "y"
			},
			scales: {
				xAxes: [{
					type: "linear",
					position: "bottom"
				}],
				yAxes: [{
					type: "category",
					position: "left",
					categoryPercentage: .8,
					barPercentage: .9,
					offset: !0,
					gridLines: {
						offsetGridLines: !0
					}
				}]
			},
			elements: {
				rectangle: {
					borderSkipped: "left"
				}
			},
			tooltips: {
				mode: "index",
				axis: "y"
			}
		});
		var Qt = jt.extend({
				_getValueScaleId: function () {
					return this.getMeta().xAxisID
				},
				_getIndexScaleId: function () {
					return this.getMeta().yAxisID
				}
			}),
			Kt = ht.valueOrDefault,
			Jt = ht.options.resolve,
			te = ht.canvas._isPointInArea;

		function ee(t, e) {
			return Kt(t.showLine, e.showLines)
		}
		ot._set("line", {
			showLines: !0,
			spanGaps: !1,
			hover: {
				mode: "label"
			},
			scales: {
				xAxes: [{
					type: "category",
					id: "x-axis-0"
				}],
				yAxes: [{
					type: "linear",
					id: "y-axis-0"
				}]
			}
		});
		var ie = wt.extend({
				datasetElementType: zt.Line,
				dataElementType: zt.Point,
				update: function (t) {
					var e, i, n = this.getMeta(),
						r = n.dataset,
						a = n.data || [],
						o = this.getScaleForId(n.yAxisID),
						s = this.getDataset(),
						l = ee(s, this.chart.options);
					for (l && (void 0 !== s.tension && void 0 === s.lineTension && (s.lineTension = s.tension), r._scale = o, r._datasetIndex = this.index, r._children = a, r._model = this._resolveLineOptions(r), r.pivot()), e = 0, i = a.length; e < i; ++e) this.updateElement(a[e], e, t);
					for (l && 0 !== r._model.tension && this.updateBezierControlPoints(), e = 0, i = a.length; e < i; ++e) a[e].pivot()
				},
				updateElement: function (t, e, i) {
					var n, r, a = this.getMeta(),
						o = t.custom || {},
						s = this.getDataset(),
						l = this.index,
						h = s.data[e],
						u = this.getScaleForId(a.yAxisID),
						d = this.getScaleForId(a.xAxisID),
						c = a.dataset._model,
						f = this._resolvePointOptions(t, e);
					n = d.getPixelForValue("object" == typeof h ? h : NaN, e, l), r = i ? u.getBasePixel() : this.calculatePointY(h, e, l), t._xScale = d, t._yScale = u, t._options = f, t._datasetIndex = l, t._index = e, t._model = {
						x: n,
						y: r,
						skip: o.skip || isNaN(n) || isNaN(r),
						radius: f.radius,
						pointStyle: f.pointStyle,
						rotation: f.rotation,
						backgroundColor: f.backgroundColor,
						borderColor: f.borderColor,
						borderWidth: f.borderWidth,
						tension: Kt(o.tension, c ? c.tension : 0),
						steppedLine: !!c && c.steppedLine,
						hitRadius: f.hitRadius
					}
				},
				_resolvePointOptions: function (t, e) {
					var i, n, r, a = this.chart,
						o = a.data.datasets[this.index],
						s = t.custom || {},
						l = a.options.elements.point,
						h = {},
						u = {
							chart: a,
							dataIndex: e,
							dataset: o,
							datasetIndex: this.index
						},
						d = {
							backgroundColor: "pointBackgroundColor",
							borderColor: "pointBorderColor",
							borderWidth: "pointBorderWidth",
							hitRadius: "pointHitRadius",
							hoverBackgroundColor: "pointHoverBackgroundColor",
							hoverBorderColor: "pointHoverBorderColor",
							hoverBorderWidth: "pointHoverBorderWidth",
							hoverRadius: "pointHoverRadius",
							pointStyle: "pointStyle",
							radius: "pointRadius",
							rotation: "pointRotation"
						},
						c = Object.keys(d);
					for (i = 0, n = c.length; i < n; ++i) h[r = c[i]] = Jt([s[r], o[d[r]], o[r], l[r]], u, e);
					return h
				},
				_resolveLineOptions: function (t) {
					var e, i, n, r = this.chart,
						a = r.data.datasets[this.index],
						o = t.custom || {},
						s = r.options,
						l = s.elements.line,
						h = {},
						u = ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill", "cubicInterpolationMode"];
					for (e = 0, i = u.length; e < i; ++e) h[n = u[e]] = Jt([o[n], a[n], l[n]]);
					return h.spanGaps = Kt(a.spanGaps, s.spanGaps), h.tension = Kt(a.lineTension, l.tension), h.steppedLine = Jt([o.steppedLine, a.steppedLine, l.stepped]), h
				},
				calculatePointY: function (t, e, i) {
					var n, r, a, o = this.chart,
						s = this.getMeta(),
						l = this.getScaleForId(s.yAxisID),
						h = 0,
						u = 0;
					if (l.options.stacked) {
						for (n = 0; n < i; n++)
							if (r = o.data.datasets[n], "line" === (a = o.getDatasetMeta(n)).type && a.yAxisID === l.id && o.isDatasetVisible(n)) {
								var d = Number(l.getRightValue(r.data[e]));
								d < 0 ? u += d || 0 : h += d || 0
							} var c = Number(l.getRightValue(t));
						return c < 0 ? l.getPixelForValue(u + c) : l.getPixelForValue(h + c)
					}
					return l.getPixelForValue(t)
				},
				updateBezierControlPoints: function () {
					var t, e, i, n, r = this.chart,
						a = this.getMeta(),
						o = a.dataset._model,
						s = r.chartArea,
						l = a.data || [];

					function h(t, e, i) {
						return Math.max(Math.min(t, i), e)
					}
					if (o.spanGaps && (l = l.filter(function (t) {
							return !t._model.skip
						})), "monotone" === o.cubicInterpolationMode) ht.splineCurveMonotone(l);
					else
						for (t = 0, e = l.length; t < e; ++t) i = l[t]._model, n = ht.splineCurve(ht.previousItem(l, t)._model, i, ht.nextItem(l, t)._model, o.tension), i.controlPointPreviousX = n.previous.x, i.controlPointPreviousY = n.previous.y, i.controlPointNextX = n.next.x, i.controlPointNextY = n.next.y;
					if (r.options.elements.line.capBezierPoints)
						for (t = 0, e = l.length; t < e; ++t) i = l[t]._model, te(i, s) && (0 < t && te(l[t - 1]._model, s) && (i.controlPointPreviousX = h(i.controlPointPreviousX, s.left, s.right), i.controlPointPreviousY = h(i.controlPointPreviousY, s.top, s.bottom)), t < l.length - 1 && te(l[t + 1]._model, s) && (i.controlPointNextX = h(i.controlPointNextX, s.left, s.right), i.controlPointNextY = h(i.controlPointNextY, s.top, s.bottom)))
				},
				draw: function () {
					var t, e = this.chart,
						i = this.getMeta(),
						n = i.data || [],
						r = e.chartArea,
						a = n.length,
						o = 0;
					for (ee(this.getDataset(), e.options) && (t = (i.dataset._model.borderWidth || 0) / 2, ht.canvas.clipArea(e.ctx, {
							left: r.left,
							right: r.right,
							top: r.top - t,
							bottom: r.bottom + t
						}), i.dataset.draw(), ht.canvas.unclipArea(e.ctx)); o < a; ++o) n[o].draw(r)
				},
				setHoverStyle: function (t) {
					var e = t._model,
						i = t._options,
						n = ht.getHoverColor;
					t.$previousStyle = {
						backgroundColor: e.backgroundColor,
						borderColor: e.borderColor,
						borderWidth: e.borderWidth,
						radius: e.radius
					}, e.backgroundColor = Kt(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = Kt(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = Kt(i.hoverBorderWidth, i.borderWidth), e.radius = Kt(i.hoverRadius, i.radius)
				}
			}),
			ne = ht.options.resolve;
		ot._set("polarArea", {
			scale: {
				type: "radialLinear",
				angleLines: {
					display: !1
				},
				gridLines: {
					circular: !0
				},
				pointLabels: {
					display: !1
				},
				ticks: {
					beginAtZero: !0
				}
			},
			animation: {
				animateRotate: !0,
				animateScale: !0
			},
			startAngle: -.5 * Math.PI,
			legendCallback: function (t) {
				var e = [];
				e.push('<ul class="' + t.id + '-legend">');
				var i = t.data,
					n = i.datasets,
					r = i.labels;
				if (n.length)
					for (var a = 0; a < n[0].data.length; ++a) e.push('<li><span style="background-color:' + n[0].backgroundColor[a] + '"></span>'), r[a] && e.push(r[a]), e.push("</li>");
				return e.push("</ul>"), e.join("")
			},
			legend: {
				labels: {
					generateLabels: function (o) {
						var s = o.data;
						return s.labels.length && s.datasets.length ? s.labels.map(function (t, e) {
							var i = o.getDatasetMeta(0),
								n = s.datasets[0],
								r = i.data[e].custom || {},
								a = o.options.elements.arc;
							return {
								text: t,
								fillStyle: ne([r.backgroundColor, n.backgroundColor, a.backgroundColor], void 0, e),
								strokeStyle: ne([r.borderColor, n.borderColor, a.borderColor], void 0, e),
								lineWidth: ne([r.borderWidth, n.borderWidth, a.borderWidth], void 0, e),
								hidden: isNaN(n.data[e]) || i.data[e].hidden,
								index: e
							}
						}) : []
					}
				},
				onClick: function (t, e) {
					var i, n, r, a = e.index,
						o = this.chart;
					for (i = 0, n = (o.data.datasets || []).length; i < n; ++i)(r = o.getDatasetMeta(i)).data[a].hidden = !r.data[a].hidden;
					o.update()
				}
			},
			tooltips: {
				callbacks: {
					title: function () {
						return ""
					},
					label: function (t, e) {
						return e.labels[t.index] + ": " + t.yLabel
					}
				}
			}
		});
		var re = wt.extend({
			dataElementType: zt.Arc,
			linkScales: ht.noop,
			update: function (t) {
				var e, i, n, r = this,
					a = r.getDataset(),
					o = r.getMeta(),
					s = r.chart.options.startAngle || 0,
					l = r._starts = [],
					h = r._angles = [],
					u = o.data;
				for (r._updateRadius(), o.count = r.countVisibleElements(), e = 0, i = a.data.length; e < i; e++) l[e] = s, n = r._computeAngle(e), s += h[e] = n;
				for (e = 0, i = u.length; e < i; ++e) u[e]._options = r._resolveElementOptions(u[e], e), r.updateElement(u[e], e, t)
			},
			_updateRadius: function () {
				var t = this.chart,
					e = t.chartArea,
					i = t.options,
					n = Math.min(e.right - e.left, e.bottom - e.top);
				t.outerRadius = Math.max(n / 2, 0), t.innerRadius = Math.max(i.cutoutPercentage ? t.outerRadius / 100 * i.cutoutPercentage : 1, 0), t.radiusLength = (t.outerRadius - t.innerRadius) / t.getVisibleDatasetCount(), this.outerRadius = t.outerRadius - t.radiusLength * this.index, this.innerRadius = this.outerRadius - t.radiusLength
			},
			updateElement: function (t, e, i) {
				var n = this.chart,
					r = this.getDataset(),
					a = n.options,
					o = a.animation,
					s = n.scale,
					l = n.data.labels,
					h = s.xCenter,
					u = s.yCenter,
					d = a.startAngle,
					c = t.hidden ? 0 : s.getDistanceFromCenterForValue(r.data[e]),
					f = this._starts[e],
					p = f + (t.hidden ? 0 : this._angles[e]),
					g = o.animateScale ? 0 : s.getDistanceFromCenterForValue(r.data[e]),
					m = t._options || {};
				ht.extend(t, {
					_datasetIndex: this.index,
					_index: e,
					_scale: s,
					_model: {
						backgroundColor: m.backgroundColor,
						borderColor: m.borderColor,
						borderWidth: m.borderWidth,
						borderAlign: m.borderAlign,
						x: h,
						y: u,
						innerRadius: 0,
						outerRadius: i ? g : c,
						startAngle: i && o.animateRotate ? d : f,
						endAngle: i && o.animateRotate ? d : p,
						label: ht.valueAtIndexOrDefault(l, e, l[e])
					}
				}), t.pivot()
			},
			countVisibleElements: function () {
				var i = this.getDataset(),
					t = this.getMeta(),
					n = 0;
				return ht.each(t.data, function (t, e) {
					isNaN(i.data[e]) || t.hidden || n++
				}), n
			},
			setHoverStyle: function (t) {
				var e = t._model,
					i = t._options,
					n = ht.getHoverColor,
					r = ht.valueOrDefault;
				t.$previousStyle = {
					backgroundColor: e.backgroundColor,
					borderColor: e.borderColor,
					borderWidth: e.borderWidth
				}, e.backgroundColor = r(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = r(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = r(i.hoverBorderWidth, i.borderWidth)
			},
			_resolveElementOptions: function (t, e) {
				var i, n, r, a = this.chart,
					o = this.getDataset(),
					s = t.custom || {},
					l = a.options.elements.arc,
					h = {},
					u = {
						chart: a,
						dataIndex: e,
						dataset: o,
						datasetIndex: this.index
					},
					d = ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"];
				for (i = 0, n = d.length; i < n; ++i) h[r = d[i]] = ne([s[r], o[r], l[r]], u, e);
				return h
			},
			_computeAngle: function (t) {
				var e = this.getMeta().count,
					i = this.getDataset(),
					n = this.getMeta();
				if (isNaN(i.data[t]) || n.data[t].hidden) return 0;
				var r = {
					chart: this.chart,
					dataIndex: t,
					dataset: i,
					datasetIndex: this.index
				};
				return ne([this.chart.options.elements.arc.angle, 2 * Math.PI / e], r, t)
			}
		});
		ot._set("pie", ht.clone(ot.doughnut)), ot._set("pie", {
			cutoutPercentage: 0
		});
		var ae = Zt,
			oe = ht.valueOrDefault,
			se = ht.options.resolve;
		ot._set("radar", {
			scale: {
				type: "radialLinear"
			},
			elements: {
				line: {
					tension: 0
				}
			}
		});
		var le = wt.extend({
			datasetElementType: zt.Line,
			dataElementType: zt.Point,
			linkScales: ht.noop,
			update: function (t) {
				var e, i, n = this.getMeta(),
					r = n.dataset,
					a = n.data || [],
					o = this.chart.scale,
					s = this.getDataset();
				for (void 0 !== s.tension && void 0 === s.lineTension && (s.lineTension = s.tension), r._scale = o, r._datasetIndex = this.index, r._children = a, r._loop = !0, r._model = this._resolveLineOptions(r), r.pivot(), e = 0, i = a.length; e < i; ++e) this.updateElement(a[e], e, t);
				for (this.updateBezierControlPoints(), e = 0, i = a.length; e < i; ++e) a[e].pivot()
			},
			updateElement: function (t, e, i) {
				var n = t.custom || {},
					r = this.getDataset(),
					a = this.chart.scale,
					o = a.getPointPositionForValue(e, r.data[e]),
					s = this._resolvePointOptions(t, e),
					l = this.getMeta().dataset._model,
					h = i ? a.xCenter : o.x,
					u = i ? a.yCenter : o.y;
				t._scale = a, t._options = s, t._datasetIndex = this.index, t._index = e, t._model = {
					x: h,
					y: u,
					skip: n.skip || isNaN(h) || isNaN(u),
					radius: s.radius,
					pointStyle: s.pointStyle,
					rotation: s.rotation,
					backgroundColor: s.backgroundColor,
					borderColor: s.borderColor,
					borderWidth: s.borderWidth,
					tension: oe(n.tension, l ? l.tension : 0),
					hitRadius: s.hitRadius
				}
			},
			_resolvePointOptions: function (t, e) {
				var i, n, r, a = this.chart,
					o = a.data.datasets[this.index],
					s = t.custom || {},
					l = a.options.elements.point,
					h = {},
					u = {
						chart: a,
						dataIndex: e,
						dataset: o,
						datasetIndex: this.index
					},
					d = {
						backgroundColor: "pointBackgroundColor",
						borderColor: "pointBorderColor",
						borderWidth: "pointBorderWidth",
						hitRadius: "pointHitRadius",
						hoverBackgroundColor: "pointHoverBackgroundColor",
						hoverBorderColor: "pointHoverBorderColor",
						hoverBorderWidth: "pointHoverBorderWidth",
						hoverRadius: "pointHoverRadius",
						pointStyle: "pointStyle",
						radius: "pointRadius",
						rotation: "pointRotation"
					},
					c = Object.keys(d);
				for (i = 0, n = c.length; i < n; ++i) h[r = c[i]] = se([s[r], o[d[r]], o[r], l[r]], u, e);
				return h
			},
			_resolveLineOptions: function (t) {
				var e, i, n, r = this.chart,
					a = r.data.datasets[this.index],
					o = t.custom || {},
					s = r.options.elements.line,
					l = {},
					h = ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill"];
				for (e = 0, i = h.length; e < i; ++e) l[n = h[e]] = se([o[n], a[n], s[n]]);
				return l.tension = oe(a.lineTension, s.tension), l
			},
			updateBezierControlPoints: function () {
				var t, e, i, n, r = this.getMeta(),
					a = this.chart.chartArea,
					o = r.data || [];

				function s(t, e, i) {
					return Math.max(Math.min(t, i), e)
				}
				for (t = 0, e = o.length; t < e; ++t) i = o[t]._model, n = ht.splineCurve(ht.previousItem(o, t, !0)._model, i, ht.nextItem(o, t, !0)._model, i.tension), i.controlPointPreviousX = s(n.previous.x, a.left, a.right), i.controlPointPreviousY = s(n.previous.y, a.top, a.bottom), i.controlPointNextX = s(n.next.x, a.left, a.right), i.controlPointNextY = s(n.next.y, a.top, a.bottom)
			},
			setHoverStyle: function (t) {
				var e = t._model,
					i = t._options,
					n = ht.getHoverColor;
				t.$previousStyle = {
					backgroundColor: e.backgroundColor,
					borderColor: e.borderColor,
					borderWidth: e.borderWidth,
					radius: e.radius
				}, e.backgroundColor = oe(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = oe(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = oe(i.hoverBorderWidth, i.borderWidth), e.radius = oe(i.hoverRadius, i.radius)
			}
		});
		ot._set("scatter", {
			hover: {
				mode: "single"
			},
			scales: {
				xAxes: [{
					id: "x-axis-1",
					type: "linear",
					position: "bottom"
				}],
				yAxes: [{
					id: "y-axis-1",
					type: "linear",
					position: "left"
				}]
			},
			showLines: !1,
			tooltips: {
				callbacks: {
					title: function () {
						return ""
					},
					label: function (t) {
						return "(" + t.xLabel + ", " + t.yLabel + ")"
					}
				}
			}
		});
		var he = {
			bar: jt,
			bubble: $t,
			doughnut: Zt,
			horizontalBar: Qt,
			line: ie,
			polarArea: re,
			pie: ae,
			radar: le,
			scatter: ie
		};

		function ue(t, e) {
			return t.native ? {
				x: t.x,
				y: t.y
			} : ht.getRelativePosition(t, e)
		}

		function de(t, e) {
			var i, n, r, a, o;
			for (n = 0, a = t.data.datasets.length; n < a; ++n)
				if (t.isDatasetVisible(n))
					for (r = 0, o = (i = t.getDatasetMeta(n)).data.length; r < o; ++r) {
						var s = i.data[r];
						s._view.skip || e(s)
					}
		}

		function ce(t, e) {
			var i = [];
			return de(t, function (t) {
				t.inRange(e.x, e.y) && i.push(t)
			}), i
		}

		function fe(t, n, r, a) {
			var o = Number.POSITIVE_INFINITY,
				s = [];
			return de(t, function (t) {
				if (!r || t.inRange(n.x, n.y)) {
					var e = t.getCenterPoint(),
						i = a(n, e);
					i < o ? (s = [t], o = i) : i === o && s.push(t)
				}
			}), s
		}

		function pe(t) {
			var r = -1 !== t.indexOf("x"),
				a = -1 !== t.indexOf("y");
			return function (t, e) {
				var i = r ? Math.abs(t.x - e.x) : 0,
					n = a ? Math.abs(t.y - e.y) : 0;
				return Math.sqrt(Math.pow(i, 2) + Math.pow(n, 2))
			}
		}

		function ge(n, t, e) {
			var i = ue(t, n);
			e.axis = e.axis || "x";
			var r = pe(e.axis),
				a = e.intersect ? ce(n, i) : fe(n, i, !1, r),
				o = [];
			return a.length ? (n.data.datasets.forEach(function (t, e) {
				if (n.isDatasetVisible(e)) {
					var i = n.getDatasetMeta(e).data[a[0]._index];
					i && !i._view.skip && o.push(i)
				}
			}), o) : []
		}
		var me = {
			modes: {
				single: function (t, e) {
					var i = ue(e, t),
						n = [];
					return de(t, function (t) {
						if (t.inRange(i.x, i.y)) return n.push(t), n
					}), n.slice(0, 1)
				},
				label: ge,
				index: ge,
				dataset: function (t, e, i) {
					var n = ue(e, t);
					i.axis = i.axis || "xy";
					var r = pe(i.axis),
						a = i.intersect ? ce(t, n) : fe(t, n, !1, r);
					return 0 < a.length && (a = t.getDatasetMeta(a[0]._datasetIndex).data), a
				},
				"x-axis": function (t, e) {
					return ge(t, e, {
						intersect: !1
					})
				},
				point: function (t, e) {
					return ce(t, ue(e, t))
				},
				nearest: function (t, e, i) {
					var n = ue(e, t);
					i.axis = i.axis || "xy";
					var r = pe(i.axis);
					return fe(t, n, i.intersect, r)
				},
				x: function (t, e, i) {
					var n = ue(e, t),
						r = [],
						a = !1;
					return de(t, function (t) {
						t.inXRange(n.x) && r.push(t), t.inRange(n.x, n.y) && (a = !0)
					}), i.intersect && !a && (r = []), r
				},
				y: function (t, e, i) {
					var n = ue(e, t),
						r = [],
						a = !1;
					return de(t, function (t) {
						t.inYRange(n.y) && r.push(t), t.inRange(n.x, n.y) && (a = !0)
					}), i.intersect && !a && (r = []), r
				}
			}
		};

		function ve(t, e) {
			return ht.where(t, function (t) {
				return t.position === e
			})
		}

		function ye(t, r) {
			t.forEach(function (t, e) {
				return t._tmpIndex_ = e, t
			}), t.sort(function (t, e) {
				var i = r ? e : t,
					n = r ? t : e;
				return i.weight === n.weight ? i._tmpIndex_ - n._tmpIndex_ : i.weight - n.weight
			}), t.forEach(function (t) {
				delete t._tmpIndex_
			})
		}

		function xe(t, e) {
			ht.each(t, function (t) {
				e[t.position] += t.isHorizontal() ? t.height : t.width
			})
		}
		ot._set("global", {
			layout: {
				padding: {
					top: 0,
					right: 0,
					bottom: 0,
					left: 0
				}
			}
		});
		var be = {
			defaults: {},
			addBox: function (t, e) {
				t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, t.boxes.push(e)
			},
			removeBox: function (t, e) {
				var i = t.boxes ? t.boxes.indexOf(e) : -1; - 1 !== i && t.boxes.splice(i, 1)
			},
			configure: function (t, e, i) {
				for (var n, r = ["fullWidth", "position", "weight"], a = r.length, o = 0; o < a; ++o) n = r[o], i.hasOwnProperty(n) && (e[n] = i[n])
			},
			update: function (e, i, t) {
				if (e) {
					var n = e.options.layout || {},
						r = ht.options.toPadding(n.padding),
						a = r.left,
						o = r.right,
						s = r.top,
						l = r.bottom,
						h = ve(e.boxes, "left"),
						u = ve(e.boxes, "right"),
						d = ve(e.boxes, "top"),
						c = ve(e.boxes, "bottom"),
						f = ve(e.boxes, "chartArea");
					ye(h, !0), ye(u, !1), ye(d, !0), ye(c, !1);
					var p, g, m, v, y, x, b = h.concat(u),
						_ = d.concat(c),
						w = b.concat(_),
						k = i - a - o,
						M = t - s - l,
						S = (i - k / 2) / b.length,
						C = k,
						D = M,
						T = {
							top: s,
							left: a,
							bottom: l,
							right: o
						},
						P = [];
					ht.each(w, function (t) {
						var e, i = t.isHorizontal();
						i ? (e = t.update(t.fullWidth ? k : C, M / 2), D -= e.height) : (e = t.update(S, D), C -= e.width), P.push({
							horizontal: i,
							width: e.width,
							box: t
						})
					}), g = w, x = y = v = m = 0, ht.each(g, function (t) {
						if (t.getPadding) {
							var e = t.getPadding();
							m = Math.max(m, e.top), v = Math.max(v, e.left), y = Math.max(y, e.bottom), x = Math.max(x, e.right)
						}
					}), p = {
						top: m,
						left: v,
						bottom: y,
						right: x
					}, ht.each(b, B), xe(b, T), ht.each(_, B), xe(_, T), ht.each(b, function (e) {
						var t = ht.findNextWhere(P, function (t) {
								return t.box === e
							}),
							i = {
								left: 0,
								right: 0,
								top: T.top,
								bottom: T.bottom
							};
						t && e.update(t.width, D, i)
					}), xe(w, T = {
						top: s,
						left: a,
						bottom: l,
						right: o
					});
					var A = Math.max(p.left - T.left, 0);
					T.left += A, T.right += Math.max(p.right - T.right, 0);
					var F = Math.max(p.top - T.top, 0);
					T.top += F, T.bottom += Math.max(p.bottom - T.bottom, 0);
					var I = t - T.top - T.bottom,
						L = i - T.left - T.right;
					L === C && I === D || (ht.each(b, function (t) {
						t.height = I
					}), ht.each(_, function (t) {
						t.fullWidth || (t.width = L)
					}), D = I, C = L);
					var O = a + A,
						R = s + F;
					ht.each(h.concat(d), W), O += C, R += D, ht.each(u, W), ht.each(c, W), e.chartArea = {
						left: T.left,
						top: T.top,
						right: T.left + C,
						bottom: T.top + D
					}, ht.each(f, function (t) {
						t.left = e.chartArea.left, t.top = e.chartArea.top, t.right = e.chartArea.right, t.bottom = e.chartArea.bottom, t.update(C, D)
					})
				}

				function B(e) {
					var t = ht.findNextWhere(P, function (t) {
						return t.box === e
					});
					if (t)
						if (t.horizontal) {
							var i = {
								left: Math.max(T.left, p.left),
								right: Math.max(T.right, p.right),
								top: 0,
								bottom: 0
							};
							e.update(e.fullWidth ? k : C, M / 2, i)
						} else e.update(t.width, D)
				}

				function W(t) {
					t.isHorizontal() ? (t.left = t.fullWidth ? a : T.left, t.right = t.fullWidth ? i - o : T.left + C, t.top = R, t.bottom = R + t.height, R = t.bottom) : (t.left = O, t.right = O + t.width, t.top = T.top, t.bottom = T.top + D, O = t.right)
				}
			}
		};
		"undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;

		function Ki() {
			throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs")
		}
		var _e, we = (_e = Object.freeze({
				default: "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n"
			})) && _e.default || _e,
			ke = "$chartjs",
			Me = "chartjs-",
			Se = Me + "size-monitor",
			Ce = Me + "render-monitor",
			De = Me + "render-animation",
			Te = ["animationstart", "webkitAnimationStart"],
			Pe = {
				touchstart: "mousedown",
				touchmove: "mousemove",
				touchend: "mouseup",
				pointerenter: "mouseenter",
				pointerdown: "mousedown",
				pointermove: "mousemove",
				pointerup: "mouseup",
				pointerleave: "mouseout",
				pointerout: "mouseout"
			};

		function Ae(t, e) {
			var i = ht.getStyle(t, e),
				n = i && i.match(/^(\d+)(\.\d+)?px$/);
			return n ? Number(n[1]) : void 0
		}
		var Fe = !! function () {
			var t = !1;
			try {
				var e = Object.defineProperty({}, "passive", {
					get: function () {
						t = !0
					}
				});
				window.addEventListener("e", null, e)
			} catch (t) {}
			return t
		}() && {
			passive: !0
		};

		function Ie(t, e, i) {
			t.addEventListener(e, i, Fe)
		}

		function Le(t, e, i) {
			t.removeEventListener(e, i, Fe)
		}

		function Oe(t, e, i, n, r) {
			return {
				type: t,
				chart: e,
				native: r || null,
				x: void 0 !== i ? i : null,
				y: void 0 !== n ? n : null
			}
		}

		function Re(t) {
			var e = document.createElement("div");
			return e.className = t || "", e
		}

		function Be(i, n, r) {
			var t, e, a, o, s, l, h, u, d = i[ke] || (i[ke] = {}),
				c = d.resizer = function (t) {
					var e = Re(Se),
						i = Re(Se + "-expand"),
						n = Re(Se + "-shrink");
					i.appendChild(Re()), n.appendChild(Re()), e.appendChild(i), e.appendChild(n), e._reset = function () {
						i.scrollLeft = 1e6, i.scrollTop = 1e6, n.scrollLeft = 1e6, n.scrollTop = 1e6
					};
					var r = function () {
						e._reset(), t()
					};
					return Ie(i, "scroll", r.bind(i, "expand")), Ie(n, "scroll", r.bind(n, "shrink")), e
				}((a = !(t = function () {
					if (d.resizer) {
						var t = r.options.maintainAspectRatio && i.parentNode,
							e = t ? t.clientWidth : 0;
						n(Oe("resize", r)), t && t.clientWidth < e && r.canvas && n(Oe("resize", r))
					}
				}), o = [], function () {
					o = Array.prototype.slice.call(arguments), e = e || this, a || (a = !0, ht.requestAnimFrame.call(window, function () {
						a = !1, t.apply(e, o)
					}))
				}));
			l = function () {
				if (d.resizer) {
					var t = i.parentNode;
					t && t !== c.parentNode && t.insertBefore(c, t.firstChild), c._reset()
				}
			}, h = (s = i)[ke] || (s[ke] = {}), u = h.renderProxy = function (t) {
				t.animationName === De && l()
			}, ht.each(Te, function (t) {
				Ie(s, t, u)
			}), h.reflow = !!s.offsetParent, s.classList.add(Ce)
		}

		function We(t) {
			var e, i, n, r = t[ke] || {},
				a = r.resizer;
			delete r.resizer, i = (e = t)[ke] || {}, (n = i.renderProxy) && (ht.each(Te, function (t) {
				Le(e, t, n)
			}), delete i.renderProxy), e.classList.remove(Ce), a && a.parentNode && a.parentNode.removeChild(a)
		}
		var ze = {
			disableCSSInjection: !1,
			_enabled: "undefined" != typeof window && "undefined" != typeof document,
			_ensureLoaded: function () {
				var t, e, i;
				this._loaded || (this._loaded = !0, this.disableCSSInjection || (e = we, i = (t = this)._style || document.createElement("style"), t._style || (e = "/* Chart.js */\n" + e, (t._style = i).setAttribute("type", "text/css"), document.getElementsByTagName("head")[0].appendChild(i)), i.appendChild(document.createTextNode(e))))
			},
			acquireContext: function (t, e) {
				"string" == typeof t ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas);
				var i = t && t.getContext && t.getContext("2d");
				return this._ensureLoaded(), i && i.canvas === t ? (function (t, e) {
					var i = t.style,
						n = t.getAttribute("height"),
						r = t.getAttribute("width");
					if (t[ke] = {
							initial: {
								height: n,
								width: r,
								style: {
									display: i.display,
									height: i.height,
									width: i.width
								}
							}
						}, i.display = i.display || "block", null === r || "" === r) {
						var a = Ae(t, "width");
						void 0 !== a && (t.width = a)
					}
					if (null === n || "" === n)
						if ("" === t.style.height) t.height = t.width / (e.options.aspectRatio || 2);
						else {
							var o = Ae(t, "height");
							void 0 !== a && (t.height = o)
						}
				}(t, e), i) : null
			},
			releaseContext: function (t) {
				var i = t.canvas;
				if (i[ke]) {
					var n = i[ke].initial;
					["height", "width"].forEach(function (t) {
						var e = n[t];
						ht.isNullOrUndef(e) ? i.removeAttribute(t) : i.setAttribute(t, e)
					}), ht.each(n.style || {}, function (t, e) {
						i.style[e] = t
					}), i.width = i.width, delete i[ke]
				}
			},
			addEventListener: function (a, t, o) {
				var e = a.canvas;
				if ("resize" !== t) {
					var i = o[ke] || (o[ke] = {});
					Ie(e, t, (i.proxies || (i.proxies = {}))[a.id + "_" + t] = function (t) {
						var e, i, n, r;
						o((i = a, n = Pe[(e = t).type] || e.type, r = ht.getRelativePosition(e, i), Oe(n, i, r.x, r.y, e)))
					})
				} else Be(e, o, a)
			},
			removeEventListener: function (t, e, i) {
				var n = t.canvas;
				if ("resize" !== e) {
					var r = ((i[ke] || {}).proxies || {})[t.id + "_" + e];
					r && Le(n, e, r)
				} else We(n)
			}
		};
		ht.addEvent = Ie, ht.removeEvent = Le;
		var Ne = ze._enabled ? ze : {
				acquireContext: function (t) {
					return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null
				}
			},
			Ye = ht.extend({
				initialize: function () {},
				acquireContext: function () {},
				releaseContext: function () {},
				addEventListener: function () {},
				removeEventListener: function () {}
			}, Ne);
		ot._set("global", {
			plugins: {}
		});
		var Ee = {
				_plugins: [],
				_cacheId: 0,
				register: function (t) {
					var e = this._plugins;
					[].concat(t).forEach(function (t) {
						-1 === e.indexOf(t) && e.push(t)
					}), this._cacheId++
				},
				unregister: function (t) {
					var i = this._plugins;
					[].concat(t).forEach(function (t) {
						var e = i.indexOf(t); - 1 !== e && i.splice(e, 1)
					}), this._cacheId++
				},
				clear: function () {
					this._plugins = [], this._cacheId++
				},
				count: function () {
					return this._plugins.length
				},
				getAll: function () {
					return this._plugins
				},
				notify: function (t, e, i) {
					var n, r, a, o, s, l = this.descriptors(t),
						h = l.length;
					for (n = 0; n < h; ++n)
						if ("function" == typeof (s = (a = (r = l[n]).plugin)[e]) && ((o = [t].concat(i || [])).push(r.options), !1 === s.apply(a, o))) return !1;
					return !0
				},
				descriptors: function (t) {
					var e = t.$plugins || (t.$plugins = {});
					if (e.id === this._cacheId) return e.descriptors;
					var n = [],
						r = [],
						i = t && t.config || {},
						a = i.options && i.options.plugins || {};
					return this._plugins.concat(i.plugins || []).forEach(function (t) {
						if (-1 === n.indexOf(t)) {
							var e = t.id,
								i = a[e];
							!1 !== i && (!0 === i && (i = ht.clone(ot.global.plugins[e])), n.push(t), r.push({
								plugin: t,
								options: i || {}
							}))
						}
					}), e.descriptors = r, e.id = this._cacheId, r
				},
				_invalidate: function (t) {
					delete t.$plugins
				}
			},
			He = {
				constructors: {},
				defaults: {},
				registerScaleType: function (t, e, i) {
					this.constructors[t] = e, this.defaults[t] = ht.clone(i)
				},
				getScaleConstructor: function (t) {
					return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0
				},
				getScaleDefaults: function (t) {
					return this.defaults.hasOwnProperty(t) ? ht.merge({}, [ot.scale, this.defaults[t]]) : {}
				},
				updateScaleDefaults: function (t, e) {
					this.defaults.hasOwnProperty(t) && (this.defaults[t] = ht.extend(this.defaults[t], e))
				},
				addScalesToLayout: function (e) {
					ht.each(e.scales, function (t) {
						t.fullWidth = t.options.fullWidth, t.position = t.options.position, t.weight = t.options.weight, be.addBox(e, t)
					})
				}
			},
			Ve = ht.valueOrDefault;
		ot._set("global", {
			tooltips: {
				enabled: !0,
				custom: null,
				mode: "nearest",
				position: "average",
				intersect: !0,
				backgroundColor: "rgba(0,0,0,0.8)",
				titleFontStyle: "bold",
				titleSpacing: 2,
				titleMarginBottom: 6,
				titleFontColor: "#fff",
				titleAlign: "left",
				bodySpacing: 2,
				bodyFontColor: "#fff",
				bodyAlign: "left",
				footerFontStyle: "bold",
				footerSpacing: 2,
				footerMarginTop: 6,
				footerFontColor: "#fff",
				footerAlign: "left",
				yPadding: 6,
				xPadding: 6,
				caretPadding: 2,
				caretSize: 5,
				cornerRadius: 6,
				multiKeyBackground: "#fff",
				displayColors: !0,
				borderColor: "rgba(0,0,0,0)",
				borderWidth: 0,
				callbacks: {
					beforeTitle: ht.noop,
					title: function (t, e) {
						var i = "",
							n = e.labels,
							r = n ? n.length : 0;
						if (0 < t.length) {
							var a = t[0];
							a.label ? i = a.label : a.xLabel ? i = a.xLabel : 0 < r && a.index < r && (i = n[a.index])
						}
						return i
					},
					afterTitle: ht.noop,
					beforeBody: ht.noop,
					beforeLabel: ht.noop,
					label: function (t, e) {
						var i = e.datasets[t.datasetIndex].label || "";
						return i && (i += ": "), ht.isNullOrUndef(t.value) ? i += t.yLabel : i += t.value, i
					},
					labelColor: function (t, e) {
						var i = e.getDatasetMeta(t.datasetIndex).data[t.index]._view;
						return {
							borderColor: i.borderColor,
							backgroundColor: i.backgroundColor
						}
					},
					labelTextColor: function () {
						return this._options.bodyFontColor
					},
					afterLabel: ht.noop,
					afterBody: ht.noop,
					beforeFooter: ht.noop,
					footer: ht.noop,
					afterFooter: ht.noop
				}
			}
		});
		var je = {
			average: function (t) {
				if (!t.length) return !1;
				var e, i, n = 0,
					r = 0,
					a = 0;
				for (e = 0, i = t.length; e < i; ++e) {
					var o = t[e];
					if (o && o.hasValue()) {
						var s = o.tooltipPosition();
						n += s.x, r += s.y, ++a
					}
				}
				return {
					x: n / a,
					y: r / a
				}
			},
			nearest: function (t, e) {
				var i, n, r, a = e.x,
					o = e.y,
					s = Number.POSITIVE_INFINITY;
				for (i = 0, n = t.length; i < n; ++i) {
					var l = t[i];
					if (l && l.hasValue()) {
						var h = l.getCenterPoint(),
							u = ht.distanceBetweenPoints(e, h);
						u < s && (s = u, r = l)
					}
				}
				if (r) {
					var d = r.tooltipPosition();
					a = d.x, o = d.y
				}
				return {
					x: a,
					y: o
				}
			}
		};

		function Ue(t, e) {
			return e && (ht.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
		}

		function Ge(t) {
			return ("string" == typeof t || t instanceof String) && -1 < t.indexOf("\n") ? t.split("\n") : t
		}

		function $e(t) {
			var e = ot.global;
			return {
				xPadding: t.xPadding,
				yPadding: t.yPadding,
				xAlign: t.xAlign,
				yAlign: t.yAlign,
				bodyFontColor: t.bodyFontColor,
				_bodyFontFamily: Ve(t.bodyFontFamily, e.defaultFontFamily),
				_bodyFontStyle: Ve(t.bodyFontStyle, e.defaultFontStyle),
				_bodyAlign: t.bodyAlign,
				bodyFontSize: Ve(t.bodyFontSize, e.defaultFontSize),
				bodySpacing: t.bodySpacing,
				titleFontColor: t.titleFontColor,
				_titleFontFamily: Ve(t.titleFontFamily, e.defaultFontFamily),
				_titleFontStyle: Ve(t.titleFontStyle, e.defaultFontStyle),
				titleFontSize: Ve(t.titleFontSize, e.defaultFontSize),
				_titleAlign: t.titleAlign,
				titleSpacing: t.titleSpacing,
				titleMarginBottom: t.titleMarginBottom,
				footerFontColor: t.footerFontColor,
				_footerFontFamily: Ve(t.footerFontFamily, e.defaultFontFamily),
				_footerFontStyle: Ve(t.footerFontStyle, e.defaultFontStyle),
				footerFontSize: Ve(t.footerFontSize, e.defaultFontSize),
				_footerAlign: t.footerAlign,
				footerSpacing: t.footerSpacing,
				footerMarginTop: t.footerMarginTop,
				caretSize: t.caretSize,
				cornerRadius: t.cornerRadius,
				backgroundColor: t.backgroundColor,
				opacity: 0,
				legendColorBackground: t.multiKeyBackground,
				displayColors: t.displayColors,
				borderColor: t.borderColor,
				borderWidth: t.borderWidth
			}
		}

		function qe(t, e) {
			return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - t.xPadding : t.x + t.xPadding
		}

		function Xe(t) {
			return Ue([], Ge(t))
		}
		var Ze = pt.extend({
				initialize: function () {
					this._model = $e(this._options), this._lastActive = []
				},
				getTitle: function () {
					var t = this._options.callbacks,
						e = t.beforeTitle.apply(this, arguments),
						i = t.title.apply(this, arguments),
						n = t.afterTitle.apply(this, arguments),
						r = [];
					return r = Ue(r = Ue(r = Ue(r, Ge(e)), Ge(i)), Ge(n))
				},
				getBeforeBody: function () {
					return Xe(this._options.callbacks.beforeBody.apply(this, arguments))
				},
				getBody: function (t, i) {
					var n = this,
						r = n._options.callbacks,
						a = [];
					return ht.each(t, function (t) {
						var e = {
							before: [],
							lines: [],
							after: []
						};
						Ue(e.before, Ge(r.beforeLabel.call(n, t, i))), Ue(e.lines, r.label.call(n, t, i)), Ue(e.after, Ge(r.afterLabel.call(n, t, i))), a.push(e)
					}), a
				},
				getAfterBody: function () {
					return Xe(this._options.callbacks.afterBody.apply(this, arguments))
				},
				getFooter: function () {
					var t = this._options.callbacks,
						e = t.beforeFooter.apply(this, arguments),
						i = t.footer.apply(this, arguments),
						n = t.afterFooter.apply(this, arguments),
						r = [];
					return r = Ue(r = Ue(r = Ue(r, Ge(e)), Ge(i)), Ge(n))
				},
				update: function (t) {
					var e, i, n, r, a, o, s, l, h, u, d, c, f, p, g, m, v, y, x, b, _, w, k, M = this,
						S = M._options,
						C = M._model,
						D = M._model = $e(S),
						T = M._active,
						P = M._data,
						A = {
							xAlign: C.xAlign,
							yAlign: C.yAlign
						},
						F = {
							x: C.x,
							y: C.y
						},
						I = {
							width: C.width,
							height: C.height
						},
						L = {
							x: C.caretX,
							y: C.caretY
						};
					if (T.length) {
						D.opacity = 1;
						var O = [],
							R = [];
						L = je[S.position].call(M, T, M._eventPosition);
						var B = [];
						for (e = 0, i = T.length; e < i; ++e) B.push((m = T[e], k = w = _ = y = v = void 0, v = m._xScale, y = m._yScale || m._scale, x = m._index, b = m._datasetIndex, _ = m._chart.getDatasetMeta(b).controller, w = _._getIndexScale(), k = _._getValueScale(), {
							xLabel: v ? v.getLabelForIndex(x, b) : "",
							yLabel: y ? y.getLabelForIndex(x, b) : "",
							label: w ? "" + w.getLabelForIndex(x, b) : "",
							value: k ? "" + k.getLabelForIndex(x, b) : "",
							index: x,
							datasetIndex: b,
							x: m._model.x,
							y: m._model.y
						}));
						S.filter && (B = B.filter(function (t) {
							return S.filter(t, P)
						})), S.itemSort && (B = B.sort(function (t, e) {
							return S.itemSort(t, e, P)
						})), ht.each(B, function (t) {
							O.push(S.callbacks.labelColor.call(M, t, M._chart)), R.push(S.callbacks.labelTextColor.call(M, t, M._chart))
						}), D.title = M.getTitle(B, P), D.beforeBody = M.getBeforeBody(B, P), D.body = M.getBody(B, P), D.afterBody = M.getAfterBody(B, P), D.footer = M.getFooter(B, P), D.x = L.x, D.y = L.y, D.caretPadding = S.caretPadding, D.labelColors = O, D.labelTextColors = R, D.dataPoints = B, A = function (t, e) {
							var i, n, r, a, o, s = t._model,
								l = t._chart,
								h = t._chart.chartArea,
								u = "center",
								d = "center";
							s.y < e.height ? d = "top" : s.y > l.height - e.height && (d = "bottom");
							var c = (h.left + h.right) / 2,
								f = (h.top + h.bottom) / 2;
							n = "center" === d ? (i = function (t) {
								return t <= c
							}, function (t) {
								return c < t
							}) : (i = function (t) {
								return t <= e.width / 2
							}, function (t) {
								return t >= l.width - e.width / 2
							}), r = function (t) {
								return t + e.width + s.caretSize + s.caretPadding > l.width
							}, a = function (t) {
								return t - e.width - s.caretSize - s.caretPadding < 0
							}, o = function (t) {
								return t <= f ? "top" : "bottom"
							}, i(s.x) ? (u = "left", r(s.x) && (u = "center", d = o(s.y))) : n(s.x) && (u = "right", a(s.x) && (u = "center", d = o(s.y)));
							var p = t._options;
							return {
								xAlign: p.xAlign ? p.xAlign : u,
								yAlign: p.yAlign ? p.yAlign : d
							}
						}(this, I = function (t, e) {
							var i = t._chart.ctx,
								n = 2 * e.yPadding,
								r = 0,
								a = e.body,
								o = a.reduce(function (t, e) {
									return t + e.before.length + e.lines.length + e.after.length
								}, 0);
							o += e.beforeBody.length + e.afterBody.length;
							var s = e.title.length,
								l = e.footer.length,
								h = e.titleFontSize,
								u = e.bodyFontSize,
								d = e.footerFontSize;
							n += s * h, n += s ? (s - 1) * e.titleSpacing : 0, n += s ? e.titleMarginBottom : 0, n += o * u, n += o ? (o - 1) * e.bodySpacing : 0, n += l ? e.footerMarginTop : 0, n += l * d, n += l ? (l - 1) * e.footerSpacing : 0;
							var c = 0,
								f = function (t) {
									r = Math.max(r, i.measureText(t).width + c)
								};
							return i.font = ht.fontString(h, e._titleFontStyle, e._titleFontFamily), ht.each(e.title, f), i.font = ht.fontString(u, e._bodyFontStyle, e._bodyFontFamily), ht.each(e.beforeBody.concat(e.afterBody), f), c = e.displayColors ? u + 2 : 0, ht.each(a, function (t) {
								ht.each(t.before, f), ht.each(t.lines, f), ht.each(t.after, f)
							}), c = 0, i.font = ht.fontString(d, e._footerFontStyle, e._footerFontFamily), ht.each(e.footer, f), {
								width: r += 2 * e.xPadding,
								height: n
							}
						}(this, D)), n = D, r = I, a = A, o = M._chart, s = n.x, l = n.y, h = n.caretSize, u = n.caretPadding, d = n.cornerRadius, c = a.xAlign, f = a.yAlign, p = h + u, g = d + u, "right" === c ? s -= r.width : "center" === c && ((s -= r.width / 2) + r.width > o.width && (s = o.width - r.width), s < 0 && (s = 0)), "top" === f ? l += p : l -= "bottom" === f ? r.height + p : r.height / 2, "center" === f ? "left" === c ? s += p : "right" === c && (s -= p) : "left" === c ? s -= g : "right" === c && (s += g), F = {
							x: s,
							y: l
						}
					} else D.opacity = 0;
					return D.xAlign = A.xAlign, D.yAlign = A.yAlign, D.x = F.x, D.y = F.y, D.width = I.width, D.height = I.height, D.caretX = L.x, D.caretY = L.y, M._model = D, t && S.custom && S.custom.call(M, D), M
				},
				drawCaret: function (t, e) {
					var i = this._chart.ctx,
						n = this._view,
						r = this.getCaretPosition(t, e, n);
					i.lineTo(r.x1, r.y1), i.lineTo(r.x2, r.y2), i.lineTo(r.x3, r.y3)
				},
				getCaretPosition: function (t, e, i) {
					var n, r, a, o, s, l, h = i.caretSize,
						u = i.cornerRadius,
						d = i.xAlign,
						c = i.yAlign,
						f = t.x,
						p = t.y,
						g = e.width,
						m = e.height;
					if ("center" === c) s = p + m / 2, l = "left" === d ? (r = (n = f) - h, a = n, o = s + h, s - h) : (r = (n = f + g) + h, a = n, o = s - h, s + h);
					else if (a = (n = "left" === d ? (r = f + u + h) - h : "right" === d ? (r = f + g - u - h) - h : (r = i.caretX) - h, r + h), "top" === c) s = (o = p) - h, l = o;
					else {
						s = (o = p + m) + h, l = o;
						var v = a;
						a = n, n = v
					}
					return {
						x1: n,
						x2: r,
						x3: a,
						y1: o,
						y2: s,
						y3: l
					}
				},
				drawTitle: function (t, e, i) {
					var n = e.title;
					if (n.length) {
						t.x = qe(e, e._titleAlign), i.textAlign = e._titleAlign, i.textBaseline = "top";
						var r, a, o = e.titleFontSize,
							s = e.titleSpacing;
						for (i.fillStyle = e.titleFontColor, i.font = ht.fontString(o, e._titleFontStyle, e._titleFontFamily), r = 0, a = n.length; r < a; ++r) i.fillText(n[r], t.x, t.y), t.y += o + s, r + 1 === n.length && (t.y += e.titleMarginBottom - s)
					}
				},
				drawBody: function (i, n, r) {
					var a, o = n.bodyFontSize,
						e = n.bodySpacing,
						t = n._bodyAlign,
						s = n.body,
						l = n.displayColors,
						h = n.labelColors,
						u = 0,
						d = l ? qe(n, "left") : 0;
					r.textAlign = t, r.textBaseline = "top", r.font = ht.fontString(o, n._bodyFontStyle, n._bodyFontFamily), i.x = qe(n, t);
					var c = function (t) {
						r.fillText(t, i.x + u, i.y), i.y += o + e
					};
					r.fillStyle = n.bodyFontColor, ht.each(n.beforeBody, c), u = l && "right" !== t ? "center" === t ? o / 2 + 1 : o + 2 : 0, ht.each(s, function (t, e) {
						a = n.labelTextColors[e], r.fillStyle = a, ht.each(t.before, c), ht.each(t.lines, function (t) {
							l && (r.fillStyle = n.legendColorBackground, r.fillRect(d, i.y, o, o), r.lineWidth = 1, r.strokeStyle = h[e].borderColor, r.strokeRect(d, i.y, o, o), r.fillStyle = h[e].backgroundColor, r.fillRect(d + 1, i.y + 1, o - 2, o - 2), r.fillStyle = a), c(t)
						}), ht.each(t.after, c)
					}), u = 0, ht.each(n.afterBody, c), i.y -= e
				},
				drawFooter: function (e, i, n) {
					var t = i.footer;
					t.length && (e.x = qe(i, i._footerAlign), e.y += i.footerMarginTop, n.textAlign = i._footerAlign, n.textBaseline = "top", n.fillStyle = i.footerFontColor, n.font = ht.fontString(i.footerFontSize, i._footerFontStyle, i._footerFontFamily), ht.each(t, function (t) {
						n.fillText(t, e.x, e.y), e.y += i.footerFontSize + i.footerSpacing
					}))
				},
				drawBackground: function (t, e, i, n) {
					i.fillStyle = e.backgroundColor, i.strokeStyle = e.borderColor, i.lineWidth = e.borderWidth;
					var r = e.xAlign,
						a = e.yAlign,
						o = t.x,
						s = t.y,
						l = n.width,
						h = n.height,
						u = e.cornerRadius;
					i.beginPath(), i.moveTo(o + u, s), "top" === a && this.drawCaret(t, n), i.lineTo(o + l - u, s), i.quadraticCurveTo(o + l, s, o + l, s + u), "center" === a && "right" === r && this.drawCaret(t, n), i.lineTo(o + l, s + h - u), i.quadraticCurveTo(o + l, s + h, o + l - u, s + h), "bottom" === a && this.drawCaret(t, n), i.lineTo(o + u, s + h), i.quadraticCurveTo(o, s + h, o, s + h - u), "center" === a && "left" === r && this.drawCaret(t, n), i.lineTo(o, s + u), i.quadraticCurveTo(o, s, o + u, s), i.closePath(), i.fill(), 0 < e.borderWidth && i.stroke()
				},
				draw: function () {
					var t = this._chart.ctx,
						e = this._view;
					if (0 !== e.opacity) {
						var i = {
								width: e.width,
								height: e.height
							},
							n = {
								x: e.x,
								y: e.y
							},
							r = Math.abs(e.opacity < .001) ? 0 : e.opacity,
							a = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length;
						this._options.enabled && a && (t.save(), t.globalAlpha = r, this.drawBackground(n, e, t, i), n.y += e.yPadding, this.drawTitle(n, e, t), this.drawBody(n, e, t), this.drawFooter(n, e, t), t.restore())
					}
				},
				handleEvent: function (t) {
					var e, i = this,
						n = i._options;
					return i._lastActive = i._lastActive || [], "mouseout" === t.type ? i._active = [] : i._active = i._chart.getElementsAtEventForMode(t, n.mode, n), (e = !ht.arrayEquals(i._active, i._lastActive)) && (i._lastActive = i._active, (n.enabled || n.custom) && (i._eventPosition = {
						x: t.x,
						y: t.y
					}, i.update(!0), i.pivot())), e
				}
			}),
			Qe = je,
			Ke = Ze;
		Ke.positioners = Qe;
		var Je = ht.valueOrDefault;

		function ti() {
			return ht.merge({}, [].slice.call(arguments), {
				merger: function (t, e, i, n) {
					if ("xAxes" === t || "yAxes" === t) {
						var r, a, o, s = i[t].length;
						for (e[t] || (e[t] = []), r = 0; r < s; ++r) o = i[t][r], a = Je(o.type, "xAxes" === t ? "category" : "linear"), r >= e[t].length && e[t].push({}), !e[t][r].type || o.type && o.type !== e[t][r].type ? ht.merge(e[t][r], [He.getScaleDefaults(a), o]) : ht.merge(e[t][r], o)
					} else ht._merger(t, e, i, n)
				}
			})
		}

		function ei() {
			return ht.merge({}, [].slice.call(arguments), {
				merger: function (t, e, i, n) {
					var r = e[t] || {},
						a = i[t];
					"scales" === t ? e[t] = ti(r, a) : "scale" === t ? e[t] = ht.merge(r, [He.getScaleDefaults(a.type), a]) : ht._merger(t, e, i, n)
				}
			})
		}

		function ii(t) {
			return "top" === t || "bottom" === t
		}
		ot._set("global", {
			elements: {},
			events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
			hover: {
				onHover: null,
				mode: "nearest",
				intersect: !0,
				animationDuration: 400
			},
			onClick: null,
			maintainAspectRatio: !0,
			responsive: !0,
			responsiveAnimationDuration: 0
		});
		var ni = function (t, e) {
			return this.construct(t, e), this
		};
		ht.extend(ni.prototype, {
			construct: function (t, e) {
				var i, n, r = this;
				(n = (i = (i = e) || {}).data = i.data || {}).datasets = n.datasets || [], n.labels = n.labels || [], i.options = ei(ot.global, ot[i.type], i.options || {}), e = i;
				var a = Ye.acquireContext(t, e),
					o = a && a.canvas,
					s = o && o.height,
					l = o && o.width;
				r.id = ht.uid(), r.ctx = a, r.canvas = o, r.config = e, r.width = l, r.height = s, r.aspectRatio = s ? l / s : null, r.options = e.options, r._bufferedRender = !1, (r.chart = r).controller = r, ni.instances[r.id] = r, Object.defineProperty(r, "data", {
					get: function () {
						return r.config.data
					},
					set: function (t) {
						r.config.data = t
					}
				}), a && o ? (r.initialize(), r.update()) : console.error("Failed to create chart: can't acquire context from the given item")
			},
			initialize: function () {
				var t = this;
				return Ee.notify(t, "beforeInit"), ht.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.ensureScalesHaveIDs(), t.buildOrUpdateScales(), t.initToolTip(), Ee.notify(t, "afterInit"), t
			},
			clear: function () {
				return ht.canvas.clear(this), this
			},
			stop: function () {
				return vt.cancelAnimation(this), this
			},
			resize: function (t) {
				var e = this,
					i = e.options,
					n = e.canvas,
					r = i.maintainAspectRatio && e.aspectRatio || null,
					a = Math.max(0, Math.floor(ht.getMaximumWidth(n))),
					o = Math.max(0, Math.floor(r ? a / r : ht.getMaximumHeight(n)));
				if ((e.width !== a || e.height !== o) && (n.width = e.width = a, n.height = e.height = o, n.style.width = a + "px", n.style.height = o + "px", ht.retinaScale(e, i.devicePixelRatio), !t)) {
					var s = {
						width: a,
						height: o
					};
					Ee.notify(e, "resize", [s]), i.onResize && i.onResize(e, s), e.stop(), e.update({
						duration: i.responsiveAnimationDuration
					})
				}
			},
			ensureScalesHaveIDs: function () {
				var t = this.options,
					e = t.scales || {},
					i = t.scale;
				ht.each(e.xAxes, function (t, e) {
					t.id = t.id || "x-axis-" + e
				}), ht.each(e.yAxes, function (t, e) {
					t.id = t.id || "y-axis-" + e
				}), i && (i.id = i.id || "scale")
			},
			buildOrUpdateScales: function () {
				var o = this,
					t = o.options,
					s = o.scales || {},
					e = [],
					l = Object.keys(s).reduce(function (t, e) {
						return t[e] = !1, t
					}, {});
				t.scales && (e = e.concat((t.scales.xAxes || []).map(function (t) {
					return {
						options: t,
						dtype: "category",
						dposition: "bottom"
					}
				}), (t.scales.yAxes || []).map(function (t) {
					return {
						options: t,
						dtype: "linear",
						dposition: "left"
					}
				}))), t.scale && e.push({
					options: t.scale,
					dtype: "radialLinear",
					isDefault: !0,
					dposition: "chartArea"
				}), ht.each(e, function (t) {
					var e = t.options,
						i = e.id,
						n = Je(e.type, t.dtype);
					ii(e.position) !== ii(t.dposition) && (e.position = t.dposition), l[i] = !0;
					var r = null;
					if (i in s && s[i].type === n)(r = s[i]).options = e, r.ctx = o.ctx, r.chart = o;
					else {
						var a = He.getScaleConstructor(n);
						if (!a) return;
						r = new a({
							id: i,
							type: n,
							options: e,
							ctx: o.ctx,
							chart: o
						}), s[r.id] = r
					}
					r.mergeTicksOptions(), t.isDefault && (o.scale = r)
				}), ht.each(l, function (t, e) {
					t || delete s[e]
				}), o.scales = s, He.addScalesToLayout(this)
			},
			buildOrUpdateControllers: function () {
				var a = this,
					o = [];
				return ht.each(a.data.datasets, function (t, e) {
					var i = a.getDatasetMeta(e),
						n = t.type || a.config.type;
					if (i.type && i.type !== n && (a.destroyDatasetMeta(e), i = a.getDatasetMeta(e)), i.type = n, i.controller) i.controller.updateIndex(e), i.controller.linkScales();
					else {
						var r = he[i.type];
						if (void 0 === r) throw new Error('"' + i.type + '" is not a chart type.');
						i.controller = new r(a, e), o.push(i.controller)
					}
				}, a), o
			},
			resetElements: function () {
				var i = this;
				ht.each(i.data.datasets, function (t, e) {
					i.getDatasetMeta(e).controller.reset()
				}, i)
			},
			reset: function () {
				this.resetElements(), this.tooltip.initialize()
			},
			update: function (t) {
				var e, i, n = this;
				if (t && "object" == typeof t || (t = {
						duration: t,
						lazy: arguments[1]
					}), i = (e = n).options, ht.each(e.scales, function (t) {
						be.removeBox(e, t)
					}), i = ei(ot.global, ot[e.config.type], i), e.options = e.config.options = i, e.ensureScalesHaveIDs(), e.buildOrUpdateScales(), e.tooltip._options = i.tooltips, e.tooltip.initialize(), Ee._invalidate(n), !1 !== Ee.notify(n, "beforeUpdate")) {
					n.tooltip._data = n.data;
					var r = n.buildOrUpdateControllers();
					ht.each(n.data.datasets, function (t, e) {
						n.getDatasetMeta(e).controller.buildOrUpdateElements()
					}, n), n.updateLayout(), n.options.animation && n.options.animation.duration && ht.each(r, function (t) {
						t.reset()
					}), n.updateDatasets(), n.tooltip.initialize(), n.lastActive = [], Ee.notify(n, "afterUpdate"), n._bufferedRender ? n._bufferedRequest = {
						duration: t.duration,
						easing: t.easing,
						lazy: t.lazy
					} : n.render(t)
				}
			},
			updateLayout: function () {
				!1 !== Ee.notify(this, "beforeLayout") && (be.update(this, this.width, this.height), Ee.notify(this, "afterScaleUpdate"), Ee.notify(this, "afterLayout"))
			},
			updateDatasets: function () {
				if (!1 !== Ee.notify(this, "beforeDatasetsUpdate")) {
					for (var t = 0, e = this.data.datasets.length; t < e; ++t) this.updateDataset(t);
					Ee.notify(this, "afterDatasetsUpdate")
				}
			},
			updateDataset: function (t) {
				var e = this.getDatasetMeta(t),
					i = {
						meta: e,
						index: t
					};
				!1 !== Ee.notify(this, "beforeDatasetUpdate", [i]) && (e.controller.update(), Ee.notify(this, "afterDatasetUpdate", [i]))
			},
			render: function (t) {
				var e = this;
				t && "object" == typeof t || (t = {
					duration: t,
					lazy: arguments[1]
				});
				var i = e.options.animation,
					n = Je(t.duration, i && i.duration),
					r = t.lazy;
				if (!1 !== Ee.notify(e, "beforeRender")) {
					var a = function (t) {
						Ee.notify(e, "afterRender"), ht.callback(i && i.onComplete, [t], e)
					};
					if (i && n) {
						var o = new mt({
							numSteps: n / 16.66,
							easing: t.easing || i.easing,
							render: function (t, e) {
								var i = ht.easing.effects[e.easing],
									n = e.currentStep,
									r = n / e.numSteps;
								t.draw(i(r), r, n)
							},
							onAnimationProgress: i.onProgress,
							onAnimationComplete: a
						});
						vt.addAnimation(e, o, n, r)
					} else e.draw(), a(new mt({
						numSteps: 0,
						chart: e
					}));
					return e
				}
			},
			draw: function (t) {
				var e = this;
				e.clear(), ht.isNullOrUndef(t) && (t = 1), e.transition(t), e.width <= 0 || e.height <= 0 || !1 !== Ee.notify(e, "beforeDraw", [t]) && (ht.each(e.boxes, function (t) {
					t.draw(e.chartArea)
				}, e), e.drawDatasets(t), e._drawTooltip(t), Ee.notify(e, "afterDraw", [t]))
			},
			transition: function (t) {
				for (var e = 0, i = (this.data.datasets || []).length; e < i; ++e) this.isDatasetVisible(e) && this.getDatasetMeta(e).controller.transition(t);
				this.tooltip.transition(t)
			},
			drawDatasets: function (t) {
				if (!1 !== Ee.notify(this, "beforeDatasetsDraw", [t])) {
					for (var e = (this.data.datasets || []).length - 1; 0 <= e; --e) this.isDatasetVisible(e) && this.drawDataset(e, t);
					Ee.notify(this, "afterDatasetsDraw", [t])
				}
			},
			drawDataset: function (t, e) {
				var i = this.getDatasetMeta(t),
					n = {
						meta: i,
						index: t,
						easingValue: e
					};
				!1 !== Ee.notify(this, "beforeDatasetDraw", [n]) && (i.controller.draw(e), Ee.notify(this, "afterDatasetDraw", [n]))
			},
			_drawTooltip: function (t) {
				var e = this.tooltip,
					i = {
						tooltip: e,
						easingValue: t
					};
				!1 !== Ee.notify(this, "beforeTooltipDraw", [i]) && (e.draw(), Ee.notify(this, "afterTooltipDraw", [i]))
			},
			getElementAtEvent: function (t) {
				return me.modes.single(this, t)
			},
			getElementsAtEvent: function (t) {
				return me.modes.label(this, t, {
					intersect: !0
				})
			},
			getElementsAtXAxis: function (t) {
				return me.modes["x-axis"](this, t, {
					intersect: !0
				})
			},
			getElementsAtEventForMode: function (t, e, i) {
				var n = me.modes[e];
				return "function" == typeof n ? n(this, t, i) : []
			},
			getDatasetAtEvent: function (t) {
				return me.modes.dataset(this, t, {
					intersect: !0
				})
			},
			getDatasetMeta: function (t) {
				var e = this.data.datasets[t];
				e._meta || (e._meta = {});
				var i = e._meta[this.id];
				return i || (i = e._meta[this.id] = {
					type: null,
					data: [],
					dataset: null,
					controller: null,
					hidden: null,
					xAxisID: null,
					yAxisID: null
				}), i
			},
			getVisibleDatasetCount: function () {
				for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e) this.isDatasetVisible(e) && t++;
				return t
			},
			isDatasetVisible: function (t) {
				var e = this.getDatasetMeta(t);
				return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden
			},
			generateLegend: function () {
				return this.options.legendCallback(this)
			},
			destroyDatasetMeta: function (t) {
				var e = this.id,
					i = this.data.datasets[t],
					n = i._meta && i._meta[e];
				n && (n.controller.destroy(), delete i._meta[e])
			},
			destroy: function () {
				var t, e, i = this,
					n = i.canvas;
				for (i.stop(), t = 0, e = i.data.datasets.length; t < e; ++t) i.destroyDatasetMeta(t);
				n && (i.unbindEvents(), ht.canvas.clear(i), Ye.releaseContext(i.ctx), i.canvas = null, i.ctx = null), Ee.notify(i, "destroy"), delete ni.instances[i.id]
			},
			toBase64Image: function () {
				return this.canvas.toDataURL.apply(this.canvas, arguments)
			},
			initToolTip: function () {
				this.tooltip = new Ke({
					_chart: this,
					_chartInstance: this,
					_data: this.data,
					_options: this.options.tooltips
				}, this)
			},
			bindEvents: function () {
				var e = this,
					i = e._listeners = {},
					n = function () {
						e.eventHandler.apply(e, arguments)
					};
				ht.each(e.options.events, function (t) {
					Ye.addEventListener(e, t, n), i[t] = n
				}), e.options.responsive && (n = function () {
					e.resize()
				}, Ye.addEventListener(e, "resize", n), i.resize = n)
			},
			unbindEvents: function () {
				var i = this,
					t = i._listeners;
				t && (delete i._listeners, ht.each(t, function (t, e) {
					Ye.removeEventListener(i, e, t)
				}))
			},
			updateHoverStyle: function (t, e, i) {
				var n, r, a, o = i ? "setHoverStyle" : "removeHoverStyle";
				for (r = 0, a = t.length; r < a; ++r)(n = t[r]) && this.getDatasetMeta(n._datasetIndex).controller[o](n)
			},
			eventHandler: function (t) {
				var e = this,
					i = e.tooltip;
				if (!1 !== Ee.notify(e, "beforeEvent", [t])) {
					e._bufferedRender = !0, e._bufferedRequest = null;
					var n = e.handleEvent(t);
					i && (n = i._start ? i.handleEvent(t) : n | i.handleEvent(t)), Ee.notify(e, "afterEvent", [t]);
					var r = e._bufferedRequest;
					return r ? e.render(r) : n && !e.animating && (e.stop(), e.render({
						duration: e.options.hover.animationDuration,
						lazy: !0
					})), e._bufferedRender = !1, e._bufferedRequest = null, e
				}
			},
			handleEvent: function (t) {
				var e, i = this,
					n = i.options || {},
					r = n.hover;
				return i.lastActive = i.lastActive || [], "mouseout" === t.type ? i.active = [] : i.active = i.getElementsAtEventForMode(t, r.mode, r), ht.callback(n.onHover || n.hover.onHover, [t.native, i.active], i), "mouseup" !== t.type && "click" !== t.type || n.onClick && n.onClick.call(i, t.native, i.active), i.lastActive.length && i.updateHoverStyle(i.lastActive, r.mode, !1), i.active.length && r.mode && i.updateHoverStyle(i.active, r.mode, !0), e = !ht.arrayEquals(i.active, i.lastActive), i.lastActive = i.active, e
			}
		}), ni.instances = {};
		var ri = ni;
		(ni.Controller = ni).types = {}, ht.configMerge = ei, ht.scaleMerge = ti;

		function ai() {
			throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.")
		}

		function oi(t) {
			this.options = t || {}
		}
		ht.extend(oi.prototype, {
			formats: ai,
			parse: ai,
			format: ai,
			add: ai,
			diff: ai,
			startOf: ai,
			endOf: ai,
			_create: function (t) {
				return t
			}
		}), oi.override = function (t) {
			ht.extend(oi.prototype, t)
		};
		var si = {
				_date: oi
			},
			li = {
				formatters: {
					values: function (t) {
						return ht.isArray(t) ? t : "" + t
					},
					linear: function (t, e, i) {
						var n = 3 < i.length ? i[2] - i[1] : i[1] - i[0];
						1 < Math.abs(n) && t !== Math.floor(t) && (n = t - Math.floor(t));
						var r = ht.log10(Math.abs(n)),
							a = "";
						if (0 !== t)
							if (Math.max(Math.abs(i[0]), Math.abs(i[i.length - 1])) < 1e-4) {
								var o = ht.log10(Math.abs(t));
								a = t.toExponential(Math.floor(o) - Math.floor(r))
							} else {
								var s = -1 * Math.floor(r);
								s = Math.max(Math.min(s, 20), 0), a = t.toFixed(s)
							}
						else a = "0";
						return a
					},
					logarithmic: function (t, e, i) {
						var n = t / Math.pow(10, Math.floor(ht.log10(t)));
						return 0 === t ? "0" : 1 === n || 2 === n || 5 === n || 0 === e || e === i.length - 1 ? t.toExponential() : ""
					}
				}
			},
			hi = ht.valueOrDefault,
			ui = ht.valueAtIndexOrDefault;

		function di(t) {
			var e, i, n = [];
			for (e = 0, i = t.length; e < i; ++e) n.push(t[e].label);
			return n
		}

		function ci(t, e, i) {
			return ht.isArray(e) ? ht.longestText(t, i, e) : t.measureText(e).width
		}
		ot._set("scale", {
			display: !0,
			position: "left",
			offset: !1,
			gridLines: {
				display: !0,
				color: "rgba(0, 0, 0, 0.1)",
				lineWidth: 1,
				drawBorder: !0,
				drawOnChartArea: !0,
				drawTicks: !0,
				tickMarkLength: 10,
				zeroLineWidth: 1,
				zeroLineColor: "rgba(0,0,0,0.25)",
				zeroLineBorderDash: [],
				zeroLineBorderDashOffset: 0,
				offsetGridLines: !1,
				borderDash: [],
				borderDashOffset: 0
			},
			scaleLabel: {
				display: !1,
				labelString: "",
				padding: {
					top: 4,
					bottom: 4
				}
			},
			ticks: {
				beginAtZero: !1,
				minRotation: 0,
				maxRotation: 50,
				mirror: !1,
				padding: 0,
				reverse: !1,
				display: !0,
				autoSkip: !0,
				autoSkipPadding: 0,
				labelOffset: 0,
				callback: li.formatters.values,
				minor: {},
				major: {}
			}
		});
		var fi = pt.extend({
				getPadding: function () {
					return {
						left: this.paddingLeft || 0,
						top: this.paddingTop || 0,
						right: this.paddingRight || 0,
						bottom: this.paddingBottom || 0
					}
				},
				getTicks: function () {
					return this._ticks
				},
				mergeTicksOptions: function () {
					var t = this.options.ticks;
					for (var e in !1 === t.minor && (t.minor = {
							display: !1
						}), !1 === t.major && (t.major = {
							display: !1
						}), t) "major" !== e && "minor" !== e && (void 0 === t.minor[e] && (t.minor[e] = t[e]), void 0 === t.major[e] && (t.major[e] = t[e]))
				},
				beforeUpdate: function () {
					ht.callback(this.options.beforeUpdate, [this])
				},
				update: function (t, e, i) {
					var n, r, a, o, s, l, h = this;
					for (h.beforeUpdate(), h.maxWidth = t, h.maxHeight = e, h.margins = ht.extend({
							left: 0,
							right: 0,
							top: 0,
							bottom: 0
						}, i), h._maxLabelLines = 0, h.longestLabelWidth = 0, h.longestTextCache = h.longestTextCache || {}, h.beforeSetDimensions(), h.setDimensions(), h.afterSetDimensions(), h.beforeDataLimits(), h.determineDataLimits(), h.afterDataLimits(), h.beforeBuildTicks(), s = h.buildTicks() || [], s = h.afterBuildTicks(s) || s, h.beforeTickToLabelConversion(), a = h.convertTicksToLabels(s) || h.ticks, h.afterTickToLabelConversion(), n = 0, r = (h.ticks = a).length; n < r; ++n) o = a[n], (l = s[n]) ? l.label = o : s.push(l = {
						label: o,
						major: !1
					});
					return h._ticks = s, h.beforeCalculateTickRotation(), h.calculateTickRotation(), h.afterCalculateTickRotation(), h.beforeFit(), h.fit(), h.afterFit(), h.afterUpdate(), h.minSize
				},
				afterUpdate: function () {
					ht.callback(this.options.afterUpdate, [this])
				},
				beforeSetDimensions: function () {
					ht.callback(this.options.beforeSetDimensions, [this])
				},
				setDimensions: function () {
					var t = this;
					t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0
				},
				afterSetDimensions: function () {
					ht.callback(this.options.afterSetDimensions, [this])
				},
				beforeDataLimits: function () {
					ht.callback(this.options.beforeDataLimits, [this])
				},
				determineDataLimits: ht.noop,
				afterDataLimits: function () {
					ht.callback(this.options.afterDataLimits, [this])
				},
				beforeBuildTicks: function () {
					ht.callback(this.options.beforeBuildTicks, [this])
				},
				buildTicks: ht.noop,
				afterBuildTicks: function (t) {
					return ht.isArray(t) && t.length ? ht.callback(this.options.afterBuildTicks, [this, t]) : (this.ticks = ht.callback(this.options.afterBuildTicks, [this, this.ticks]) || this.ticks, t)
				},
				beforeTickToLabelConversion: function () {
					ht.callback(this.options.beforeTickToLabelConversion, [this])
				},
				convertTicksToLabels: function () {
					var t = this.options.ticks;
					this.ticks = this.ticks.map(t.userCallback || t.callback, this)
				},
				afterTickToLabelConversion: function () {
					ht.callback(this.options.afterTickToLabelConversion, [this])
				},
				beforeCalculateTickRotation: function () {
					ht.callback(this.options.beforeCalculateTickRotation, [this])
				},
				calculateTickRotation: function () {
					var t = this,
						e = t.ctx,
						i = t.options.ticks,
						n = di(t._ticks),
						r = ht.options._parseFont(i);
					e.font = r.string;
					var a = i.minRotation || 0;
					if (n.length && t.options.display && t.isHorizontal())
						for (var o, s = ht.longestText(e, r.string, n, t.longestTextCache), l = s, h = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; h < l && a < i.maxRotation;) {
							var u = ht.toRadians(a);
							if (o = Math.cos(u), Math.sin(u) * s > t.maxHeight) {
								a--;
								break
							}
							a++, l = o * s
						}
					t.labelRotation = a
				},
				afterCalculateTickRotation: function () {
					ht.callback(this.options.afterCalculateTickRotation, [this])
				},
				beforeFit: function () {
					ht.callback(this.options.beforeFit, [this])
				},
				fit: function () {
					var t = this,
						e = t.minSize = {
							width: 0,
							height: 0
						},
						i = di(t._ticks),
						n = t.options,
						r = n.ticks,
						a = n.scaleLabel,
						o = n.gridLines,
						s = t._isVisible(),
						l = n.position,
						h = t.isHorizontal(),
						u = ht.options._parseFont,
						d = u(r),
						c = n.gridLines.tickMarkLength;
					if (e.width = h ? t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : s && o.drawTicks ? c : 0, e.height = h ? s && o.drawTicks ? c : 0 : t.maxHeight, a.display && s) {
						var f = u(a),
							p = ht.options.toPadding(a.padding),
							g = f.lineHeight + p.height;
						h ? e.height += g : e.width += g
					}
					if (r.display && s) {
						var m = ht.longestText(t.ctx, d.string, i, t.longestTextCache),
							v = ht.numberOfLabelLines(i),
							y = .5 * d.size,
							x = t.options.ticks.padding;
						if (t._maxLabelLines = v, t.longestLabelWidth = m, h) {
							var b = ht.toRadians(t.labelRotation),
								_ = Math.cos(b),
								w = Math.sin(b) * m + d.lineHeight * v + y;
							e.height = Math.min(t.maxHeight, e.height + w + x), t.ctx.font = d.string;
							var k, M, S = ci(t.ctx, i[0], d.string),
								C = ci(t.ctx, i[i.length - 1], d.string),
								D = t.getPixelForTick(0) - t.left,
								T = t.right - t.getPixelForTick(i.length - 1);
							M = 0 !== t.labelRotation ? (k = "bottom" === l ? _ * S : _ * y, "bottom" === l ? _ * y : _ * C) : (k = S / 2, C / 2), t.paddingLeft = Math.max(k - D, 0) + 3, t.paddingRight = Math.max(M - T, 0) + 3
						} else r.mirror ? m = 0 : m += x + y, e.width = Math.min(t.maxWidth, e.width + m), t.paddingTop = d.size / 2, t.paddingBottom = d.size / 2
					}
					t.handleMargins(), t.width = e.width, t.height = e.height
				},
				handleMargins: function () {
					var t = this;
					t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0))
				},
				afterFit: function () {
					ht.callback(this.options.afterFit, [this])
				},
				isHorizontal: function () {
					return "top" === this.options.position || "bottom" === this.options.position
				},
				isFullWidth: function () {
					return this.options.fullWidth
				},
				getRightValue: function (t) {
					if (ht.isNullOrUndef(t)) return NaN;
					if (("number" == typeof t || t instanceof Number) && !isFinite(t)) return NaN;
					if (t)
						if (this.isHorizontal()) {
							if (void 0 !== t.x) return this.getRightValue(t.x)
						} else if (void 0 !== t.y) return this.getRightValue(t.y);
					return t
				},
				getLabelForIndex: ht.noop,
				getPixelForValue: ht.noop,
				getValueForPixel: ht.noop,
				getPixelForTick: function (t) {
					var e = this,
						i = e.options.offset;
					if (e.isHorizontal()) {
						var n = (e.width - (e.paddingLeft + e.paddingRight)) / Math.max(e._ticks.length - (i ? 0 : 1), 1),
							r = n * t + e.paddingLeft;
						i && (r += n / 2);
						var a = e.left + r;
						return a += e.isFullWidth() ? e.margins.left : 0
					}
					var o = e.height - (e.paddingTop + e.paddingBottom);
					return e.top + t * (o / (e._ticks.length - 1))
				},
				getPixelForDecimal: function (t) {
					var e = this;
					if (e.isHorizontal()) {
						var i = (e.width - (e.paddingLeft + e.paddingRight)) * t + e.paddingLeft,
							n = e.left + i;
						return n += e.isFullWidth() ? e.margins.left : 0
					}
					return e.top + t * e.height
				},
				getBasePixel: function () {
					return this.getPixelForValue(this.getBaseValue())
				},
				getBaseValue: function () {
					var t = this.min,
						e = this.max;
					return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : 0 < t && 0 < e ? t : 0
				},
				_autoSkip: function (t) {
					var e, i, n = this.isHorizontal(),
						r = this.options.ticks.minor,
						a = t.length,
						o = !1,
						s = r.maxTicksLimit,
						l = this._tickSize() * (a - 1),
						h = n ? this.width - (this.paddingLeft + this.paddingRight) : this.height - (this.paddingTop + this.PaddingBottom),
						u = [];
					for (h < l && (o = 1 + Math.floor(l / h)), s < a && (o = Math.max(o, 1 + Math.floor(a / s))), e = 0; e < a; e++) i = t[e], 1 < o && 0 < e % o && delete i.label, u.push(i);
					return u
				},
				_tickSize: function () {
					var t = this.isHorizontal(),
						e = this.options.ticks.minor,
						i = ht.toRadians(this.labelRotation),
						n = Math.abs(Math.cos(i)),
						r = Math.abs(Math.sin(i)),
						a = e.autoSkipPadding || 0,
						o = this.longestLabelWidth + a || 0,
						s = ht.options._parseFont(e),
						l = this._maxLabelLines * s.lineHeight + a || 0;
					return t ? o * r < l * n ? o / n : l / r : l * r < o * n ? l / n : o / r
				},
				_isVisible: function () {
					var t, e, i, n = this.chart,
						r = this.options.display;
					if ("auto" !== r) return !!r;
					for (t = 0, e = n.data.datasets.length; t < e; ++t)
						if (n.isDatasetVisible(t) && ((i = n.getDatasetMeta(t)).xAxisID === this.id || i.yAxisID === this.id)) return !0;
					return !1
				},
				draw: function (D) {
					var T = this,
						P = T.options;
					if (T._isVisible()) {
						var t, A, F, I = T.chart,
							o = T.ctx,
							e = ot.global.defaultFontColor,
							s = P.ticks.minor,
							i = P.ticks.major || s,
							L = P.gridLines,
							n = P.scaleLabel,
							O = P.position,
							R = 0 !== T.labelRotation,
							B = s.mirror,
							W = T.isHorizontal(),
							r = ht.options._parseFont,
							a = s.display && s.autoSkip ? T._autoSkip(T.getTicks()) : T.getTicks(),
							l = hi(s.fontColor, e),
							h = r(s),
							z = h.lineHeight,
							u = hi(i.fontColor, e),
							d = r(i),
							N = s.padding,
							Y = s.labelOffset,
							E = L.drawTicks ? L.tickMarkLength : 0,
							c = hi(n.fontColor, e),
							f = r(n),
							p = ht.options.toPadding(n.padding),
							H = ht.toRadians(T.labelRotation),
							V = [],
							j = L.drawBorder ? ui(L.lineWidth, 0, 0) : 0,
							U = ht._alignPixel;
						F = "top" === O ? (t = U(I, T.bottom, j), A = T.bottom - E, t - j / 2) : "bottom" === O ? (t = U(I, T.top, j), A = t + j / 2, T.top + E) : "left" === O ? (t = U(I, T.right, j), A = T.right - E, t - j / 2) : (t = U(I, T.left, j), A = t + j / 2, T.left + E);
						if (ht.each(a, function (t, e) {
								if (!ht.isNullOrUndef(t.label)) {
									var i, n, r, a, o, s, l, h, u, d, c, f, p, g, m, v, y = t.label;
									a = e === T.zeroLineIndex && P.offset === L.offsetGridLines ? (i = L.zeroLineWidth, n = L.zeroLineColor, r = L.zeroLineBorderDash || [], L.zeroLineBorderDashOffset || 0) : (i = ui(L.lineWidth, e), n = ui(L.color, e), r = L.borderDash || [], L.borderDashOffset || 0);
									var x, b, _, w, k = ht.isArray(y) ? y.length : 1,
										M = (x = T, b = e, _ = L.offsetGridLines, w = x.getPixelForTick(b), _ && (1 === x.getTicks().length ? w -= x.isHorizontal() ? Math.max(w - x.left, x.right - w) : Math.max(w - x.top, x.bottom - w) : w -= 0 === b ? (x.getPixelForTick(1) - w) / 2 : (w - x.getPixelForTick(b - 1)) / 2), w);
									if (W) {
										var S = E + N;
										M < T.left - 1e-7 && (n = "rgba(0,0,0,0)"), o = l = u = c = U(I, M, i), s = A, h = F, p = T.getPixelForTick(e) + Y, g = "top" === O ? (d = U(I, D.top, j) + j / 2, f = D.bottom, m = ((R ? 1 : .5) - k) * z, v = R ? "left" : "center", T.bottom - S) : (d = D.top, f = U(I, D.bottom, j) - j / 2, m = (R ? 0 : .5) * z, v = R ? "right" : "center", T.top + S)
									} else {
										var C = (B ? 0 : E) + N;
										M < T.top - 1e-7 && (n = "rgba(0,0,0,0)"), o = A, l = F, s = h = d = f = U(I, M, i), g = T.getPixelForTick(e) + Y, m = (1 - k) * z / 2, p = "left" === O ? (u = U(I, D.left, j) + j / 2, c = D.right, v = B ? "left" : "right", T.right - C) : (u = D.left, c = U(I, D.right, j) - j / 2, v = B ? "right" : "left", T.left + C)
									}
									V.push({
										tx1: o,
										ty1: s,
										tx2: l,
										ty2: h,
										x1: u,
										y1: d,
										x2: c,
										y2: f,
										labelX: p,
										labelY: g,
										glWidth: i,
										glColor: n,
										glBorderDash: r,
										glBorderDashOffset: a,
										rotation: -1 * H,
										label: y,
										major: t.major,
										textOffset: m,
										textAlign: v
									})
								}
							}), ht.each(V, function (t) {
								var e = t.glWidth,
									i = t.glColor;
								if (L.display && e && i && (o.save(), o.lineWidth = e, o.strokeStyle = i, o.setLineDash && (o.setLineDash(t.glBorderDash), o.lineDashOffset = t.glBorderDashOffset), o.beginPath(), L.drawTicks && (o.moveTo(t.tx1, t.ty1), o.lineTo(t.tx2, t.ty2)), L.drawOnChartArea && (o.moveTo(t.x1, t.y1), o.lineTo(t.x2, t.y2)), o.stroke(), o.restore()), s.display) {
									o.save(), o.translate(t.labelX, t.labelY), o.rotate(t.rotation), o.font = t.major ? d.string : h.string, o.fillStyle = t.major ? u : l, o.textBaseline = "middle", o.textAlign = t.textAlign;
									var n = t.label,
										r = t.textOffset;
									if (ht.isArray(n))
										for (var a = 0; a < n.length; ++a) o.fillText("" + n[a], 0, r), r += z;
									else o.fillText(n, 0, r);
									o.restore()
								}
							}), n.display) {
							var g, m, v = 0,
								y = f.lineHeight / 2;
							if (W) g = T.left + (T.right - T.left) / 2, m = "bottom" === O ? T.bottom - y - p.bottom : T.top + y + p.top;
							else {
								var x = "left" === O;
								g = x ? T.left + y + p.top : T.right - y - p.top, m = T.top + (T.bottom - T.top) / 2, v = x ? -.5 * Math.PI : .5 * Math.PI
							}
							o.save(), o.translate(g, m), o.rotate(v), o.textAlign = "center", o.textBaseline = "middle", o.fillStyle = c, o.font = f.string, o.fillText(n.labelString, 0, 0), o.restore()
						}
						if (j) {
							var b, _, w, k, M = j,
								S = ui(L.lineWidth, a.length - 1, 0);
							W ? (b = U(I, T.left, M) - M / 2, _ = U(I, T.right, S) + S / 2, w = k = t) : (w = U(I, T.top, M) - M / 2, k = U(I, T.bottom, S) + S / 2, b = _ = t), o.lineWidth = j, o.strokeStyle = ui(L.color, 0), o.beginPath(), o.moveTo(b, w), o.lineTo(_, k), o.stroke()
						}
					}
				}
			}),
			pi = fi.extend({
				getLabels: function () {
					var t = this.chart.data;
					return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels
				},
				determineDataLimits: function () {
					var t, e = this,
						i = e.getLabels();
					e.minIndex = 0, e.maxIndex = i.length - 1, void 0 !== e.options.ticks.min && (t = i.indexOf(e.options.ticks.min), e.minIndex = -1 !== t ? t : e.minIndex), void 0 !== e.options.ticks.max && (t = i.indexOf(e.options.ticks.max), e.maxIndex = -1 !== t ? t : e.maxIndex), e.min = i[e.minIndex], e.max = i[e.maxIndex]
				},
				buildTicks: function () {
					var t = this.getLabels();
					this.ticks = 0 === this.minIndex && this.maxIndex === t.length - 1 ? t : t.slice(this.minIndex, this.maxIndex + 1)
				},
				getLabelForIndex: function (t, e) {
					var i = this.chart;
					return i.getDatasetMeta(e).controller._getValueScaleId() === this.id ? this.getRightValue(i.data.datasets[e].data[t]) : this.ticks[t - this.minIndex]
				},
				getPixelForValue: function (t, e) {
					var i, n = this,
						r = n.options.offset,
						a = Math.max(n.maxIndex + 1 - n.minIndex - (r ? 0 : 1), 1);
					if (null != t && (i = n.isHorizontal() ? t.x : t.y), void 0 !== i || void 0 !== t && isNaN(e)) {
						t = i || t;
						var o = n.getLabels().indexOf(t);
						e = -1 !== o ? o : e
					}
					if (n.isHorizontal()) {
						var s = n.width / a,
							l = s * (e - n.minIndex);
						return r && (l += s / 2), n.left + l
					}
					var h = n.height / a,
						u = h * (e - n.minIndex);
					return r && (u += h / 2), n.top + u
				},
				getPixelForTick: function (t) {
					return this.getPixelForValue(this.ticks[t], t + this.minIndex, null)
				},
				getValueForPixel: function (t) {
					var e = this.options.offset,
						i = Math.max(this._ticks.length - (e ? 0 : 1), 1),
						n = this.isHorizontal(),
						r = (n ? this.width : this.height) / i;
					return t -= n ? this.left : this.top, e && (t -= r / 2), (t <= 0 ? 0 : Math.round(t / r)) + this.minIndex
				},
				getBasePixel: function () {
					return this.bottom
				}
			}),
			gi = {
				position: "bottom"
			};
		pi._defaults = gi;
		var mi = ht.noop,
			vi = ht.isNullOrUndef;
		var yi = fi.extend({
				getRightValue: function (t) {
					return "string" == typeof t ? +t : fi.prototype.getRightValue.call(this, t)
				},
				handleTickRangeOptions: function () {
					var t = this,
						e = t.options.ticks;
					if (e.beginAtZero) {
						var i = ht.sign(t.min),
							n = ht.sign(t.max);
						i < 0 && n < 0 ? t.max = 0 : 0 < i && 0 < n && (t.min = 0)
					}
					var r = void 0 !== e.min || void 0 !== e.suggestedMin,
						a = void 0 !== e.max || void 0 !== e.suggestedMax;
					void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (null === t.min ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (null === t.max ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), r !== a && t.min >= t.max && (r ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--)
				},
				getTickLimit: function () {
					var t, e = this.options.ticks,
						i = e.stepSize,
						n = e.maxTicksLimit;
					return i ? t = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1 : (t = this._computeTickLimit(), n = n || 11), n && (t = Math.min(n, t)), t
				},
				_computeTickLimit: function () {
					return Number.POSITIVE_INFINITY
				},
				handleDirectionalChanges: mi,
				buildTicks: function () {
					var t = this,
						e = t.options.ticks,
						i = t.getTickLimit(),
						n = {
							maxTicks: i = Math.max(2, i),
							min: e.min,
							max: e.max,
							precision: e.precision,
							stepSize: ht.valueOrDefault(e.fixedStepSize, e.stepSize)
						},
						r = t.ticks = function (t, e) {
							var i, n, r, a, o = [],
								s = t.stepSize,
								l = s || 1,
								h = t.maxTicks - 1,
								u = t.min,
								d = t.max,
								c = t.precision,
								f = e.min,
								p = e.max,
								g = ht.niceNum((p - f) / h / l) * l;
							if (g < 1e-14 && vi(u) && vi(d)) return [f, p];
							h < (a = Math.ceil(p / g) - Math.floor(f / g)) && (g = ht.niceNum(a * g / h / l) * l), s || vi(c) ? i = Math.pow(10, ht._decimalPlaces(g)) : (i = Math.pow(10, c), g = Math.ceil(g * i) / i), n = Math.floor(f / g) * g, r = Math.ceil(p / g) * g, s && (!vi(u) && ht.almostWhole(u / g, g / 1e3) && (n = u), !vi(d) && ht.almostWhole(d / g, g / 1e3) && (r = d)), a = (r - n) / g, a = ht.almostEquals(a, Math.round(a), g / 1e3) ? Math.round(a) : Math.ceil(a), n = Math.round(n * i) / i, r = Math.round(r * i) / i, o.push(vi(u) ? n : u);
							for (var m = 1; m < a; ++m) o.push(Math.round((n + m * g) * i) / i);
							return o.push(vi(d) ? r : d), o
						}(n, t);
					t.handleDirectionalChanges(), t.max = ht.max(r), t.min = ht.min(r), e.reverse ? (r.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max)
				},
				convertTicksToLabels: function () {
					this.ticksAsNumbers = this.ticks.slice(), this.zeroLineIndex = this.ticks.indexOf(0), fi.prototype.convertTicksToLabels.call(this)
				}
			}),
			xi = {
				position: "left",
				ticks: {
					callback: li.formatters.linear
				}
			},
			bi = yi.extend({
				determineDataLimits: function () {
					var o = this,
						s = o.options,
						l = o.chart,
						t = l.data.datasets,
						e = o.isHorizontal();

					function h(t) {
						return e ? t.xAxisID === o.id : t.yAxisID === o.id
					}
					o.min = null, o.max = null;
					var n = s.stacked;
					if (void 0 === n && ht.each(t, function (t, e) {
							if (!n) {
								var i = l.getDatasetMeta(e);
								l.isDatasetVisible(e) && h(i) && void 0 !== i.stack && (n = !0)
							}
						}), s.stacked || n) {
						var u = {};
						ht.each(t, function (t, e) {
							var n = l.getDatasetMeta(e),
								i = [n.type, void 0 === s.stacked && void 0 === n.stack ? e : "", n.stack].join(".");
							void 0 === u[i] && (u[i] = {
								positiveValues: [],
								negativeValues: []
							});
							var r = u[i].positiveValues,
								a = u[i].negativeValues;
							l.isDatasetVisible(e) && h(n) && ht.each(t.data, function (t, e) {
								var i = +o.getRightValue(t);
								isNaN(i) || n.data[e].hidden || (r[e] = r[e] || 0, a[e] = a[e] || 0, s.relativePoints ? r[e] = 100 : i < 0 ? a[e] += i : r[e] += i)
							})
						}), ht.each(u, function (t) {
							var e = t.positiveValues.concat(t.negativeValues),
								i = ht.min(e),
								n = ht.max(e);
							o.min = null === o.min ? i : Math.min(o.min, i), o.max = null === o.max ? n : Math.max(o.max, n)
						})
					} else ht.each(t, function (t, e) {
						var n = l.getDatasetMeta(e);
						l.isDatasetVisible(e) && h(n) && ht.each(t.data, function (t, e) {
							var i = +o.getRightValue(t);
							isNaN(i) || n.data[e].hidden || (null === o.min ? o.min = i : i < o.min && (o.min = i), null === o.max ? o.max = i : i > o.max && (o.max = i))
						})
					});
					o.min = isFinite(o.min) && !isNaN(o.min) ? o.min : 0, o.max = isFinite(o.max) && !isNaN(o.max) ? o.max : 1, this.handleTickRangeOptions()
				},
				_computeTickLimit: function () {
					var t;
					return this.isHorizontal() ? Math.ceil(this.width / 40) : (t = ht.options._parseFont(this.options.ticks), Math.ceil(this.height / t.lineHeight))
				},
				handleDirectionalChanges: function () {
					this.isHorizontal() || this.ticks.reverse()
				},
				getLabelForIndex: function (t, e) {
					return +this.getRightValue(this.chart.data.datasets[e].data[t])
				},
				getPixelForValue: function (t) {
					var e = this.start,
						i = +this.getRightValue(t),
						n = this.end - e;
					return this.isHorizontal() ? this.left + this.width / n * (i - e) : this.bottom - this.height / n * (i - e)
				},
				getValueForPixel: function (t) {
					var e = this.isHorizontal(),
						i = e ? this.width : this.height,
						n = (e ? t - this.left : this.bottom - t) / i;
					return this.start + (this.end - this.start) * n
				},
				getPixelForTick: function (t) {
					return this.getPixelForValue(this.ticksAsNumbers[t])
				}
			}),
			_i = xi;
		bi._defaults = _i;
		var wi = ht.valueOrDefault;
		var ki = {
			position: "left",
			ticks: {
				callback: li.formatters.logarithmic
			}
		};

		function Mi(t, e) {
			return ht.isFinite(t) && 0 <= t ? t : e
		}
		var Si = fi.extend({
				determineDataLimits: function () {
					var o = this,
						i = o.options,
						s = o.chart,
						t = s.data.datasets,
						e = o.isHorizontal();

					function l(t) {
						return e ? t.xAxisID === o.id : t.yAxisID === o.id
					}
					o.min = null, o.max = null, o.minNotZero = null;
					var n = i.stacked;
					if (void 0 === n && ht.each(t, function (t, e) {
							if (!n) {
								var i = s.getDatasetMeta(e);
								s.isDatasetVisible(e) && l(i) && void 0 !== i.stack && (n = !0)
							}
						}), i.stacked || n) {
						var h = {};
						ht.each(t, function (t, e) {
							var r = s.getDatasetMeta(e),
								a = [r.type, void 0 === i.stacked && void 0 === r.stack ? e : "", r.stack].join(".");
							s.isDatasetVisible(e) && l(r) && (void 0 === h[a] && (h[a] = []), ht.each(t.data, function (t, e) {
								var i = h[a],
									n = +o.getRightValue(t);
								isNaN(n) || r.data[e].hidden || n < 0 || (i[e] = i[e] || 0, i[e] += n)
							}))
						}), ht.each(h, function (t) {
							if (0 < t.length) {
								var e = ht.min(t),
									i = ht.max(t);
								o.min = null === o.min ? e : Math.min(o.min, e), o.max = null === o.max ? i : Math.max(o.max, i)
							}
						})
					} else ht.each(t, function (t, e) {
						var n = s.getDatasetMeta(e);
						s.isDatasetVisible(e) && l(n) && ht.each(t.data, function (t, e) {
							var i = +o.getRightValue(t);
							isNaN(i) || n.data[e].hidden || i < 0 || (null === o.min ? o.min = i : i < o.min && (o.min = i), null === o.max ? o.max = i : i > o.max && (o.max = i), 0 !== i && (null === o.minNotZero || i < o.minNotZero) && (o.minNotZero = i))
						})
					});
					this.handleTickRangeOptions()
				},
				handleTickRangeOptions: function () {
					var t = this,
						e = t.options.ticks;
					t.min = Mi(e.min, t.min), t.max = Mi(e.max, t.max), t.min === t.max && (0 !== t.min && null !== t.min ? (t.min = Math.pow(10, Math.floor(ht.log10(t.min)) - 1), t.max = Math.pow(10, Math.floor(ht.log10(t.max)) + 1)) : (t.min = 1, t.max = 10)), null === t.min && (t.min = Math.pow(10, Math.floor(ht.log10(t.max)) - 1)), null === t.max && (t.max = 0 !== t.min ? Math.pow(10, Math.floor(ht.log10(t.min)) + 1) : 10), null === t.minNotZero && (0 < t.min ? t.minNotZero = t.min : t.max < 1 ? t.minNotZero = Math.pow(10, Math.floor(ht.log10(t.max))) : t.minNotZero = 1)
				},
				buildTicks: function () {
					var t = this,
						e = t.options.ticks,
						i = !t.isHorizontal(),
						n = {
							min: Mi(e.min),
							max: Mi(e.max)
						},
						r = t.ticks = function (t, e) {
							var i, n, r = [],
								a = wi(t.min, Math.pow(10, Math.floor(ht.log10(e.min)))),
								o = Math.floor(ht.log10(e.max)),
								s = Math.ceil(e.max / Math.pow(10, o));
							0 === a ? (i = Math.floor(ht.log10(e.minNotZero)), n = Math.floor(e.minNotZero / Math.pow(10, i)), r.push(a), a = n * Math.pow(10, i)) : (i = Math.floor(ht.log10(a)), n = Math.floor(a / Math.pow(10, i)));
							for (var l = i < 0 ? Math.pow(10, Math.abs(i)) : 1; r.push(a), 10 == ++n && (n = 1, l = 0 <= ++i ? 1 : l), a = Math.round(n * Math.pow(10, i) * l) / l, i < o || i === o && n < s;);
							var h = wi(t.max, a);
							return r.push(h), r
						}(n, t);
					t.max = ht.max(r), t.min = ht.min(r), e.reverse ? (i = !i, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i && r.reverse()
				},
				convertTicksToLabels: function () {
					this.tickValues = this.ticks.slice(), fi.prototype.convertTicksToLabels.call(this)
				},
				getLabelForIndex: function (t, e) {
					return +this.getRightValue(this.chart.data.datasets[e].data[t])
				},
				getPixelForTick: function (t) {
					return this.getPixelForValue(this.tickValues[t])
				},
				_getFirstTickValue: function (t) {
					var e = Math.floor(ht.log10(t));
					return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e)
				},
				getPixelForValue: function (t) {
					var e, i, n, r, a, o = this,
						s = o.options.ticks,
						l = s.reverse,
						h = ht.log10,
						u = o._getFirstTickValue(o.minNotZero),
						d = 0;
					return t = +o.getRightValue(t), a = l ? (n = o.end, r = o.start, -1) : (n = o.start, r = o.end, 1), i = o.isHorizontal() ? (e = o.width, l ? o.right : o.left) : (e = o.height, a *= -1, l ? o.top : o.bottom), t !== n && (0 === n && (e -= d = wi(s.fontSize, ot.global.defaultFontSize), n = u), 0 !== t && (d += e / (h(r) - h(n)) * (h(t) - h(n))), i += a * d), i
				},
				getValueForPixel: function (t) {
					var e, i, n, r, a = this,
						o = a.options.ticks,
						s = o.reverse,
						l = ht.log10,
						h = a._getFirstTickValue(a.minNotZero);
					if (n = s ? (i = a.end, a.start) : (i = a.start, a.end), (r = a.isHorizontal() ? (e = a.width, s ? a.right - t : t - a.left) : (e = a.height, s ? t - a.top : a.bottom - t)) !== i) {
						if (0 === i) {
							var u = wi(o.fontSize, ot.global.defaultFontSize);
							r -= u, e -= u, i = h
						}
						r *= l(n) - l(i), r /= e, r = Math.pow(10, l(i) + r)
					}
					return r
				}
			}),
			Ci = ki;
		Si._defaults = Ci;
		var Di = ht.valueOrDefault,
			Ti = ht.valueAtIndexOrDefault,
			Pi = ht.options.resolve,
			Ai = {
				display: !0,
				animate: !0,
				position: "chartArea",
				angleLines: {
					display: !0,
					color: "rgba(0, 0, 0, 0.1)",
					lineWidth: 1,
					borderDash: [],
					borderDashOffset: 0
				},
				gridLines: {
					circular: !1
				},
				ticks: {
					showLabelBackdrop: !0,
					backdropColor: "rgba(255,255,255,0.75)",
					backdropPaddingY: 2,
					backdropPaddingX: 2,
					callback: li.formatters.linear
				},
				pointLabels: {
					display: !0,
					fontSize: 10,
					callback: function (t) {
						return t
					}
				}
			};

		function Fi(t) {
			var e = t.options;
			return e.angleLines.display || e.pointLabels.display ? t.chart.data.labels.length : 0
		}

		function Ii(t) {
			var e = t.ticks;
			return e.display && t.display ? Di(e.fontSize, ot.global.defaultFontSize) + 2 * e.backdropPaddingY : 0
		}

		function Li(t, e, i, n, r) {
			return t === n || t === r ? {
				start: e - i / 2,
				end: e + i / 2
			} : t < n || r < t ? {
				start: e - i,
				end: e
			} : {
				start: e,
				end: e + i
			}
		}

		function Oi(t, e, i, n) {
			var r, a, o = i.y + n / 2;
			if (ht.isArray(e))
				for (r = 0, a = e.length; r < a; ++r) t.fillText(e[r], i.x, o), o += n;
			else t.fillText(e, i.x, o)
		}

		function Ri(t) {
			return ht.isNumber(t) ? t : 0
		}
		var Bi = yi.extend({
				setDimensions: function () {
					var t = this;
					t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = Ii(t.options) / 2, t.xCenter = Math.floor(t.width / 2), t.yCenter = Math.floor((t.height - t.paddingTop) / 2), t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2
				},
				determineDataLimits: function () {
					var r = this,
						i = r.chart,
						a = Number.POSITIVE_INFINITY,
						o = Number.NEGATIVE_INFINITY;
					ht.each(i.data.datasets, function (t, e) {
						if (i.isDatasetVisible(e)) {
							var n = i.getDatasetMeta(e);
							ht.each(t.data, function (t, e) {
								var i = +r.getRightValue(t);
								isNaN(i) || n.data[e].hidden || (a = Math.min(i, a), o = Math.max(i, o))
							})
						}
					}), r.min = a === Number.POSITIVE_INFINITY ? 0 : a, r.max = o === Number.NEGATIVE_INFINITY ? 0 : o, r.handleTickRangeOptions()
				},
				_computeTickLimit: function () {
					return Math.ceil(this.drawingArea / Ii(this.options))
				},
				convertTicksToLabels: function () {
					yi.prototype.convertTicksToLabels.call(this), this.pointLabels = this.chart.data.labels.map(this.options.pointLabels.callback, this)
				},
				getLabelForIndex: function (t, e) {
					return +this.getRightValue(this.chart.data.datasets[e].data[t])
				},
				fit: function () {
					var t = this.options;
					t.display && t.pointLabels.display ? function (t) {
						var e, i, n, r = ht.options._parseFont(t.options.pointLabels),
							a = {
								l: 0,
								r: t.width,
								t: 0,
								b: t.height - t.paddingTop
							},
							o = {};
						t.ctx.font = r.string, t._pointLabelSizes = [];
						var s, l, h, u = Fi(t);
						for (e = 0; e < u; e++) {
							n = t.getPointPosition(e, t.drawingArea + 5), s = t.ctx, l = r.lineHeight, h = t.pointLabels[e] || "", i = ht.isArray(h) ? {
								w: ht.longestText(s, s.font, h),
								h: h.length * l
							} : {
								w: s.measureText(h).width,
								h: l
							}, t._pointLabelSizes[e] = i;
							var d = t.getIndexAngle(e),
								c = ht.toDegrees(d) % 360,
								f = Li(c, n.x, i.w, 0, 180),
								p = Li(c, n.y, i.h, 90, 270);
							f.start < a.l && (a.l = f.start, o.l = d), f.end > a.r && (a.r = f.end, o.r = d), p.start < a.t && (a.t = p.start, o.t = d), p.end > a.b && (a.b = p.end, o.b = d)
						}
						t.setReductions(t.drawingArea, a, o)
					}(this) : this.setCenterPoint(0, 0, 0, 0)
				},
				setReductions: function (t, e, i) {
					var n = e.l / Math.sin(i.l),
						r = Math.max(e.r - this.width, 0) / Math.sin(i.r),
						a = -e.t / Math.cos(i.t),
						o = -Math.max(e.b - (this.height - this.paddingTop), 0) / Math.cos(i.b);
					n = Ri(n), r = Ri(r), a = Ri(a), o = Ri(o), this.drawingArea = Math.min(Math.floor(t - (n + r) / 2), Math.floor(t - (a + o) / 2)), this.setCenterPoint(n, r, a, o)
				},
				setCenterPoint: function (t, e, i, n) {
					var r = this,
						a = r.width - e - r.drawingArea,
						o = t + r.drawingArea,
						s = i + r.drawingArea,
						l = r.height - r.paddingTop - n - r.drawingArea;
					r.xCenter = Math.floor((o + a) / 2 + r.left), r.yCenter = Math.floor((s + l) / 2 + r.top + r.paddingTop)
				},
				getIndexAngle: function (t) {
					return t * (2 * Math.PI / Fi(this)) + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360
				},
				getDistanceFromCenterForValue: function (t) {
					if (null === t) return 0;
					var e = this.drawingArea / (this.max - this.min);
					return this.options.ticks.reverse ? (this.max - t) * e : (t - this.min) * e
				},
				getPointPosition: function (t, e) {
					var i = this.getIndexAngle(t) - Math.PI / 2;
					return {
						x: Math.cos(i) * e + this.xCenter,
						y: Math.sin(i) * e + this.yCenter
					}
				},
				getPointPositionForValue: function (t, e) {
					return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
				},
				getBasePosition: function () {
					var t = this.min,
						e = this.max;
					return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : 0 < t && 0 < e ? t : 0)
				},
				draw: function () {
					var a = this,
						t = a.options,
						o = t.gridLines,
						s = t.ticks;
					if (t.display) {
						var l = a.ctx,
							h = this.getIndexAngle(0),
							u = ht.options._parseFont(s);
						(t.angleLines.display || t.pointLabels.display) && function (t) {
							var e = t.ctx,
								i = t.options,
								n = i.angleLines,
								r = i.gridLines,
								a = i.pointLabels,
								o = Di(n.lineWidth, r.lineWidth),
								s = Di(n.color, r.color),
								l = Ii(i);
							e.save(), e.lineWidth = o, e.strokeStyle = s, e.setLineDash && (e.setLineDash(Pi([n.borderDash, r.borderDash, []])), e.lineDashOffset = Pi([n.borderDashOffset, r.borderDashOffset, 0]));
							var h, u, d, c, f = t.getDistanceFromCenterForValue(i.ticks.reverse ? t.min : t.max),
								p = ht.options._parseFont(a);
							e.font = p.string, e.textBaseline = "middle";
							for (var g = Fi(t) - 1; 0 <= g; g--) {
								if (n.display && o && s) {
									var m = t.getPointPosition(g, f);
									e.beginPath(), e.moveTo(t.xCenter, t.yCenter), e.lineTo(m.x, m.y), e.stroke()
								}
								if (a.display) {
									var v = 0 === g ? l / 2 : 0,
										y = t.getPointPosition(g, f + v + 5),
										x = Ti(a.fontColor, g, ot.global.defaultFontColor);
									e.fillStyle = x;
									var b = t.getIndexAngle(g),
										_ = ht.toDegrees(b);
									e.textAlign = 0 === (c = _) || 180 === c ? "center" : c < 180 ? "left" : "right", h = _, u = t._pointLabelSizes[g], d = y, 90 === h || 270 === h ? d.y -= u.h / 2 : (270 < h || h < 90) && (d.y -= u.h), Oi(e, t.pointLabels[g] || "", y, p.lineHeight)
								}
							}
							e.restore()
						}(a), ht.each(a.ticks, function (t, e) {
							if (0 < e || s.reverse) {
								var i = a.getDistanceFromCenterForValue(a.ticksAsNumbers[e]);
								if (o.display && 0 !== e && function (t, e, i, n) {
										var r, a = t.ctx,
											o = e.circular,
											s = Fi(t),
											l = Ti(e.color, n - 1),
											h = Ti(e.lineWidth, n - 1);
										if ((o || s) && l && h) {
											if (a.save(), a.strokeStyle = l, a.lineWidth = h, a.setLineDash && (a.setLineDash(e.borderDash || []), a.lineDashOffset = e.borderDashOffset || 0), a.beginPath(), o) a.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI);
											else {
												r = t.getPointPosition(0, i), a.moveTo(r.x, r.y);
												for (var u = 1; u < s; u++) r = t.getPointPosition(u, i), a.lineTo(r.x, r.y)
											}
											a.closePath(), a.stroke(), a.restore()
										}
									}(a, o, i, e), s.display) {
									var n = Di(s.fontColor, ot.global.defaultFontColor);
									if (l.font = u.string, l.save(), l.translate(a.xCenter, a.yCenter), l.rotate(h), s.showLabelBackdrop) {
										var r = l.measureText(t).width;
										l.fillStyle = s.backdropColor, l.fillRect(-r / 2 - s.backdropPaddingX, -i - u.size / 2 - s.backdropPaddingY, r + 2 * s.backdropPaddingX, u.size + 2 * s.backdropPaddingY)
									}
									l.textAlign = "center", l.textBaseline = "middle", l.fillStyle = n, l.fillText(t, 0, -i), l.restore()
								}
							}
						})
					}
				}
			}),
			Wi = Ai;
		Bi._defaults = Wi;
		var zi = ht.valueOrDefault,
			Ni = Number.MIN_SAFE_INTEGER || -9007199254740991,
			Yi = Number.MAX_SAFE_INTEGER || 9007199254740991,
			Ei = {
				millisecond: {
					common: !0,
					size: 1,
					steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
				},
				second: {
					common: !0,
					size: 1e3,
					steps: [1, 2, 5, 10, 15, 30]
				},
				minute: {
					common: !0,
					size: 6e4,
					steps: [1, 2, 5, 10, 15, 30]
				},
				hour: {
					common: !0,
					size: 36e5,
					steps: [1, 2, 3, 6, 12]
				},
				day: {
					common: !0,
					size: 864e5,
					steps: [1, 2, 5]
				},
				week: {
					common: !1,
					size: 6048e5,
					steps: [1, 2, 3, 4]
				},
				month: {
					common: !0,
					size: 2628e6,
					steps: [1, 2, 3]
				},
				quarter: {
					common: !1,
					size: 7884e6,
					steps: [1, 2, 3, 4]
				},
				year: {
					common: !0,
					size: 3154e7
				}
			},
			Hi = Object.keys(Ei);

		function Vi(t, e) {
			return t - e
		}

		function ji(t) {
			var e, i, n, r = {},
				a = [];
			for (e = 0, i = t.length; e < i; ++e) r[n = t[e]] || (r[n] = !0, a.push(n));
			return a
		}

		function Ui(t, e, i, n) {
			var r = function (t, e, i) {
					for (var n, r, a, o = 0, s = t.length - 1; 0 <= o && o <= s;) {
						if (r = t[(n = o + s >> 1) - 1] || null, a = t[n], !r) return {
							lo: null,
							hi: a
						};
						if (a[e] < i) o = n + 1;
						else {
							if (!(r[e] > i)) return {
								lo: r,
								hi: a
							};
							s = n - 1
						}
					}
					return {
						lo: a,
						hi: null
					}
				}(t, e, i),
				a = r.lo ? r.hi ? r.lo : t[t.length - 2] : t[0],
				o = r.lo ? r.hi ? r.hi : t[t.length - 1] : t[1],
				s = o[e] - a[e],
				l = s ? (i - a[e]) / s : 0,
				h = (o[n] - a[n]) * l;
			return a[n] + h
		}

		function Gi(t, e) {
			var i = t._adapter,
				n = t.options.time,
				r = n.parser,
				a = r || n.format,
				o = e;
			return "function" == typeof r && (o = r(o)), ht.isFinite(o) || (o = "string" == typeof a ? i.parse(o, a) : i.parse(o)), null !== o ? +o : (r || "function" != typeof a || (o = a(e), ht.isFinite(o) || (o = i.parse(o))), o)
		}

		function $i(t, e) {
			if (ht.isNullOrUndef(e)) return null;
			var i = t.options.time,
				n = Gi(t, t.getRightValue(e));
			return null === n || i.round && (n = +t._adapter.startOf(n, i.round)), n
		}

		function qi(t) {
			for (var e = Hi.indexOf(t) + 1, i = Hi.length; e < i; ++e)
				if (Ei[Hi[e]].common) return Hi[e]
		}

		function Xi(t, e, i, n) {
			var r, a = t._adapter,
				o = t.options,
				s = o.time,
				l = s.unit || function (t, e, i, n) {
					var r, a, o, s = Hi.length;
					for (r = Hi.indexOf(t); r < s - 1; ++r)
						if (o = (a = Ei[Hi[r]]).steps ? a.steps[a.steps.length - 1] : Yi, a.common && Math.ceil((i - e) / (o * a.size)) <= n) return Hi[r];
					return Hi[s - 1]
				}(s.minUnit, e, i, n),
				h = qi(l),
				u = zi(s.stepSize, s.unitStepSize),
				d = "week" === l && s.isoWeekday,
				c = o.ticks.major.enabled,
				f = Ei[l],
				p = e,
				g = i,
				m = [];
			for (u || (u = function (t, e, i, n) {
					var r, a, o, s = e - t,
						l = Ei[i],
						h = l.size,
						u = l.steps;
					if (!u) return Math.ceil(s / (n * h));
					for (r = 0, a = u.length; r < a && (o = u[r], !(Math.ceil(s / (h * o)) <= n)); ++r);
					return o
				}(e, i, l, n)), d && (p = +a.startOf(p, "isoWeek", d), g = +a.startOf(g, "isoWeek", d)), p = +a.startOf(p, d ? "day" : l), (g = +a.startOf(g, d ? "day" : l)) < i && (g = +a.add(g, 1, l)), r = p, c && h && !d && !s.round && (r = +a.startOf(r, h), r = +a.add(r, ~~((p - r) / (f.size * u)) * u, l)); r < g; r = +a.add(r, u, l)) m.push(+r);
			return m.push(+r), m
		}
		var Zi = fi.extend({
				initialize: function () {
					this.mergeTicksOptions(), fi.prototype.initialize.call(this)
				},
				update: function () {
					var t = this.options,
						e = t.time || (t.time = {}),
						i = this._adapter = new si._date(t.adapters.date);
					return e.format && console.warn("options.time.format is deprecated and replaced by options.time.parser."), ht.mergeIf(e.displayFormats, i.formats()), fi.prototype.update.apply(this, arguments)
				},
				getRightValue: function (t) {
					return t && void 0 !== t.t && (t = t.t), fi.prototype.getRightValue.call(this, t)
				},
				determineDataLimits: function () {
					var t, e, i, n, r, a, o = this,
						s = o.chart,
						l = o._adapter,
						h = o.options.time,
						u = h.unit || "day",
						d = Yi,
						c = Ni,
						f = [],
						p = [],
						g = [],
						m = s.data.labels || [];
					for (t = 0, i = m.length; t < i; ++t) g.push($i(o, m[t]));
					for (t = 0, i = (s.data.datasets || []).length; t < i; ++t)
						if (s.isDatasetVisible(t))
							if (r = s.data.datasets[t].data, ht.isObject(r[0]))
								for (p[t] = [], e = 0, n = r.length; e < n; ++e) a = $i(o, r[e]), f.push(a), p[t][e] = a;
							else {
								for (e = 0, n = g.length; e < n; ++e) f.push(g[e]);
								p[t] = g.slice(0)
							}
					else p[t] = [];
					g.length && (g = ji(g).sort(Vi), d = Math.min(d, g[0]), c = Math.max(c, g[g.length - 1])), f.length && (f = ji(f).sort(Vi), d = Math.min(d, f[0]), c = Math.max(c, f[f.length - 1])), d = $i(o, h.min) || d, c = $i(o, h.max) || c, d = d === Yi ? +l.startOf(Date.now(), u) : d, c = c === Ni ? +l.endOf(Date.now(), u) + 1 : c, o.min = Math.min(d, c), o.max = Math.max(d + 1, c), o._horizontal = o.isHorizontal(), o._table = [], o._timestamps = {
						data: f,
						datasets: p,
						labels: g
					}
				},
				buildTicks: function () {
					var t, e, i, n, r, a, o, s, l, h, u = this,
						d = u.min,
						c = u.max,
						f = u.options,
						p = f.time,
						g = [],
						m = [];
					switch (f.ticks.source) {
						case "data":
							g = u._timestamps.data;
							break;
						case "labels":
							g = u._timestamps.labels;
							break;
						case "auto":
						default:
							g = Xi(u, d, c, u.getLabelCapacity(d))
					}
					for ("ticks" === f.bounds && g.length && (d = g[0], c = g[g.length - 1]), d = $i(u, p.min) || d, c = $i(u, p.max) || c, t = 0, e = g.length; t < e; ++t) d <= (i = g[t]) && i <= c && m.push(i);
					return u.min = d, u.max = c, u._unit = p.unit || function (t, e, i, n, r) {
							var a, o;
							for (a = Hi.length - 1; a >= Hi.indexOf(i); a--)
								if (o = Hi[a], Ei[o].common && t._adapter.diff(r, n, o) >= e.length) return o;
							return Hi[i ? Hi.indexOf(i) : 0]
						}(u, m, p.minUnit, u.min, u.max), u._majorUnit = qi(u._unit), u._table = function (t, e, i, n) {
							if ("linear" === n || !t.length) return [{
								time: e,
								pos: 0
							}, {
								time: i,
								pos: 1
							}];
							var r, a, o, s, l, h = [],
								u = [e];
							for (r = 0, a = t.length; r < a; ++r) e < (s = t[r]) && s < i && u.push(s);
							for (u.push(i), r = 0, a = u.length; r < a; ++r) l = u[r + 1], o = u[r - 1], s = u[r], void 0 !== o && void 0 !== l && Math.round((l + o) / 2) === s || h.push({
								time: s,
								pos: r / (a - 1)
							});
							return h
						}(u._timestamps.data, d, c, f.distribution), u._offsets = (n = u._table, r = m, h = l = 0, (a = f).offset && r.length && (a.time.min || (o = Ui(n, "time", r[0], "pos"), l = 1 === r.length ? 1 - o : (Ui(n, "time", r[1], "pos") - o) / 2), a.time.max || (s = Ui(n, "time", r[r.length - 1], "pos"), h = 1 === r.length ? s : (s - Ui(n, "time", r[r.length - 2], "pos")) / 2)), {
							start: l,
							end: h
						}), f.ticks.reverse && m.reverse(),
						function (t, e, i) {
							var n, r, a, o, s = [];
							for (n = 0, r = e.length; n < r; ++n) a = e[n], o = !!i && a === +t._adapter.startOf(a, i), s.push({
								value: a,
								major: o
							});
							return s
						}(u, m, u._majorUnit)
				},
				getLabelForIndex: function (t, e) {
					var i = this._adapter,
						n = this.chart.data,
						r = this.options.time,
						a = n.labels && t < n.labels.length ? n.labels[t] : "",
						o = n.datasets[e].data[t];
					return ht.isObject(o) && (a = this.getRightValue(o)), r.tooltipFormat ? i.format(Gi(this, a), r.tooltipFormat) : "string" == typeof a ? a : i.format(Gi(this, a), r.displayFormats.datetime)
				},
				tickFormatFunction: function (t, e, i, n) {
					var r = this._adapter,
						a = this.options,
						o = a.time.displayFormats,
						s = o[this._unit],
						l = this._majorUnit,
						h = o[l],
						u = +r.startOf(t, l),
						d = a.ticks.major,
						c = d.enabled && l && h && t === u,
						f = r.format(t, n || (c ? h : s)),
						p = c ? d : a.ticks.minor,
						g = zi(p.callback, p.userCallback);
					return g ? g(f, e, i) : f
				},
				convertTicksToLabels: function (t) {
					var e, i, n = [];
					for (e = 0, i = t.length; e < i; ++e) n.push(this.tickFormatFunction(t[e].value, e, t));
					return n
				},
				getPixelForOffset: function (t) {
					var e = this,
						i = e.options.ticks.reverse,
						n = e._horizontal ? e.width : e.height,
						r = e._horizontal ? i ? e.right : e.left : i ? e.bottom : e.top,
						a = Ui(e._table, "time", t, "pos"),
						o = n * (e._offsets.start + a) / (e._offsets.start + 1 + e._offsets.end);
					return i ? r - o : r + o
				},
				getPixelForValue: function (t, e, i) {
					var n = null;
					if (void 0 !== e && void 0 !== i && (n = this._timestamps.datasets[i][e]), null === n && (n = $i(this, t)), null !== n) return this.getPixelForOffset(n)
				},
				getPixelForTick: function (t) {
					var e = this.getTicks();
					return 0 <= t && t < e.length ? this.getPixelForOffset(e[t].value) : null
				},
				getValueForPixel: function (t) {
					var e = this,
						i = e._horizontal ? e.width : e.height,
						n = e._horizontal ? e.left : e.top,
						r = (i ? (t - n) / i : 0) * (e._offsets.start + 1 + e._offsets.start) - e._offsets.end,
						a = Ui(e._table, "pos", r, "time");
					return e._adapter._create(a)
				},
				getLabelWidth: function (t) {
					var e = this.options.ticks,
						i = this.ctx.measureText(t).width,
						n = ht.toRadians(e.maxRotation),
						r = Math.cos(n),
						a = Math.sin(n);
					return i * r + zi(e.fontSize, ot.global.defaultFontSize) * a
				},
				getLabelCapacity: function (t) {
					var e = this.options.time.displayFormats.millisecond,
						i = this.tickFormatFunction(t, 0, [], e),
						n = this.getLabelWidth(i),
						r = this.isHorizontal() ? this.width : this.height,
						a = Math.floor(r / n);
					return 0 < a ? a : 1
				}
			}),
			Qi = {
				position: "bottom",
				distribution: "linear",
				bounds: "data",
				adapters: {},
				time: {
					parser: !1,
					format: !1,
					unit: !1,
					round: !1,
					displayFormat: !1,
					isoWeekday: !1,
					minUnit: "millisecond",
					displayFormats: {}
				},
				ticks: {
					autoSkip: !1,
					source: "auto",
					major: {
						enabled: !1
					}
				}
			};
		Zi._defaults = Qi;
		var Ji, tn = {
				category: pi,
				linear: bi,
				logarithmic: Si,
				radialLinear: Bi,
				time: Zi
			},
			en = (function (Qi, t) {
				Qi.exports = function () {
					var t, r;

					function m() {
						return t.apply(null, arguments)
					}

					function s(t) {
						return t instanceof Array || "[object Array]" === Object.prototype.toString.call(t)
					}

					function l(t) {
						return null != t && "[object Object]" === Object.prototype.toString.call(t)
					}

					function a(t) {
						return void 0 === t
					}

					function u(t) {
						return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t)
					}

					function o(t) {
						return t instanceof Date || "[object Date]" === Object.prototype.toString.call(t)
					}

					function h(t, e) {
						var i, n = [];
						for (i = 0; i < t.length; ++i) n.push(e(t[i], i));
						return n
					}

					function v(t, e) {
						return Object.prototype.hasOwnProperty.call(t, e)
					}

					function d(t, e) {
						for (var i in e) v(e, i) && (t[i] = e[i]);
						return v(e, "toString") && (t.toString = e.toString), v(e, "valueOf") && (t.valueOf = e.valueOf), t
					}

					function c(t, e, i, n) {
						return Ae(t, e, i, n, !0).utc()
					}

					function y(t) {
						return null == t._pf && (t._pf = {
							empty: !1,
							unusedTokens: [],
							unusedInput: [],
							overflow: -2,
							charsLeftOver: 0,
							nullInput: !1,
							invalidMonth: null,
							invalidFormat: !1,
							userInvalidated: !1,
							iso: !1,
							parsedDateParts: [],
							meridiem: null,
							rfc2822: !1,
							weekdayMismatch: !1
						}), t._pf
					}

					function f(t) {
						if (null == t._isValid) {
							var e = y(t),
								i = r.call(e.parsedDateParts, function (t) {
									return null != t
								}),
								n = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && i);
							if (t._strict && (n = n && 0 === e.charsLeftOver && 0 === e.unusedTokens.length && void 0 === e.bigHour), null != Object.isFrozen && Object.isFrozen(t)) return n;
							t._isValid = n
						}
						return t._isValid
					}

					function p(t) {
						var e = c(NaN);
						return null != t ? d(y(e), t) : y(e).userInvalidated = !0, e
					}
					r = Array.prototype.some ? Array.prototype.some : function (t) {
						for (var e = Object(this), i = e.length >>> 0, n = 0; n < i; n++)
							if (n in e && t.call(this, e[n], n, e)) return !0;
						return !1
					};
					var g = m.momentProperties = [];

					function x(t, e) {
						var i, n, r;
						if (a(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), a(e._i) || (t._i = e._i), a(e._f) || (t._f = e._f), a(e._l) || (t._l = e._l), a(e._strict) || (t._strict = e._strict), a(e._tzm) || (t._tzm = e._tzm), a(e._isUTC) || (t._isUTC = e._isUTC), a(e._offset) || (t._offset = e._offset), a(e._pf) || (t._pf = y(e)), a(e._locale) || (t._locale = e._locale), 0 < g.length)
							for (i = 0; i < g.length; i++) n = g[i], a(r = e[n]) || (t[n] = r);
						return t
					}
					var e = !1;

					function b(t) {
						x(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === e && (e = !0, m.updateOffset(this), e = !1)
					}

					function _(t) {
						return t instanceof b || null != t && null != t._isAMomentObject
					}

					function w(t) {
						return t < 0 ? Math.ceil(t) || 0 : Math.floor(t)
					}

					function k(t) {
						var e = +t,
							i = 0;
						return 0 !== e && isFinite(e) && (i = w(e)), i
					}

					function M(t, e, i) {
						var n, r = Math.min(t.length, e.length),
							a = Math.abs(t.length - e.length),
							o = 0;
						for (n = 0; n < r; n++)(i && t[n] !== e[n] || !i && k(t[n]) !== k(e[n])) && o++;
						return o + a
					}

					function S(t) {
						!1 === m.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t)
					}

					function i(r, a) {
						var o = !0;
						return d(function () {
							if (null != m.deprecationHandler && m.deprecationHandler(null, r), o) {
								for (var t, e = [], i = 0; i < arguments.length; i++) {
									if (t = "", "object" == typeof arguments[i]) {
										for (var n in t += "\n[" + i + "] ", arguments[0]) t += n + ": " + arguments[0][n] + ", ";
										t = t.slice(0, -2)
									} else t = arguments[i];
									e.push(t)
								}
								S(r + "\nArguments: " + Array.prototype.slice.call(e).join("") + "\n" + (new Error).stack), o = !1
							}
							return a.apply(this, arguments)
						}, a)
					}
					var n, C = {};

					function D(t, e) {
						null != m.deprecationHandler && m.deprecationHandler(t, e), C[t] || (S(e), C[t] = !0)
					}

					function T(t) {
						return t instanceof Function || "[object Function]" === Object.prototype.toString.call(t)
					}

					function P(t, e) {
						var i, n = d({}, t);
						for (i in e) v(e, i) && (l(t[i]) && l(e[i]) ? (n[i] = {}, d(n[i], t[i]), d(n[i], e[i])) : null != e[i] ? n[i] = e[i] : delete n[i]);
						for (i in t) v(t, i) && !v(e, i) && l(t[i]) && (n[i] = d({}, n[i]));
						return n
					}

					function A(t) {
						null != t && this.set(t)
					}
					m.suppressDeprecationWarnings = !1, m.deprecationHandler = null, n = Object.keys ? Object.keys : function (t) {
						var e, i = [];
						for (e in t) v(t, e) && i.push(e);
						return i
					};
					var F = {};

					function I(t, e) {
						var i = t.toLowerCase();
						F[i] = F[i + "s"] = F[e] = t
					}

					function L(t) {
						return "string" == typeof t ? F[t] || F[t.toLowerCase()] : void 0
					}

					function O(t) {
						var e, i, n = {};
						for (i in t) v(t, i) && (e = L(i)) && (n[e] = t[i]);
						return n
					}
					var R = {};

					function B(t, e) {
						R[t] = e
					}

					function W(t) {
						var e = [];
						for (var i in t) e.push({
							unit: i,
							priority: R[i]
						});
						return e.sort(function (t, e) {
							return t.priority - e.priority
						}), e
					}

					function z(t, e, i) {
						var n = "" + Math.abs(t),
							r = e - n.length,
							a = 0 <= t;
						return (a ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + n
					}
					var N = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
						Y = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
						E = {},
						H = {};

					function V(t, e, i, n) {
						var r = n;
						"string" == typeof n && (r = function () {
							return this[n]()
						}), t && (H[t] = r), e && (H[e[0]] = function () {
							return z(r.apply(this, arguments), e[1], e[2])
						}), i && (H[i] = function () {
							return this.localeData().ordinal(r.apply(this, arguments), t)
						})
					}

					function j(t, e) {
						return t.isValid() ? (e = U(e, t.localeData()), E[e] = E[e] || function (n) {
							var t, r, e, a = n.match(N);
							for (t = 0, r = a.length; t < r; t++) H[a[t]] ? a[t] = H[a[t]] : a[t] = (e = a[t]).match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "");
							return function (t) {
								var e, i = "";
								for (e = 0; e < r; e++) i += T(a[e]) ? a[e].call(t, n) : a[e];
								return i
							}
						}(e), E[e](t)) : t.localeData().invalidDate()
					}

					function U(t, e) {
						var i = 5;

						function n(t) {
							return e.longDateFormat(t) || t
						}
						for (Y.lastIndex = 0; 0 <= i && Y.test(t);) t = t.replace(Y, n), Y.lastIndex = 0, i -= 1;
						return t
					}
					var G = /\d/,
						$ = /\d\d/,
						q = /\d{3}/,
						X = /\d{4}/,
						Z = /[+-]?\d{6}/,
						Q = /\d\d?/,
						K = /\d\d\d\d?/,
						J = /\d\d\d\d\d\d?/,
						tt = /\d{1,3}/,
						et = /\d{1,4}/,
						it = /[+-]?\d{1,6}/,
						nt = /\d+/,
						rt = /[+-]?\d+/,
						at = /Z|[+-]\d\d:?\d\d/gi,
						ot = /Z|[+-]\d\d(?::?\d\d)?/gi,
						st = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
						lt = {};

					function ht(t, i, n) {
						lt[t] = T(i) ? i : function (t, e) {
							return t && n ? n : i
						}
					}

					function ut(t, e) {
						return v(lt, t) ? lt[t](e._strict, e._locale) : new RegExp(dt(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (t, e, i, n, r) {
							return e || i || n || r
						})))
					}

					function dt(t) {
						return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
					}
					var ct = {};

					function ft(t, i) {
						var e, n = i;
						for ("string" == typeof t && (t = [t]), u(i) && (n = function (t, e) {
								e[i] = k(t)
							}), e = 0; e < t.length; e++) ct[t[e]] = n
					}

					function pt(t, r) {
						ft(t, function (t, e, i, n) {
							i._w = i._w || {}, r(t, i._w, i, n)
						})
					}
					var gt = 0,
						mt = 1,
						vt = 2,
						yt = 3,
						xt = 4,
						bt = 5,
						_t = 6,
						wt = 7,
						kt = 8;

					function Mt(t) {
						return St(t) ? 366 : 365
					}

					function St(t) {
						return t % 4 == 0 && t % 100 != 0 || t % 400 == 0
					}
					V("Y", 0, 0, function () {
						var t = this.year();
						return t <= 9999 ? "" + t : "+" + t
					}), V(0, ["YY", 2], 0, function () {
						return this.year() % 100
					}), V(0, ["YYYY", 4], 0, "year"), V(0, ["YYYYY", 5], 0, "year"), V(0, ["YYYYYY", 6, !0], 0, "year"), I("year", "y"), B("year", 1), ht("Y", rt), ht("YY", Q, $), ht("YYYY", et, X), ht("YYYYY", it, Z), ht("YYYYYY", it, Z), ft(["YYYYY", "YYYYYY"], gt), ft("YYYY", function (t, e) {
						e[gt] = 2 === t.length ? m.parseTwoDigitYear(t) : k(t)
					}), ft("YY", function (t, e) {
						e[gt] = m.parseTwoDigitYear(t)
					}), ft("Y", function (t, e) {
						e[gt] = parseInt(t, 10)
					}), m.parseTwoDigitYear = function (t) {
						return k(t) + (68 < k(t) ? 1900 : 2e3)
					};
					var Ct, Dt = Tt("FullYear", !0);

					function Tt(e, i) {
						return function (t) {
							return null != t ? (At(this, e, t), m.updateOffset(this, i), this) : Pt(this, e)
						}
					}

					function Pt(t, e) {
						return t.isValid() ? t._d["get" + (t._isUTC ? "UTC" : "") + e]() : NaN
					}

					function At(t, e, i) {
						t.isValid() && !isNaN(i) && ("FullYear" === e && St(t.year()) && 1 === t.month() && 29 === t.date() ? t._d["set" + (t._isUTC ? "UTC" : "") + e](i, t.month(), Ft(i, t.month())) : t._d["set" + (t._isUTC ? "UTC" : "") + e](i))
					}

					function Ft(t, e) {
						if (isNaN(t) || isNaN(e)) return NaN;
						var i, n = (e % (i = 12) + i) % i;
						return t += (e - n) / 12, 1 === n ? St(t) ? 29 : 28 : 31 - n % 7 % 2
					}
					Ct = Array.prototype.indexOf ? Array.prototype.indexOf : function (t) {
						var e;
						for (e = 0; e < this.length; ++e)
							if (this[e] === t) return e;
						return -1
					}, V("M", ["MM", 2], "Mo", function () {
						return this.month() + 1
					}), V("MMM", 0, 0, function (t) {
						return this.localeData().monthsShort(this, t)
					}), V("MMMM", 0, 0, function (t) {
						return this.localeData().months(this, t)
					}), I("month", "M"), B("month", 8), ht("M", Q), ht("MM", Q, $), ht("MMM", function (t, e) {
						return e.monthsShortRegex(t)
					}), ht("MMMM", function (t, e) {
						return e.monthsRegex(t)
					}), ft(["M", "MM"], function (t, e) {
						e[mt] = k(t) - 1
					}), ft(["MMM", "MMMM"], function (t, e, i, n) {
						var r = i._locale.monthsParse(t, n, i._strict);
						null != r ? e[mt] = r : y(i).invalidMonth = t
					});
					var It = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
						Lt = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
						Ot = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");

					function Rt(t, e, i) {
						var n, r, a, o = t.toLocaleLowerCase();
						if (!this._monthsParse)
							for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n = 0; n < 12; ++n) a = c([2e3, n]), this._shortMonthsParse[n] = this.monthsShort(a, "").toLocaleLowerCase(), this._longMonthsParse[n] = this.months(a, "").toLocaleLowerCase();
						return i ? "MMM" === e ? -1 !== (r = Ct.call(this._shortMonthsParse, o)) ? r : null : -1 !== (r = Ct.call(this._longMonthsParse, o)) ? r : null : "MMM" === e ? -1 !== (r = Ct.call(this._shortMonthsParse, o)) ? r : -1 !== (r = Ct.call(this._longMonthsParse, o)) ? r : null : -1 !== (r = Ct.call(this._longMonthsParse, o)) ? r : -1 !== (r = Ct.call(this._shortMonthsParse, o)) ? r : null
					}

					function Bt(t, e) {
						var i;
						if (!t.isValid()) return t;
						if ("string" == typeof e)
							if (/^\d+$/.test(e)) e = k(e);
							else if (!u(e = t.localeData().monthsParse(e))) return t;
						return i = Math.min(t.date(), Ft(t.year(), e)), t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, i), t
					}

					function Wt(t) {
						return null != t ? (Bt(this, t), m.updateOffset(this, !0), this) : Pt(this, "Month")
					}
					var zt = st,
						Nt = st;

					function Yt() {
						function t(t, e) {
							return e.length - t.length
						}
						var e, i, n = [],
							r = [],
							a = [];
						for (e = 0; e < 12; e++) i = c([2e3, e]), n.push(this.monthsShort(i, "")), r.push(this.months(i, "")), a.push(this.months(i, "")), a.push(this.monthsShort(i, ""));
						for (n.sort(t), r.sort(t), a.sort(t), e = 0; e < 12; e++) n[e] = dt(n[e]), r[e] = dt(r[e]);
						for (e = 0; e < 24; e++) a[e] = dt(a[e]);
						this._monthsRegex = new RegExp("^(" + a.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n.join("|") + ")", "i")
					}

					function Et(t) {
						var e;
						if (t < 100 && 0 <= t) {
							var i = Array.prototype.slice.call(arguments);
							i[0] = t + 400, e = new Date(Date.UTC.apply(null, i)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t)
						} else e = new Date(Date.UTC.apply(null, arguments));
						return e
					}

					function Ht(t, e, i) {
						var n = 7 + e - i,
							r = (7 + Et(t, 0, n).getUTCDay() - e) % 7;
						return -r + n - 1
					}

					function Vt(t, e, i, n, r) {
						var a, o, s = (7 + i - n) % 7,
							l = Ht(t, n, r),
							h = 1 + 7 * (e - 1) + s + l;
						return o = h <= 0 ? Mt(a = t - 1) + h : h > Mt(t) ? (a = t + 1, h - Mt(t)) : (a = t, h), {
							year: a,
							dayOfYear: o
						}
					}

					function jt(t, e, i) {
						var n, r, a = Ht(t.year(), e, i),
							o = Math.floor((t.dayOfYear() - a - 1) / 7) + 1;
						return o < 1 ? (r = t.year() - 1, n = o + Ut(r, e, i)) : o > Ut(t.year(), e, i) ? (n = o - Ut(t.year(), e, i), r = t.year() + 1) : (r = t.year(), n = o), {
							week: n,
							year: r
						}
					}

					function Ut(t, e, i) {
						var n = Ht(t, e, i),
							r = Ht(t + 1, e, i);
						return (Mt(t) - n + r) / 7
					}

					function Gt(t, e) {
						return t.slice(e, 7).concat(t.slice(0, e))
					}
					V("w", ["ww", 2], "wo", "week"), V("W", ["WW", 2], "Wo", "isoWeek"), I("week", "w"), I("isoWeek", "W"), B("week", 5), B("isoWeek", 5), ht("w", Q), ht("ww", Q, $), ht("W", Q), ht("WW", Q, $), pt(["w", "ww", "W", "WW"], function (t, e, i, n) {
						e[n.substr(0, 1)] = k(t)
					}), V("d", 0, "do", "day"), V("dd", 0, 0, function (t) {
						return this.localeData().weekdaysMin(this, t)
					}), V("ddd", 0, 0, function (t) {
						return this.localeData().weekdaysShort(this, t)
					}), V("dddd", 0, 0, function (t) {
						return this.localeData().weekdays(this, t)
					}), V("e", 0, 0, "weekday"), V("E", 0, 0, "isoWeekday"), I("day", "d"), I("weekday", "e"), I("isoWeekday", "E"), B("day", 11), B("weekday", 11), B("isoWeekday", 11), ht("d", Q), ht("e", Q), ht("E", Q), ht("dd", function (t, e) {
						return e.weekdaysMinRegex(t)
					}), ht("ddd", function (t, e) {
						return e.weekdaysShortRegex(t)
					}), ht("dddd", function (t, e) {
						return e.weekdaysRegex(t)
					}), pt(["dd", "ddd", "dddd"], function (t, e, i, n) {
						var r = i._locale.weekdaysParse(t, n, i._strict);
						null != r ? e.d = r : y(i).invalidWeekday = t
					}), pt(["d", "e", "E"], function (t, e, i, n) {
						e[n] = k(t)
					});
					var $t = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
						qt = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
						Xt = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");

					function Zt(t, e, i) {
						var n, r, a, o = t.toLocaleLowerCase();
						if (!this._weekdaysParse)
							for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n = 0; n < 7; ++n) a = c([2e3, 1]).day(n), this._minWeekdaysParse[n] = this.weekdaysMin(a, "").toLocaleLowerCase(), this._shortWeekdaysParse[n] = this.weekdaysShort(a, "").toLocaleLowerCase(), this._weekdaysParse[n] = this.weekdays(a, "").toLocaleLowerCase();
						return i ? "dddd" === e ? -1 !== (r = Ct.call(this._weekdaysParse, o)) ? r : null : "ddd" === e ? -1 !== (r = Ct.call(this._shortWeekdaysParse, o)) ? r : null : -1 !== (r = Ct.call(this._minWeekdaysParse, o)) ? r : null : "dddd" === e ? -1 !== (r = Ct.call(this._weekdaysParse, o)) ? r : -1 !== (r = Ct.call(this._shortWeekdaysParse, o)) ? r : -1 !== (r = Ct.call(this._minWeekdaysParse, o)) ? r : null : "ddd" === e ? -1 !== (r = Ct.call(this._shortWeekdaysParse, o)) ? r : -1 !== (r = Ct.call(this._weekdaysParse, o)) ? r : -1 !== (r = Ct.call(this._minWeekdaysParse, o)) ? r : null : -1 !== (r = Ct.call(this._minWeekdaysParse, o)) ? r : -1 !== (r = Ct.call(this._weekdaysParse, o)) ? r : -1 !== (r = Ct.call(this._shortWeekdaysParse, o)) ? r : null
					}
					var Qt = st,
						Kt = st,
						Jt = st;

					function te() {
						function t(t, e) {
							return e.length - t.length
						}
						var e, i, n, r, a, o = [],
							s = [],
							l = [],
							h = [];
						for (e = 0; e < 7; e++) i = c([2e3, 1]).day(e), n = this.weekdaysMin(i, ""), r = this.weekdaysShort(i, ""), a = this.weekdays(i, ""), o.push(n), s.push(r), l.push(a), h.push(n), h.push(r), h.push(a);
						for (o.sort(t), s.sort(t), l.sort(t), h.sort(t), e = 0; e < 7; e++) s[e] = dt(s[e]), l[e] = dt(l[e]), h[e] = dt(h[e]);
						this._weekdaysRegex = new RegExp("^(" + h.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + o.join("|") + ")", "i")
					}

					function ee() {
						return this.hours() % 12 || 12
					}

					function ie(t, e) {
						V(t, 0, 0, function () {
							return this.localeData().meridiem(this.hours(), this.minutes(), e)
						})
					}

					function ne(t, e) {
						return e._meridiemParse
					}
					V("H", ["HH", 2], 0, "hour"), V("h", ["hh", 2], 0, ee), V("k", ["kk", 2], 0, function () {
						return this.hours() || 24
					}), V("hmm", 0, 0, function () {
						return "" + ee.apply(this) + z(this.minutes(), 2)
					}), V("hmmss", 0, 0, function () {
						return "" + ee.apply(this) + z(this.minutes(), 2) + z(this.seconds(), 2)
					}), V("Hmm", 0, 0, function () {
						return "" + this.hours() + z(this.minutes(), 2)
					}), V("Hmmss", 0, 0, function () {
						return "" + this.hours() + z(this.minutes(), 2) + z(this.seconds(), 2)
					}), ie("a", !0), ie("A", !1), I("hour", "h"), B("hour", 13), ht("a", ne), ht("A", ne), ht("H", Q), ht("h", Q), ht("k", Q), ht("HH", Q, $), ht("hh", Q, $), ht("kk", Q, $), ht("hmm", K), ht("hmmss", J), ht("Hmm", K), ht("Hmmss", J), ft(["H", "HH"], yt), ft(["k", "kk"], function (t, e, i) {
						var n = k(t);
						e[yt] = 24 === n ? 0 : n
					}), ft(["a", "A"], function (t, e, i) {
						i._isPm = i._locale.isPM(t), i._meridiem = t
					}), ft(["h", "hh"], function (t, e, i) {
						e[yt] = k(t), y(i).bigHour = !0
					}), ft("hmm", function (t, e, i) {
						var n = t.length - 2;
						e[yt] = k(t.substr(0, n)), e[xt] = k(t.substr(n)), y(i).bigHour = !0
					}), ft("hmmss", function (t, e, i) {
						var n = t.length - 4,
							r = t.length - 2;
						e[yt] = k(t.substr(0, n)), e[xt] = k(t.substr(n, 2)), e[bt] = k(t.substr(r)), y(i).bigHour = !0
					}), ft("Hmm", function (t, e, i) {
						var n = t.length - 2;
						e[yt] = k(t.substr(0, n)), e[xt] = k(t.substr(n))
					}), ft("Hmmss", function (t, e, i) {
						var n = t.length - 4,
							r = t.length - 2;
						e[yt] = k(t.substr(0, n)), e[xt] = k(t.substr(n, 2)), e[bt] = k(t.substr(r))
					});
					var re, ae = Tt("Hours", !0),
						oe = {
							calendar: {
								sameDay: "[Today at] LT",
								nextDay: "[Tomorrow at] LT",
								nextWeek: "dddd [at] LT",
								lastDay: "[Yesterday at] LT",
								lastWeek: "[Last] dddd [at] LT",
								sameElse: "L"
							},
							longDateFormat: {
								LTS: "h:mm:ss A",
								LT: "h:mm A",
								L: "MM/DD/YYYY",
								LL: "MMMM D, YYYY",
								LLL: "MMMM D, YYYY h:mm A",
								LLLL: "dddd, MMMM D, YYYY h:mm A"
							},
							invalidDate: "Invalid date",
							ordinal: "%d",
							dayOfMonthOrdinalParse: /\d{1,2}/,
							relativeTime: {
								future: "in %s",
								past: "%s ago",
								s: "a few seconds",
								ss: "%d seconds",
								m: "a minute",
								mm: "%d minutes",
								h: "an hour",
								hh: "%d hours",
								d: "a day",
								dd: "%d days",
								M: "a month",
								MM: "%d months",
								y: "a year",
								yy: "%d years"
							},
							months: Lt,
							monthsShort: Ot,
							week: {
								dow: 0,
								doy: 6
							},
							weekdays: $t,
							weekdaysMin: Xt,
							weekdaysShort: qt,
							meridiemParse: /[ap]\.?m?\.?/i
						},
						se = {},
						le = {};

					function he(t) {
						return t ? t.toLowerCase().replace("_", "-") : t
					}

					function ue(t) {
						var e = null;
						if (!se[t] && Qi && Qi.exports) try {
							e = re._abbr;
							var i = Ki;
							i("./locale/" + t), de(e)
						} catch (t) {}
						return se[t]
					}

					function de(t, e) {
						var i;
						return t && ((i = a(e) ? fe(t) : ce(t, e)) ? re = i : "undefined" != typeof console && console.warn && console.warn("Locale " + t + " not found. Did you forget to load it?")), re._abbr
					}

					function ce(t, e) {
						if (null === e) return delete se[t], null;
						var i, n = oe;
						if (e.abbr = t, null != se[t]) D("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n = se[t]._config;
						else if (null != e.parentLocale)
							if (null != se[e.parentLocale]) n = se[e.parentLocale]._config;
							else {
								if (null == (i = ue(e.parentLocale))) return le[e.parentLocale] || (le[e.parentLocale] = []), le[e.parentLocale].push({
									name: t,
									config: e
								}), null;
								n = i._config
							} return se[t] = new A(P(n, e)), le[t] && le[t].forEach(function (t) {
							ce(t.name, t.config)
						}), de(t), se[t]
					}

					function fe(t) {
						var e;
						if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return re;
						if (!s(t)) {
							if (e = ue(t)) return e;
							t = [t]
						}
						return function (t) {
							for (var e, i, n, r, a = 0; a < t.length;) {
								for (r = he(t[a]).split("-"), e = r.length, i = (i = he(t[a + 1])) ? i.split("-") : null; 0 < e;) {
									if (n = ue(r.slice(0, e).join("-"))) return n;
									if (i && i.length >= e && M(r, i, !0) >= e - 1) break;
									e--
								}
								a++
							}
							return re
						}(t)
					}

					function pe(t) {
						var e, i = t._a;
						return i && -2 === y(t).overflow && (e = i[mt] < 0 || 11 < i[mt] ? mt : i[vt] < 1 || i[vt] > Ft(i[gt], i[mt]) ? vt : i[yt] < 0 || 24 < i[yt] || 24 === i[yt] && (0 !== i[xt] || 0 !== i[bt] || 0 !== i[_t]) ? yt : i[xt] < 0 || 59 < i[xt] ? xt : i[bt] < 0 || 59 < i[bt] ? bt : i[_t] < 0 || 999 < i[_t] ? _t : -1, y(t)._overflowDayOfYear && (e < gt || vt < e) && (e = vt), y(t)._overflowWeeks && -1 === e && (e = wt), y(t)._overflowWeekday && -1 === e && (e = kt), y(t).overflow = e), t
					}

					function ge(t, e, i) {
						return null != t ? t : null != e ? e : i
					}

					function me(t) {
						var e, i, n, r, a, o, s, l = [];
						if (!t._d) {
							for (o = t, s = void 0, s = new Date(m.now()), n = o._useUTC ? [s.getUTCFullYear(), s.getUTCMonth(), s.getUTCDate()] : [s.getFullYear(), s.getMonth(), s.getDate()], t._w && null == t._a[vt] && null == t._a[mt] && function (t) {
									var e, i, n, r, a, o, s, l;
									if (null != (e = t._w).GG || null != e.W || null != e.E) a = 1, o = 4, i = ge(e.GG, t._a[gt], jt(Fe(), 1, 4).year), n = ge(e.W, 1), ((r = ge(e.E, 1)) < 1 || 7 < r) && (l = !0);
									else {
										a = t._locale._week.dow, o = t._locale._week.doy;
										var h = jt(Fe(), a, o);
										i = ge(e.gg, t._a[gt], h.year), n = ge(e.w, h.week), null != e.d ? ((r = e.d) < 0 || 6 < r) && (l = !0) : null != e.e ? (r = e.e + a, (e.e < 0 || 6 < e.e) && (l = !0)) : r = a
									}
									n < 1 || n > Ut(i, a, o) ? y(t)._overflowWeeks = !0 : null != l ? y(t)._overflowWeekday = !0 : (s = Vt(i, n, r, a, o), t._a[gt] = s.year, t._dayOfYear = s.dayOfYear)
								}(t), null != t._dayOfYear && (a = ge(t._a[gt], n[gt]), (t._dayOfYear > Mt(a) || 0 === t._dayOfYear) && (y(t)._overflowDayOfYear = !0), i = Et(a, 0, t._dayOfYear), t._a[mt] = i.getUTCMonth(), t._a[vt] = i.getUTCDate()), e = 0; e < 3 && null == t._a[e]; ++e) t._a[e] = l[e] = n[e];
							for (; e < 7; e++) t._a[e] = l[e] = null == t._a[e] ? 2 === e ? 1 : 0 : t._a[e];
							24 === t._a[yt] && 0 === t._a[xt] && 0 === t._a[bt] && 0 === t._a[_t] && (t._nextDay = !0, t._a[yt] = 0), t._d = (t._useUTC ? Et : function (t, e, i, n, r, a, o) {
								var s;
								return t < 100 && 0 <= t ? (s = new Date(t + 400, e, i, n, r, a, o), isFinite(s.getFullYear()) && s.setFullYear(t)) : s = new Date(t, e, i, n, r, a, o), s
							}).apply(null, l), r = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[yt] = 24), t._w && void 0 !== t._w.d && t._w.d !== r && (y(t).weekdayMismatch = !0)
						}
					}
					var ve = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
						ye = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
						xe = /Z|[+-]\d\d(?::?\d\d)?/,
						be = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/]],
						_e = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]],
						we = /^\/?Date\((\-?\d+)/i;

					function ke(t) {
						var e, i, n, r, a, o, s = t._i,
							l = ve.exec(s) || ye.exec(s);
						if (l) {
							for (y(t).iso = !0, e = 0, i = be.length; e < i; e++)
								if (be[e][1].exec(l[1])) {
									r = be[e][0], n = !1 !== be[e][2];
									break
								} if (null == r) return void(t._isValid = !1);
							if (l[3]) {
								for (e = 0, i = _e.length; e < i; e++)
									if (_e[e][1].exec(l[3])) {
										a = (l[2] || " ") + _e[e][0];
										break
									} if (null == a) return void(t._isValid = !1)
							}
							if (!n && null != a) return void(t._isValid = !1);
							if (l[4]) {
								if (!xe.exec(l[4])) return void(t._isValid = !1);
								o = "Z"
							}
							t._f = r + (a || "") + (o || ""), Te(t)
						} else t._isValid = !1
					}
					var Me = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

					function Se(t, e, i, n, r, a) {
						var o, s, l = [(o = t, s = parseInt(o, 10), s <= 49 ? 2e3 + s : s <= 999 ? 1900 + s : s), Ot.indexOf(e), parseInt(i, 10), parseInt(n, 10), parseInt(r, 10)];
						return a && l.push(parseInt(a, 10)), l
					}
					var Ce = {
						UT: 0,
						GMT: 0,
						EDT: -240,
						EST: -300,
						CDT: -300,
						CST: -360,
						MDT: -360,
						MST: -420,
						PDT: -420,
						PST: -480
					};

					function De(t) {
						var e = Me.exec(t._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
						if (e) {
							var i = Se(e[4], e[3], e[2], e[5], e[6], e[7]);
							if (! function (t, e, i) {
									if (t) {
										var n = qt.indexOf(t),
											r = new Date(e[0], e[1], e[2]).getDay();
										if (n !== r) return y(i).weekdayMismatch = !0, i._isValid = !1
									}
									return !0
								}(e[1], i, t)) return;
							t._a = i, t._tzm = function (t, e, i) {
								if (t) return Ce[t];
								if (e) return 0;
								var n = parseInt(i, 10),
									r = n % 100,
									a = (n - r) / 100;
								return 60 * a + r
							}(e[8], e[9], e[10]), t._d = Et.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), y(t).rfc2822 = !0
						} else t._isValid = !1
					}

					function Te(t) {
						if (t._f !== m.ISO_8601)
							if (t._f !== m.RFC_2822) {
								t._a = [], y(t).empty = !0;
								var e, i, n, r, a, o = "" + t._i,
									s = o.length,
									l = 0;
								for (n = U(t._f, t._locale).match(N) || [], e = 0; e < n.length; e++) r = n[e], (i = (o.match(ut(r, t)) || [])[0]) && (0 < (a = o.substr(0, o.indexOf(i))).length && y(t).unusedInput.push(a), o = o.slice(o.indexOf(i) + i.length), l += i.length), H[r] ? (i ? y(t).empty = !1 : y(t).unusedTokens.push(r), f = r, g = t, null != (p = i) && v(ct, f) && ct[f](p, g._a, g, f)) : t._strict && !i && y(t).unusedTokens.push(r);
								y(t).charsLeftOver = s - l, 0 < o.length && y(t).unusedInput.push(o), t._a[yt] <= 12 && !0 === y(t).bigHour && 0 < t._a[yt] && (y(t).bigHour = void 0), y(t).parsedDateParts = t._a.slice(0), y(t).meridiem = t._meridiem, t._a[yt] = (h = t._locale, u = t._a[yt], null == (d = t._meridiem) ? u : null != h.meridiemHour ? h.meridiemHour(u, d) : (null != h.isPM && ((c = h.isPM(d)) && u < 12 && (u += 12), c || 12 !== u || (u = 0)), u)), me(t), pe(t)
							} else De(t);
						else ke(t);
						var h, u, d, c, f, p, g
					}

					function Pe(t) {
						var e, i, n = t._i,
							r = t._f;
						return t._locale = t._locale || fe(t._l), null === n || void 0 === r && "" === n ? p({
							nullInput: !0
						}) : ("string" == typeof n && (t._i = n = t._locale.preparse(n)), _(n) ? new b(pe(n)) : (o(n) ? t._d = n : s(r) ? function (t) {
							var e, i, n, r, a;
							if (0 === t._f.length) return y(t).invalidFormat = !0, t._d = new Date(NaN);
							for (r = 0; r < t._f.length; r++) a = 0, e = x({}, t), null != t._useUTC && (e._useUTC = t._useUTC), e._f = t._f[r], Te(e), f(e) && (a += y(e).charsLeftOver, a += 10 * y(e).unusedTokens.length, y(e).score = a, (null == n || a < n) && (n = a, i = e));
							d(t, i || e)
						}(t) : r ? Te(t) : a(i = (e = t)._i) ? e._d = new Date(m.now()) : o(i) ? e._d = new Date(i.valueOf()) : "string" == typeof i ? function (t) {
							var e = we.exec(t._i);
							if (null !== e) return t._d = new Date(+e[1]);
							ke(t), !1 === t._isValid && (delete t._isValid, De(t), !1 === t._isValid && (delete t._isValid, m.createFromInputFallback(t)))
						}(e) : s(i) ? (e._a = h(i.slice(0), function (t) {
							return parseInt(t, 10)
						}), me(e)) : l(i) ? function (t) {
							if (!t._d) {
								var e = O(t._i);
								t._a = h([e.year, e.month, e.day || e.date, e.hour, e.minute, e.second, e.millisecond], function (t) {
									return t && parseInt(t, 10)
								}), me(t)
							}
						}(e) : u(i) ? e._d = new Date(i) : m.createFromInputFallback(e), f(t) || (t._d = null), t))
					}

					function Ae(t, e, i, n, r) {
						var a, o = {};
						return !0 !== i && !1 !== i || (n = i, i = void 0), (l(t) && function (t) {
							if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(t).length;
							var e;
							for (e in t)
								if (t.hasOwnProperty(e)) return !1;
							return !0
						}(t) || s(t) && 0 === t.length) && (t = void 0), o._isAMomentObject = !0, o._useUTC = o._isUTC = r, o._l = i, o._i = t, o._f = e, o._strict = n, (a = new b(pe(Pe(o))))._nextDay && (a.add(1, "d"), a._nextDay = void 0), a
					}

					function Fe(t, e, i, n) {
						return Ae(t, e, i, n, !1)
					}
					m.createFromInputFallback = i("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (t) {
						t._d = new Date(t._i + (t._useUTC ? " UTC" : ""))
					}), m.ISO_8601 = function () {}, m.RFC_2822 = function () {};
					var Ie = i("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
							var t = Fe.apply(null, arguments);
							return this.isValid() && t.isValid() ? t < this ? this : t : p()
						}),
						Le = i("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
							var t = Fe.apply(null, arguments);
							return this.isValid() && t.isValid() ? this < t ? this : t : p()
						});

					function Oe(t, e) {
						var i, n;
						if (1 === e.length && s(e[0]) && (e = e[0]), !e.length) return Fe();
						for (i = e[0], n = 1; n < e.length; ++n) e[n].isValid() && !e[n][t](i) || (i = e[n]);
						return i
					}
					var Re = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

					function Be(t) {
						var e = O(t),
							i = e.year || 0,
							n = e.quarter || 0,
							r = e.month || 0,
							a = e.week || e.isoWeek || 0,
							o = e.day || 0,
							s = e.hour || 0,
							l = e.minute || 0,
							h = e.second || 0,
							u = e.millisecond || 0;
						this._isValid = function (t) {
							for (var e in t)
								if (-1 === Ct.call(Re, e) || null != t[e] && isNaN(t[e])) return !1;
							for (var i = !1, n = 0; n < Re.length; ++n)
								if (t[Re[n]]) {
									if (i) return !1;
									parseFloat(t[Re[n]]) !== k(t[Re[n]]) && (i = !0)
								} return !0
						}(e), this._milliseconds = +u + 1e3 * h + 6e4 * l + 1e3 * s * 60 * 60, this._days = +o + 7 * a, this._months = +r + 3 * n + 12 * i, this._data = {}, this._locale = fe(), this._bubble()
					}

					function We(t) {
						return t instanceof Be
					}

					function ze(t) {
						return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t)
					}

					function Ne(t, i) {
						V(t, 0, 0, function () {
							var t = this.utcOffset(),
								e = "+";
							return t < 0 && (t = -t, e = "-"), e + z(~~(t / 60), 2) + i + z(~~t % 60, 2)
						})
					}
					Ne("Z", ":"), Ne("ZZ", ""), ht("Z", ot), ht("ZZ", ot), ft(["Z", "ZZ"], function (t, e, i) {
						i._useUTC = !0, i._tzm = Ee(ot, t)
					});
					var Ye = /([\+\-]|\d\d)/gi;

					function Ee(t, e) {
						var i = (e || "").match(t);
						if (null === i) return null;
						var n = i[i.length - 1] || [],
							r = (n + "").match(Ye) || ["-", 0, 0],
							a = 60 * r[1] + k(r[2]);
						return 0 === a ? 0 : "+" === r[0] ? a : -a
					}

					function He(t, e) {
						var i, n;
						return e._isUTC ? (i = e.clone(), n = (_(t) || o(t) ? t.valueOf() : Fe(t).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + n), m.updateOffset(i, !1), i) : Fe(t).local()
					}

					function Ve(t) {
						return 15 * -Math.round(t._d.getTimezoneOffset() / 15)
					}

					function je() {
						return !!this.isValid() && this._isUTC && 0 === this._offset
					}
					m.updateOffset = function () {};
					var Ue = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
						Ge = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

					function $e(t, e) {
						var i, n, r, a, o, s, l = t,
							h = null;
						return We(t) ? l = {
							ms: t._milliseconds,
							d: t._days,
							M: t._months
						} : u(t) ? (l = {}, e ? l[e] = t : l.milliseconds = t) : (h = Ue.exec(t)) ? (i = "-" === h[1] ? -1 : 1, l = {
							y: 0,
							d: k(h[vt]) * i,
							h: k(h[yt]) * i,
							m: k(h[xt]) * i,
							s: k(h[bt]) * i,
							ms: k(ze(1e3 * h[_t])) * i
						}) : (h = Ge.exec(t)) ? (i = "-" === h[1] ? -1 : 1, l = {
							y: qe(h[2], i),
							M: qe(h[3], i),
							w: qe(h[4], i),
							d: qe(h[5], i),
							h: qe(h[6], i),
							m: qe(h[7], i),
							s: qe(h[8], i)
						}) : null == l ? l = {} : "object" == typeof l && ("from" in l || "to" in l) && (a = Fe(l.from), o = Fe(l.to), r = a.isValid() && o.isValid() ? (o = He(o, a), a.isBefore(o) ? s = Xe(a, o) : ((s = Xe(o, a)).milliseconds = -s.milliseconds, s.months = -s.months), s) : {
							milliseconds: 0,
							months: 0
						}, (l = {}).ms = r.milliseconds, l.M = r.months), n = new Be(l), We(t) && v(t, "_locale") && (n._locale = t._locale), n
					}

					function qe(t, e) {
						var i = t && parseFloat(t.replace(",", "."));
						return (isNaN(i) ? 0 : i) * e
					}

					function Xe(t, e) {
						var i = {};
						return i.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(i.months, "M").isAfter(e) && --i.months, i.milliseconds = +e - +t.clone().add(i.months, "M"), i
					}

					function Ze(n, r) {
						return function (t, e) {
							var i;
							return null === e || isNaN(+e) || (D(r, "moment()." + r + "(period, number) is deprecated. Please use moment()." + r + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), i = t, t = e, e = i), Qe(this, $e(t = "string" == typeof t ? +t : t, e), n), this
						}
					}

					function Qe(t, e, i, n) {
						var r = e._milliseconds,
							a = ze(e._days),
							o = ze(e._months);
						t.isValid() && (n = null == n || n, o && Bt(t, Pt(t, "Month") + o * i), a && At(t, "Date", Pt(t, "Date") + a * i), r && t._d.setTime(t._d.valueOf() + r * i), n && m.updateOffset(t, a || o))
					}
					$e.fn = Be.prototype, $e.invalid = function () {
						return $e(NaN)
					};
					var Ke = Ze(1, "add"),
						Je = Ze(-1, "subtract");

					function ti(t, e) {
						var i, n, r = 12 * (e.year() - t.year()) + (e.month() - t.month()),
							a = t.clone().add(r, "months");
						return n = e - a < 0 ? (i = t.clone().add(r - 1, "months"), (e - a) / (a - i)) : (i = t.clone().add(r + 1, "months"), (e - a) / (i - a)), -(r + n) || 0
					}

					function ei(t) {
						var e;
						return void 0 === t ? this._locale._abbr : (null != (e = fe(t)) && (this._locale = e), this)
					}
					m.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", m.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
					var ii = i("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (t) {
						return void 0 === t ? this.localeData() : this.locale(t)
					});

					function ni() {
						return this._locale
					}
					var ri = 126227808e5;

					function ai(t, e) {
						return (t % e + e) % e
					}

					function oi(t, e, i) {
						return t < 100 && 0 <= t ? new Date(t + 400, e, i) - ri : new Date(t, e, i).valueOf()
					}

					function si(t, e, i) {
						return t < 100 && 0 <= t ? Date.UTC(t + 400, e, i) - ri : Date.UTC(t, e, i)
					}

					function li(t, e) {
						V(0, [t, t.length], 0, e)
					}

					function hi(t, e, i, n, r) {
						var a;
						return null == t ? jt(this, n, r).year : ((a = Ut(t, n, r)) < e && (e = a), function (t, e, i, n, r) {
							var a = Vt(t, e, i, n, r),
								o = Et(a.year, 0, a.dayOfYear);
							return this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this
						}.call(this, t, e, i, n, r))
					}
					V(0, ["gg", 2], 0, function () {
						return this.weekYear() % 100
					}), V(0, ["GG", 2], 0, function () {
						return this.isoWeekYear() % 100
					}), li("gggg", "weekYear"), li("ggggg", "weekYear"), li("GGGG", "isoWeekYear"), li("GGGGG", "isoWeekYear"), I("weekYear", "gg"), I("isoWeekYear", "GG"), B("weekYear", 1), B("isoWeekYear", 1), ht("G", rt), ht("g", rt), ht("GG", Q, $), ht("gg", Q, $), ht("GGGG", et, X), ht("gggg", et, X), ht("GGGGG", it, Z), ht("ggggg", it, Z), pt(["gggg", "ggggg", "GGGG", "GGGGG"], function (t, e, i, n) {
						e[n.substr(0, 2)] = k(t)
					}), pt(["gg", "GG"], function (t, e, i, n) {
						e[n] = m.parseTwoDigitYear(t)
					}), V("Q", 0, "Qo", "quarter"), I("quarter", "Q"), B("quarter", 7), ht("Q", G), ft("Q", function (t, e) {
						e[mt] = 3 * (k(t) - 1)
					}), V("D", ["DD", 2], "Do", "date"), I("date", "D"), B("date", 9), ht("D", Q), ht("DD", Q, $), ht("Do", function (t, e) {
						return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient
					}), ft(["D", "DD"], vt), ft("Do", function (t, e) {
						e[vt] = k(t.match(Q)[0])
					});
					var ui = Tt("Date", !0);
					V("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), I("dayOfYear", "DDD"), B("dayOfYear", 4), ht("DDD", tt), ht("DDDD", q), ft(["DDD", "DDDD"], function (t, e, i) {
						i._dayOfYear = k(t)
					}), V("m", ["mm", 2], 0, "minute"), I("minute", "m"), B("minute", 14), ht("m", Q), ht("mm", Q, $), ft(["m", "mm"], xt);
					var di = Tt("Minutes", !1);
					V("s", ["ss", 2], 0, "second"), I("second", "s"), B("second", 15), ht("s", Q), ht("ss", Q, $), ft(["s", "ss"], bt);
					var ci, fi = Tt("Seconds", !1);
					for (V("S", 0, 0, function () {
							return ~~(this.millisecond() / 100)
						}), V(0, ["SS", 2], 0, function () {
							return ~~(this.millisecond() / 10)
						}), V(0, ["SSS", 3], 0, "millisecond"), V(0, ["SSSS", 4], 0, function () {
							return 10 * this.millisecond()
						}), V(0, ["SSSSS", 5], 0, function () {
							return 100 * this.millisecond()
						}), V(0, ["SSSSSS", 6], 0, function () {
							return 1e3 * this.millisecond()
						}), V(0, ["SSSSSSS", 7], 0, function () {
							return 1e4 * this.millisecond()
						}), V(0, ["SSSSSSSS", 8], 0, function () {
							return 1e5 * this.millisecond()
						}), V(0, ["SSSSSSSSS", 9], 0, function () {
							return 1e6 * this.millisecond()
						}), I("millisecond", "ms"), B("millisecond", 16), ht("S", tt, G), ht("SS", tt, $), ht("SSS", tt, q), ci = "SSSS"; ci.length <= 9; ci += "S") ht(ci, nt);

					function pi(t, e) {
						e[_t] = k(1e3 * ("0." + t))
					}
					for (ci = "S"; ci.length <= 9; ci += "S") ft(ci, pi);
					var gi = Tt("Milliseconds", !1);
					V("z", 0, 0, "zoneAbbr"), V("zz", 0, 0, "zoneName");
					var mi = b.prototype;

					function vi(t) {
						return t
					}
					mi.add = Ke, mi.calendar = function (t, e) {
						var i = t || Fe(),
							n = He(i, this).startOf("day"),
							r = m.calendarFormat(this, n) || "sameElse",
							a = e && (T(e[r]) ? e[r].call(this, i) : e[r]);
						return this.format(a || this.localeData().calendar(r, this, Fe(i)))
					}, mi.clone = function () {
						return new b(this)
					}, mi.diff = function (t, e, i) {
						var n, r, a;
						if (!this.isValid()) return NaN;
						if (!(n = He(t, this)).isValid()) return NaN;
						switch (r = 6e4 * (n.utcOffset() - this.utcOffset()), e = L(e)) {
							case "year":
								a = ti(this, n) / 12;
								break;
							case "month":
								a = ti(this, n);
								break;
							case "quarter":
								a = ti(this, n) / 3;
								break;
							case "second":
								a = (this - n) / 1e3;
								break;
							case "minute":
								a = (this - n) / 6e4;
								break;
							case "hour":
								a = (this - n) / 36e5;
								break;
							case "day":
								a = (this - n - r) / 864e5;
								break;
							case "week":
								a = (this - n - r) / 6048e5;
								break;
							default:
								a = this - n
						}
						return i ? a : w(a)
					}, mi.endOf = function (t) {
						var e;
						if (void 0 === (t = L(t)) || "millisecond" === t || !this.isValid()) return this;
						var i = this._isUTC ? si : oi;
						switch (t) {
							case "year":
								e = i(this.year() + 1, 0, 1) - 1;
								break;
							case "quarter":
								e = i(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
								break;
							case "month":
								e = i(this.year(), this.month() + 1, 1) - 1;
								break;
							case "week":
								e = i(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
								break;
							case "isoWeek":
								e = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
								break;
							case "day":
							case "date":
								e = i(this.year(), this.month(), this.date() + 1) - 1;
								break;
							case "hour":
								e = this._d.valueOf(), e += 36e5 - ai(e + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5) - 1;
								break;
							case "minute":
								e = this._d.valueOf(), e += 6e4 - ai(e, 6e4) - 1;
								break;
							case "second":
								e = this._d.valueOf(), e += 1e3 - ai(e, 1e3) - 1
						}
						return this._d.setTime(e), m.updateOffset(this, !0), this
					}, mi.format = function (t) {
						t || (t = this.isUtc() ? m.defaultFormatUtc : m.defaultFormat);
						var e = j(this, t);
						return this.localeData().postformat(e)
					}, mi.from = function (t, e) {
						return this.isValid() && (_(t) && t.isValid() || Fe(t).isValid()) ? $e({
							to: this,
							from: t
						}).locale(this.locale()).humanize(!e) : this.localeData().invalidDate()
					}, mi.fromNow = function (t) {
						return this.from(Fe(), t)
					}, mi.to = function (t, e) {
						return this.isValid() && (_(t) && t.isValid() || Fe(t).isValid()) ? $e({
							from: this,
							to: t
						}).locale(this.locale()).humanize(!e) : this.localeData().invalidDate()
					}, mi.toNow = function (t) {
						return this.to(Fe(), t)
					}, mi.get = function (t) {
						return T(this[t = L(t)]) ? this[t]() : this
					}, mi.invalidAt = function () {
						return y(this).overflow
					}, mi.isAfter = function (t, e) {
						var i = _(t) ? t : Fe(t);
						return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = L(e) || "millisecond") ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(e).valueOf())
					}, mi.isBefore = function (t, e) {
						var i = _(t) ? t : Fe(t);
						return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = L(e) || "millisecond") ? this.valueOf() < i.valueOf() : this.clone().endOf(e).valueOf() < i.valueOf())
					}, mi.isBetween = function (t, e, i, n) {
						var r = _(t) ? t : Fe(t),
							a = _(e) ? e : Fe(e);
						return !!(this.isValid() && r.isValid() && a.isValid()) && ("(" === (n = n || "()")[0] ? this.isAfter(r, i) : !this.isBefore(r, i)) && (")" === n[1] ? this.isBefore(a, i) : !this.isAfter(a, i))
					}, mi.isSame = function (t, e) {
						var i, n = _(t) ? t : Fe(t);
						return !(!this.isValid() || !n.isValid()) && ("millisecond" === (e = L(e) || "millisecond") ? this.valueOf() === n.valueOf() : (i = n.valueOf(), this.clone().startOf(e).valueOf() <= i && i <= this.clone().endOf(e).valueOf()))
					}, mi.isSameOrAfter = function (t, e) {
						return this.isSame(t, e) || this.isAfter(t, e)
					}, mi.isSameOrBefore = function (t, e) {
						return this.isSame(t, e) || this.isBefore(t, e)
					}, mi.isValid = function () {
						return f(this)
					}, mi.lang = ii, mi.locale = ei, mi.localeData = ni, mi.max = Le, mi.min = Ie, mi.parsingFlags = function () {
						return d({}, y(this))
					}, mi.set = function (t, e) {
						if ("object" == typeof t)
							for (var i = W(t = O(t)), n = 0; n < i.length; n++) this[i[n].unit](t[i[n].unit]);
						else if (T(this[t = L(t)])) return this[t](e);
						return this
					}, mi.startOf = function (t) {
						var e;
						if (void 0 === (t = L(t)) || "millisecond" === t || !this.isValid()) return this;
						var i = this._isUTC ? si : oi;
						switch (t) {
							case "year":
								e = i(this.year(), 0, 1);
								break;
							case "quarter":
								e = i(this.year(), this.month() - this.month() % 3, 1);
								break;
							case "month":
								e = i(this.year(), this.month(), 1);
								break;
							case "week":
								e = i(this.year(), this.month(), this.date() - this.weekday());
								break;
							case "isoWeek":
								e = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
								break;
							case "day":
							case "date":
								e = i(this.year(), this.month(), this.date());
								break;
							case "hour":
								e = this._d.valueOf(), e -= ai(e + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5);
								break;
							case "minute":
								e = this._d.valueOf(), e -= ai(e, 6e4);
								break;
							case "second":
								e = this._d.valueOf(), e -= ai(e, 1e3)
						}
						return this._d.setTime(e), m.updateOffset(this, !0), this
					}, mi.subtract = Je, mi.toArray = function () {
						return [this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()]
					}, mi.toObject = function () {
						return {
							years: this.year(),
							months: this.month(),
							date: this.date(),
							hours: this.hours(),
							minutes: this.minutes(),
							seconds: this.seconds(),
							milliseconds: this.milliseconds()
						}
					}, mi.toDate = function () {
						return new Date(this.valueOf())
					}, mi.toISOString = function (t) {
						if (!this.isValid()) return null;
						var e = !0 !== t,
							i = e ? this.clone().utc() : this;
						return i.year() < 0 || 9999 < i.year() ? j(i, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : T(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", j(i, "Z")) : j(i, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
					}, mi.inspect = function () {
						if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
						var t = "moment",
							e = "";
						this.isLocal() || (t = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", e = "Z");
						var i = "[" + t + '("]',
							n = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
							r = e + '[")]';
						return this.format(i + n + "-MM-DD[T]HH:mm:ss.SSS" + r)
					}, mi.toJSON = function () {
						return this.isValid() ? this.toISOString() : null
					}, mi.toString = function () {
						return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
					}, mi.unix = function () {
						return Math.floor(this.valueOf() / 1e3)
					}, mi.valueOf = function () {
						return this._d.valueOf() - 6e4 * (this._offset || 0)
					}, mi.creationData = function () {
						return {
							input: this._i,
							format: this._f,
							locale: this._locale,
							isUTC: this._isUTC,
							strict: this._strict
						}
					}, mi.year = Dt, mi.isLeapYear = function () {
						return St(this.year())
					}, mi.weekYear = function (t) {
						return hi.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
					}, mi.isoWeekYear = function (t) {
						return hi.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4)
					}, mi.quarter = mi.quarters = function (t) {
						return null == t ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3)
					}, mi.month = Wt, mi.daysInMonth = function () {
						return Ft(this.year(), this.month())
					}, mi.week = mi.weeks = function (t) {
						var e = this.localeData().week(this);
						return null == t ? e : this.add(7 * (t - e), "d")
					}, mi.isoWeek = mi.isoWeeks = function (t) {
						var e = jt(this, 1, 4).week;
						return null == t ? e : this.add(7 * (t - e), "d")
					}, mi.weeksInYear = function () {
						var t = this.localeData()._week;
						return Ut(this.year(), t.dow, t.doy)
					}, mi.isoWeeksInYear = function () {
						return Ut(this.year(), 1, 4)
					}, mi.date = ui, mi.day = mi.days = function (t) {
						if (!this.isValid()) return null != t ? this : NaN;
						var e, i, n = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
						return null != t ? (e = t, i = this.localeData(), t = "string" == typeof e ? isNaN(e) ? "number" != typeof (e = i.weekdaysParse(e)) ? null : e : parseInt(e, 10) : e, this.add(t - n, "d")) : n
					}, mi.weekday = function (t) {
						if (!this.isValid()) return null != t ? this : NaN;
						var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
						return null == t ? e : this.add(t - e, "d")
					}, mi.isoWeekday = function (t) {
						if (!this.isValid()) return null != t ? this : NaN;
						if (null == t) return this.day() || 7;
						var e, i, n = (e = t, i = this.localeData(), "string" != typeof e ? isNaN(e) ? null : e : i.weekdaysParse(e) % 7 || 7);
						return this.day(this.day() % 7 ? n : n - 7)
					}, mi.dayOfYear = function (t) {
						var e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
						return null == t ? e : this.add(t - e, "d")
					}, mi.hour = mi.hours = ae, mi.minute = mi.minutes = di, mi.second = mi.seconds = fi, mi.millisecond = mi.milliseconds = gi, mi.utcOffset = function (t, e, i) {
						var n, r = this._offset || 0;
						if (!this.isValid()) return null != t ? this : NaN;
						if (null == t) return this._isUTC ? r : Ve(this);
						if ("string" == typeof t) {
							if (null === (t = Ee(ot, t))) return this
						} else Math.abs(t) < 16 && !i && (t *= 60);
						return !this._isUTC && e && (n = Ve(this)), this._offset = t, this._isUTC = !0, null != n && this.add(n, "m"), r !== t && (!e || this._changeInProgress ? Qe(this, $e(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, m.updateOffset(this, !0), this._changeInProgress = null)), this
					}, mi.utc = function (t) {
						return this.utcOffset(0, t)
					}, mi.local = function (t) {
						return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(Ve(this), "m")), this
					}, mi.parseZone = function () {
						if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
						else if ("string" == typeof this._i) {
							var t = Ee(at, this._i);
							null != t ? this.utcOffset(t) : this.utcOffset(0, !0)
						}
						return this
					}, mi.hasAlignedHourOffset = function (t) {
						return !!this.isValid() && (t = t ? Fe(t).utcOffset() : 0, (this.utcOffset() - t) % 60 == 0)
					}, mi.isDST = function () {
						return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
					}, mi.isLocal = function () {
						return !!this.isValid() && !this._isUTC
					}, mi.isUtcOffset = function () {
						return !!this.isValid() && this._isUTC
					}, mi.isUtc = je, mi.isUTC = je, mi.zoneAbbr = function () {
						return this._isUTC ? "UTC" : ""
					}, mi.zoneName = function () {
						return this._isUTC ? "Coordinated Universal Time" : ""
					}, mi.dates = i("dates accessor is deprecated. Use date instead.", ui), mi.months = i("months accessor is deprecated. Use month instead", Wt), mi.years = i("years accessor is deprecated. Use year instead", Dt), mi.zone = i("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (t, e) {
						return null != t ? ("string" != typeof t && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset()
					}), mi.isDSTShifted = i("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () {
						if (!a(this._isDSTShifted)) return this._isDSTShifted;
						var t = {};
						if (x(t, this), (t = Pe(t))._a) {
							var e = t._isUTC ? c(t._a) : Fe(t._a);
							this._isDSTShifted = this.isValid() && 0 < M(t._a, e.toArray())
						} else this._isDSTShifted = !1;
						return this._isDSTShifted
					});
					var yi = A.prototype;

					function xi(t, e, i, n) {
						var r = fe(),
							a = c().set(n, e);
						return r[i](a, t)
					}

					function bi(t, e, i) {
						if (u(t) && (e = t, t = void 0), t = t || "", null != e) return xi(t, e, i, "month");
						var n, r = [];
						for (n = 0; n < 12; n++) r[n] = xi(t, n, i, "month");
						return r
					}

					function _i(t, e, i, n) {
						"boolean" == typeof t ? u(e) && (i = e, e = void 0) : (e = t, t = !1, u(i = e) && (i = e, e = void 0)), e = e || "";
						var r, a = fe(),
							o = t ? a._week.dow : 0;
						if (null != i) return xi(e, (i + o) % 7, n, "day");
						var s = [];
						for (r = 0; r < 7; r++) s[r] = xi(e, (r + o) % 7, n, "day");
						return s
					}
					yi.calendar = function (t, e, i) {
						var n = this._calendar[t] || this._calendar.sameElse;
						return T(n) ? n.call(e, i) : n
					}, yi.longDateFormat = function (t) {
						var e = this._longDateFormat[t],
							i = this._longDateFormat[t.toUpperCase()];
						return !e && i ? (this._longDateFormat[t] = i.replace(/MMMM|MM|DD|dddd/g, function (t) {
							return t.slice(1)
						}), this._longDateFormat[t]) : e
					}, yi.invalidDate = function () {
						return this._invalidDate
					}, yi.ordinal = function (t) {
						return this._ordinal.replace("%d", t)
					}, yi.preparse = vi, yi.postformat = vi, yi.relativeTime = function (t, e, i, n) {
						var r = this._relativeTime[i];
						return T(r) ? r(t, e, i, n) : r.replace(/%d/i, t)
					}, yi.pastFuture = function (t, e) {
						var i = this._relativeTime[0 < t ? "future" : "past"];
						return T(i) ? i(e) : i.replace(/%s/i, e)
					}, yi.set = function (t) {
						var e, i;
						for (i in t) T(e = t[i]) ? this[i] = e : this["_" + i] = e;
						this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
					}, yi.months = function (t, e) {
						return t ? s(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || It).test(e) ? "format" : "standalone"][t.month()] : s(this._months) ? this._months : this._months.standalone
					}, yi.monthsShort = function (t, e) {
						return t ? s(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[It.test(e) ? "format" : "standalone"][t.month()] : s(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
					}, yi.monthsParse = function (t, e, i) {
						var n, r, a;
						if (this._monthsParseExact) return Rt.call(this, t, e, i);
						for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; n < 12; n++) {
							if (r = c([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp("^" + this.months(r, "").replace(".", "") + "$", "i"), this._shortMonthsParse[n] = new RegExp("^" + this.monthsShort(r, "").replace(".", "") + "$", "i")), i || this._monthsParse[n] || (a = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[n] = new RegExp(a.replace(".", ""), "i")), i && "MMMM" === e && this._longMonthsParse[n].test(t)) return n;
							if (i && "MMM" === e && this._shortMonthsParse[n].test(t)) return n;
							if (!i && this._monthsParse[n].test(t)) return n
						}
					}, yi.monthsRegex = function (t) {
						return this._monthsParseExact ? (v(this, "_monthsRegex") || Yt.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (v(this, "_monthsRegex") || (this._monthsRegex = Nt), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex)
					}, yi.monthsShortRegex = function (t) {
						return this._monthsParseExact ? (v(this, "_monthsRegex") || Yt.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (v(this, "_monthsShortRegex") || (this._monthsShortRegex = zt), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex)
					}, yi.week = function (t) {
						return jt(t, this._week.dow, this._week.doy).week
					}, yi.firstDayOfYear = function () {
						return this._week.doy
					}, yi.firstDayOfWeek = function () {
						return this._week.dow
					}, yi.weekdays = function (t, e) {
						var i = s(this._weekdays) ? this._weekdays : this._weekdays[t && !0 !== t && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
						return !0 === t ? Gt(i, this._week.dow) : t ? i[t.day()] : i
					}, yi.weekdaysMin = function (t) {
						return !0 === t ? Gt(this._weekdaysMin, this._week.dow) : t ? this._weekdaysMin[t.day()] : this._weekdaysMin
					}, yi.weekdaysShort = function (t) {
						return !0 === t ? Gt(this._weekdaysShort, this._week.dow) : t ? this._weekdaysShort[t.day()] : this._weekdaysShort
					}, yi.weekdaysParse = function (t, e, i) {
						var n, r, a;
						if (this._weekdaysParseExact) return Zt.call(this, t, e, i);
						for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n = 0; n < 7; n++) {
							if (r = c([2e3, 1]).day(n), i && !this._fullWeekdaysParse[n] && (this._fullWeekdaysParse[n] = new RegExp("^" + this.weekdays(r, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[n] = new RegExp("^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[n] = new RegExp("^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[n] || (a = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[n] = new RegExp(a.replace(".", ""), "i")), i && "dddd" === e && this._fullWeekdaysParse[n].test(t)) return n;
							if (i && "ddd" === e && this._shortWeekdaysParse[n].test(t)) return n;
							if (i && "dd" === e && this._minWeekdaysParse[n].test(t)) return n;
							if (!i && this._weekdaysParse[n].test(t)) return n
						}
					}, yi.weekdaysRegex = function (t) {
						return this._weekdaysParseExact ? (v(this, "_weekdaysRegex") || te.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (v(this, "_weekdaysRegex") || (this._weekdaysRegex = Qt), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex)
					}, yi.weekdaysShortRegex = function (t) {
						return this._weekdaysParseExact ? (v(this, "_weekdaysRegex") || te.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (v(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Kt), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
					}, yi.weekdaysMinRegex = function (t) {
						return this._weekdaysParseExact ? (v(this, "_weekdaysRegex") || te.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (v(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Jt), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
					}, yi.isPM = function (t) {
						return "p" === (t + "").toLowerCase().charAt(0)
					}, yi.meridiem = function (t, e, i) {
						return 11 < t ? i ? "pm" : "PM" : i ? "am" : "AM"
					}, de("en", {
						dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
						ordinal: function (t) {
							var e = t % 10,
								i = 1 === k(t % 100 / 10) ? "th" : 1 === e ? "st" : 2 === e ? "nd" : 3 === e ? "rd" : "th";
							return t + i
						}
					}), m.lang = i("moment.lang is deprecated. Use moment.locale instead.", de), m.langData = i("moment.langData is deprecated. Use moment.localeData instead.", fe);
					var wi = Math.abs;

					function ki(t, e, i, n) {
						var r = $e(e, i);
						return t._milliseconds += n * r._milliseconds, t._days += n * r._days, t._months += n * r._months, t._bubble()
					}

					function Mi(t) {
						return t < 0 ? Math.floor(t) : Math.ceil(t)
					}

					function Si(t) {
						return 4800 * t / 146097
					}

					function Ci(t) {
						return 146097 * t / 4800
					}

					function Di(t) {
						return function () {
							return this.as(t)
						}
					}
					var Ti = Di("ms"),
						Pi = Di("s"),
						Ai = Di("m"),
						Fi = Di("h"),
						Ii = Di("d"),
						Li = Di("w"),
						Oi = Di("M"),
						Ri = Di("Q"),
						Bi = Di("y");

					function Wi(t) {
						return function () {
							return this.isValid() ? this._data[t] : NaN
						}
					}
					var zi = Wi("milliseconds"),
						Ni = Wi("seconds"),
						Yi = Wi("minutes"),
						Ei = Wi("hours"),
						Hi = Wi("days"),
						Vi = Wi("months"),
						ji = Wi("years"),
						Ui = Math.round,
						Gi = {
							ss: 44,
							s: 45,
							m: 45,
							h: 22,
							d: 26,
							M: 11
						},
						$i = Math.abs;

					function qi(t) {
						return (0 < t) - (t < 0) || +t
					}

					function Xi() {
						if (!this.isValid()) return this.localeData().invalidDate();
						var t, e, i = $i(this._milliseconds) / 1e3,
							n = $i(this._days),
							r = $i(this._months);
						t = w(i / 60), e = w(t / 60), i %= 60, t %= 60;
						var a = w(r / 12),
							o = r %= 12,
							s = n,
							l = e,
							h = t,
							u = i ? i.toFixed(3).replace(/\.?0+$/, "") : "",
							d = this.asSeconds();
						if (!d) return "P0D";
						var c = d < 0 ? "-" : "",
							f = qi(this._months) !== qi(d) ? "-" : "",
							p = qi(this._days) !== qi(d) ? "-" : "",
							g = qi(this._milliseconds) !== qi(d) ? "-" : "";
						return c + "P" + (a ? f + a + "Y" : "") + (o ? f + o + "M" : "") + (s ? p + s + "D" : "") + (l || h || u ? "T" : "") + (l ? g + l + "H" : "") + (h ? g + h + "M" : "") + (u ? g + u + "S" : "")
					}
					var Zi = Be.prototype;
					return Zi.isValid = function () {
						return this._isValid
					}, Zi.abs = function () {
						var t = this._data;
						return this._milliseconds = wi(this._milliseconds), this._days = wi(this._days), this._months = wi(this._months), t.milliseconds = wi(t.milliseconds), t.seconds = wi(t.seconds), t.minutes = wi(t.minutes), t.hours = wi(t.hours), t.months = wi(t.months), t.years = wi(t.years), this
					}, Zi.add = function (t, e) {
						return ki(this, t, e, 1)
					}, Zi.subtract = function (t, e) {
						return ki(this, t, e, -1)
					}, Zi.as = function (t) {
						if (!this.isValid()) return NaN;
						var e, i, n = this._milliseconds;
						if ("month" === (t = L(t)) || "quarter" === t || "year" === t) switch (e = this._days + n / 864e5, i = this._months + Si(e), t) {
							case "month":
								return i;
							case "quarter":
								return i / 3;
							case "year":
								return i / 12
						} else switch (e = this._days + Math.round(Ci(this._months)), t) {
							case "week":
								return e / 7 + n / 6048e5;
							case "day":
								return e + n / 864e5;
							case "hour":
								return 24 * e + n / 36e5;
							case "minute":
								return 1440 * e + n / 6e4;
							case "second":
								return 86400 * e + n / 1e3;
							case "millisecond":
								return Math.floor(864e5 * e) + n;
							default:
								throw new Error("Unknown unit " + t)
						}
					}, Zi.asMilliseconds = Ti, Zi.asSeconds = Pi, Zi.asMinutes = Ai, Zi.asHours = Fi, Zi.asDays = Ii, Zi.asWeeks = Li, Zi.asMonths = Oi, Zi.asQuarters = Ri, Zi.asYears = Bi, Zi.valueOf = function () {
						return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * k(this._months / 12) : NaN
					}, Zi._bubble = function () {
						var t, e, i, n, r, a = this._milliseconds,
							o = this._days,
							s = this._months,
							l = this._data;
						return 0 <= a && 0 <= o && 0 <= s || a <= 0 && o <= 0 && s <= 0 || (a += 864e5 * Mi(Ci(s) + o), s = o = 0), l.milliseconds = a % 1e3, t = w(a / 1e3), l.seconds = t % 60, e = w(t / 60), l.minutes = e % 60, i = w(e / 60), l.hours = i % 24, o += w(i / 24), r = w(Si(o)), s += r, o -= Mi(Ci(r)), n = w(s / 12), s %= 12, l.days = o, l.months = s, l.years = n, this
					}, Zi.clone = function () {
						return $e(this)
					}, Zi.get = function (t) {
						return t = L(t), this.isValid() ? this[t + "s"]() : NaN
					}, Zi.milliseconds = zi, Zi.seconds = Ni, Zi.minutes = Yi, Zi.hours = Ei, Zi.days = Hi, Zi.weeks = function () {
						return w(this.days() / 7)
					}, Zi.months = Vi, Zi.years = ji, Zi.humanize = function (t) {
						if (!this.isValid()) return this.localeData().invalidDate();
						var e, i, n, r, a, o, s, l, h, u, d, c = this.localeData(),
							f = (i = !t, n = c, r = $e(e = this).abs(), a = Ui(r.as("s")), o = Ui(r.as("m")), s = Ui(r.as("h")), l = Ui(r.as("d")), h = Ui(r.as("M")), u = Ui(r.as("y")), (d = a <= Gi.ss && ["s", a] || a < Gi.s && ["ss", a] || o <= 1 && ["m"] || o < Gi.m && ["mm", o] || s <= 1 && ["h"] || s < Gi.h && ["hh", s] || l <= 1 && ["d"] || l < Gi.d && ["dd", l] || h <= 1 && ["M"] || h < Gi.M && ["MM", h] || u <= 1 && ["y"] || ["yy", u])[2] = i, d[3] = 0 < +e, d[4] = n, function (t, e, i, n, r) {
								return r.relativeTime(e || 1, !!i, t, n)
							}.apply(null, d));
						return t && (f = c.pastFuture(+this, f)), c.postformat(f)
					}, Zi.toISOString = Xi, Zi.toString = Xi, Zi.toJSON = Xi, Zi.locale = ei, Zi.localeData = ni, Zi.toIsoString = i("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Xi), Zi.lang = ii, V("X", 0, 0, "unix"), V("x", 0, 0, "valueOf"), ht("x", rt), ht("X", /[+-]?\d+(\.\d{1,3})?/), ft("X", function (t, e, i) {
						i._d = new Date(1e3 * parseFloat(t, 10))
					}), ft("x", function (t, e, i) {
						i._d = new Date(k(t))
					}), m.version = "2.24.0", t = Fe, m.fn = mi, m.min = function () {
						return Oe("isBefore", [].slice.call(arguments, 0))
					}, m.max = function () {
						return Oe("isAfter", [].slice.call(arguments, 0))
					}, m.now = function () {
						return Date.now ? Date.now() : +new Date
					}, m.utc = c, m.unix = function (t) {
						return Fe(1e3 * t)
					}, m.months = function (t, e) {
						return bi(t, e, "months")
					}, m.isDate = o, m.locale = de, m.invalid = p, m.duration = $e, m.isMoment = _, m.weekdays = function (t, e, i) {
						return _i(t, e, i, "weekdays")
					}, m.parseZone = function () {
						return Fe.apply(null, arguments).parseZone()
					}, m.localeData = fe, m.isDuration = We, m.monthsShort = function (t, e) {
						return bi(t, e, "monthsShort")
					}, m.weekdaysMin = function (t, e, i) {
						return _i(t, e, i, "weekdaysMin")
					}, m.defineLocale = ce, m.updateLocale = function (t, e) {
						if (null != e) {
							var i, n, r = oe;
							null != (n = ue(t)) && (r = n._config), e = P(r, e), (i = new A(e)).parentLocale = se[t], se[t] = i, de(t)
						} else null != se[t] && (null != se[t].parentLocale ? se[t] = se[t].parentLocale : null != se[t] && delete se[t]);
						return se[t]
					}, m.locales = function () {
						return n(se)
					}, m.weekdaysShort = function (t, e, i) {
						return _i(t, e, i, "weekdaysShort")
					}, m.normalizeUnits = L, m.relativeTimeRounding = function (t) {
						return void 0 !== t ? "function" == typeof t && (Ui = t, !0) : Ui
					}, m.relativeTimeThreshold = function (t, e) {
						return void 0 !== Gi[t] && (void 0 === e ? Gi[t] : (Gi[t] = e, "s" === t && (Gi.ss = e - 1), !0))
					}, m.calendarFormat = function (t, e) {
						var i = t.diff(e, "days", !0);
						return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse"
					}, m.prototype = mi, m.HTML5_FMT = {
						DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
						DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
						DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
						DATE: "YYYY-MM-DD",
						TIME: "HH:mm",
						TIME_SECONDS: "HH:mm:ss",
						TIME_MS: "HH:mm:ss.SSS",
						WEEK: "GGGG-[W]WW",
						MONTH: "YYYY-MM"
					}, m
				}()
			}(Ji = {
				exports: {}
			}, Ji.exports), Ji.exports),
			nn = {
				datetime: "MMM D, YYYY, h:mm:ss a",
				millisecond: "h:mm:ss.SSS a",
				second: "h:mm:ss a",
				minute: "h:mm a",
				hour: "hA",
				day: "MMM D",
				week: "ll",
				month: "MMM YYYY",
				quarter: "[Q]Q - YYYY",
				year: "YYYY"
			};
		si._date.override("function" == typeof en ? {
			_id: "moment",
			formats: function () {
				return nn
			},
			parse: function (t, e) {
				return "string" == typeof t && "string" == typeof e ? t = en(t, e) : t instanceof en || (t = en(t)), t.isValid() ? t.valueOf() : null
			},
			format: function (t, e) {
				return en(t).format(e)
			},
			add: function (t, e, i) {
				return en(t).add(e, i).valueOf()
			},
			diff: function (t, e, i) {
				return en.duration(en(t).diff(en(e))).as(i)
			},
			startOf: function (t, e, i) {
				return t = en(t), "isoWeek" === e ? t.isoWeekday(i).valueOf() : t.startOf(e).valueOf()
			},
			endOf: function (t, e) {
				return en(t).endOf(e).valueOf()
			},
			_create: function (t) {
				return en(t)
			}
		} : {}), ot._set("global", {
			plugins: {
				filler: {
					propagate: !0
				}
			}
		});
		var rn = {
			dataset: function (t) {
				var e = t.fill,
					i = t.chart,
					n = i.getDatasetMeta(e),
					r = n && i.isDatasetVisible(e) && n.dataset._children || [],
					a = r.length || 0;
				return a ? function (t, e) {
					return e < a && r[e]._view || null
				} : null
			},
			boundary: function (t) {
				var e = t.boundary,
					i = e ? e.x : null,
					n = e ? e.y : null;
				return function (t) {
					return {
						x: null === i ? t.x : i,
						y: null === n ? t.y : n
					}
				}
			}
		};

		function an(t, e, i) {
			var n, r = t._model || {},
				a = r.fill;
			if (void 0 === a && (a = !!r.backgroundColor), !1 === a || null === a) return !1;
			if (!0 === a) return "origin";
			if (n = parseFloat(a, 10), isFinite(n) && Math.floor(n) === n) return "-" !== a[0] && "+" !== a[0] || (n = e + n), !(n === e || n < 0 || i <= n) && n;
			switch (a) {
				case "bottom":
					return "start";
				case "top":
					return "end";
				case "zero":
					return "origin";
				case "origin":
				case "start":
				case "end":
					return a;
				default:
					return !1
			}
		}

		function on(t) {
			var e, i = t.el._model || {},
				n = t.el._scale || {},
				r = t.fill,
				a = null;
			if (isFinite(r)) return null;
			if ("start" === r ? a = void 0 === i.scaleBottom ? n.bottom : i.scaleBottom : "end" === r ? a = void 0 === i.scaleTop ? n.top : i.scaleTop : void 0 !== i.scaleZero ? a = i.scaleZero : n.getBasePosition ? a = n.getBasePosition() : n.getBasePixel && (a = n.getBasePixel()), null != a) {
				if (void 0 !== a.x && void 0 !== a.y) return a;
				if (ht.isFinite(a)) return {
					x: (e = n.isHorizontal()) ? a : null,
					y: e ? null : a
				}
			}
			return null
		}

		function sn(t, e, i) {
			var n, r = t[e].fill,
				a = [e];
			if (!i) return r;
			for (; !1 !== r && -1 === a.indexOf(r);) {
				if (!isFinite(r)) return r;
				if (!(n = t[r])) return !1;
				if (n.visible) return r;
				a.push(r), r = n.fill
			}
			return !1
		}

		function ln(t) {
			return t && !t.skip
		}

		function hn(t, e, i, n, r) {
			var a;
			if (n && r) {
				for (t.moveTo(e[0].x, e[0].y), a = 1; a < n; ++a) ht.canvas.lineTo(t, e[a - 1], e[a]);
				for (t.lineTo(i[r - 1].x, i[r - 1].y), a = r - 1; 0 < a; --a) ht.canvas.lineTo(t, i[a], i[a - 1], !0)
			}
		}
		var un = {
				id: "filler",
				afterDatasetsUpdate: function (t, e) {
					var i, n, r, a, o, s, l, h = (t.data.datasets || []).length,
						u = e.propagate,
						d = [];
					for (n = 0; n < h; ++n) a = null, (r = (i = t.getDatasetMeta(n)).dataset) && r._model && r instanceof zt.Line && (a = {
						visible: t.isDatasetVisible(n),
						fill: an(r, n, h),
						chart: t,
						el: r
					}), i.$filler = a, d.push(a);
					for (n = 0; n < h; ++n)(a = d[n]) && (a.fill = sn(d, n, u), a.boundary = on(a), a.mapper = (l = void 0, s = (o = a).fill, !(l = "dataset") === s ? null : (isFinite(s) || (l = "boundary"), rn[l](o))))
				},
				beforeDatasetDraw: function (t, e) {
					var i = e.meta.$filler;
					if (i) {
						var n = t.ctx,
							r = i.el,
							a = r._view,
							o = r._children || [],
							s = i.mapper,
							l = a.backgroundColor || ot.global.defaultColor;
						s && l && o.length && (ht.canvas.clipArea(n, t.chartArea), function (t, e, i, n, r, a) {
							var o, s, l, h, u, d, c, f = e.length,
								p = n.spanGaps,
								g = [],
								m = [],
								v = 0,
								y = 0;
							for (t.beginPath(), o = 0, s = f + !!a; o < s; ++o) u = i(h = e[l = o % f]._view, l, n), d = ln(h), c = ln(u), d && c ? (v = g.push(h), y = m.push(u)) : v && y && (p ? (d && g.push(h), c && m.push(u)) : (hn(t, g, m, v, y), v = y = 0, g = [], m = []));
							hn(t, g, m, v, y), t.closePath(), t.fillStyle = r, t.fill()
						}(n, o, s, a, l, r._loop), ht.canvas.unclipArea(n))
					}
				}
			},
			dn = ht.noop,
			cn = ht.valueOrDefault;

		function fn(t, e) {
			return t.usePointStyle && t.boxWidth > e ? e : t.boxWidth
		}
		ot._set("global", {
			legend: {
				display: !0,
				position: "top",
				fullWidth: !0,
				reverse: !1,
				weight: 1e3,
				onClick: function (t, e) {
					var i = e.datasetIndex,
						n = this.chart,
						r = n.getDatasetMeta(i);
					r.hidden = null === r.hidden ? !n.data.datasets[i].hidden : null, n.update()
				},
				onHover: null,
				onLeave: null,
				labels: {
					boxWidth: 40,
					padding: 10,
					generateLabels: function (i) {
						var t = i.data;
						return ht.isArray(t.datasets) ? t.datasets.map(function (t, e) {
							return {
								text: t.label,
								fillStyle: ht.isArray(t.backgroundColor) ? t.backgroundColor[0] : t.backgroundColor,
								hidden: !i.isDatasetVisible(e),
								lineCap: t.borderCapStyle,
								lineDash: t.borderDash,
								lineDashOffset: t.borderDashOffset,
								lineJoin: t.borderJoinStyle,
								lineWidth: t.borderWidth,
								strokeStyle: t.borderColor,
								pointStyle: t.pointStyle,
								datasetIndex: e
							}
						}, this) : []
					}
				}
			},
			legendCallback: function (t) {
				var e = [];
				e.push('<ul class="' + t.id + '-legend">');
				for (var i = 0; i < t.data.datasets.length; i++) e.push('<li><span style="background-color:' + t.data.datasets[i].backgroundColor + '"></span>'), t.data.datasets[i].label && e.push(t.data.datasets[i].label), e.push("</li>");
				return e.push("</ul>"), e.join("")
			}
		});
		var pn = pt.extend({
			initialize: function (t) {
				ht.extend(this, t), this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1
			},
			beforeUpdate: dn,
			update: function (t, e, i) {
				var n = this;
				return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize
			},
			afterUpdate: dn,
			beforeSetDimensions: dn,
			setDimensions: function () {
				var t = this;
				t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {
					width: 0,
					height: 0
				}
			},
			afterSetDimensions: dn,
			beforeBuildLabels: dn,
			buildLabels: function () {
				var e = this,
					i = e.options.labels || {},
					t = ht.callback(i.generateLabels, [e.chart], e) || [];
				i.filter && (t = t.filter(function (t) {
					return i.filter(t, e.chart.data)
				})), e.options.reverse && t.reverse(), e.legendItems = t
			},
			afterBuildLabels: dn,
			beforeFit: dn,
			fit: function () {
				var t = this,
					e = t.options,
					n = e.labels,
					i = e.display,
					r = t.ctx,
					a = ht.options._parseFont(n),
					o = a.size,
					s = t.legendHitBoxes = [],
					l = t.minSize,
					h = t.isHorizontal();
				if (l.height = h ? (l.width = t.maxWidth, i ? 10 : 0) : (l.width = i ? 10 : 0, t.maxHeight), i)
					if (r.font = a.string, h) {
						var u = t.lineWidths = [0],
							d = 0;
						r.textAlign = "left", r.textBaseline = "top", ht.each(t.legendItems, function (t, e) {
							var i = fn(n, o) + o / 2 + r.measureText(t.text).width;
							(0 === e || u[u.length - 1] + i + n.padding > l.width) && (d += o + n.padding, u[u.length - (0 < e ? 0 : 1)] = n.padding), s[e] = {
								left: 0,
								top: 0,
								width: i,
								height: o
							}, u[u.length - 1] += i + n.padding
						}), l.height += d
					} else {
						var c = n.padding,
							f = t.columnWidths = [],
							p = n.padding,
							g = 0,
							m = 0,
							v = o + c;
						ht.each(t.legendItems, function (t, e) {
							var i = fn(n, o) + o / 2 + r.measureText(t.text).width;
							0 < e && m + v > l.height - c && (p += g + n.padding, f.push(g), m = g = 0), g = Math.max(g, i), m += v, s[e] = {
								left: 0,
								top: 0,
								width: i,
								height: o
							}
						}), p += g, f.push(g), l.width += p
					} t.width = l.width, t.height = l.height
			},
			afterFit: dn,
			isHorizontal: function () {
				return "top" === this.options.position || "bottom" === this.options.position
			},
			draw: function () {
				var d = this,
					c = d.options,
					f = c.labels,
					t = ot.global,
					p = t.defaultColor,
					g = t.elements.line,
					m = d.width,
					v = d.lineWidths;
				if (c.display) {
					var y, x = d.ctx,
						e = cn(f.fontColor, t.defaultFontColor),
						i = ht.options._parseFont(f),
						b = i.size;
					x.textAlign = "left", x.textBaseline = "middle", x.lineWidth = .5, x.strokeStyle = e, x.fillStyle = e, x.font = i.string;
					var _ = fn(f, b),
						w = d.legendHitBoxes,
						k = d.isHorizontal();
					y = k ? {
						x: d.left + (m - v[0]) / 2 + f.padding,
						y: d.top + f.padding,
						line: 0
					} : {
						x: d.left + f.padding,
						y: d.top + f.padding,
						line: 0
					};
					var M = b + f.padding;
					ht.each(d.legendItems, function (t, e) {
						var i, n, r, a, o, s = x.measureText(t.text).width,
							l = _ + b / 2 + s,
							h = y.x,
							u = y.y;
						k ? 0 < e && h + l + f.padding > d.left + d.minSize.width && (u = y.y += M, y.line++, h = y.x = d.left + (m - v[y.line]) / 2 + f.padding) : 0 < e && u + M > d.top + d.minSize.height && (h = y.x = h + d.columnWidths[y.line] + f.padding, u = y.y = d.top + f.padding, y.line++),
							function (t, e, i) {
								if (!(isNaN(_) || _ <= 0)) {
									x.save();
									var n = cn(i.lineWidth, g.borderWidth);
									if (x.fillStyle = cn(i.fillStyle, p), x.lineCap = cn(i.lineCap, g.borderCapStyle), x.lineDashOffset = cn(i.lineDashOffset, g.borderDashOffset), x.lineJoin = cn(i.lineJoin, g.borderJoinStyle), x.lineWidth = n, x.strokeStyle = cn(i.strokeStyle, p), x.setLineDash && x.setLineDash(cn(i.lineDash, g.borderDash)), c.labels && c.labels.usePointStyle) {
										var r = _ * Math.SQRT2 / 2,
											a = t + _ / 2,
											o = e + b / 2;
										ht.canvas.drawPoint(x, i.pointStyle, r, a, o)
									} else 0 !== n && x.strokeRect(t, e, _, b), x.fillRect(t, e, _, b);
									x.restore()
								}
							}(h, u, t), w[e].left = h, w[e].top = u, i = t, n = s, a = _ + (r = b / 2) + h, o = u + r, x.fillText(i.text, a, o), i.hidden && (x.beginPath(), x.lineWidth = 2, x.moveTo(a, o), x.lineTo(a + n, o), x.stroke()), k ? y.x += l + f.padding : y.y += M
					})
				}
			},
			_getLegendItemAt: function (t, e) {
				var i, n, r;
				if (t >= this.left && t <= this.right && e >= this.top && e <= this.bottom)
					for (r = this.legendHitBoxes, i = 0; i < r.length; ++i)
						if (t >= (n = r[i]).left && t <= n.left + n.width && e >= n.top && e <= n.top + n.height) return this.legendItems[i];
				return null
			},
			handleEvent: function (t) {
				var e, i = this.options,
					n = "mouseup" === t.type ? "click" : t.type;
				if ("mousemove" === n) {
					if (!i.onHover && !i.onLeave) return
				} else {
					if ("click" !== n) return;
					if (!i.onClick) return
				}
				e = this._getLegendItemAt(t.x, t.y), "click" === n ? e && i.onClick && i.onClick.call(this, t.native, e) : (i.onLeave && e !== this._hoveredItem && (this._hoveredItem && i.onLeave.call(this, t.native, this._hoveredItem), this._hoveredItem = e), i.onHover && e && i.onHover.call(this, t.native, e))
			}
		});

		function gn(t, e) {
			var i = new pn({
				ctx: t.ctx,
				options: e,
				chart: t
			});
			be.configure(t, i, e), be.addBox(t, i), t.legend = i
		}
		var mn = {
				id: "legend",
				_element: pn,
				beforeInit: function (t) {
					var e = t.options.legend;
					e && gn(t, e)
				},
				beforeUpdate: function (t) {
					var e = t.options.legend,
						i = t.legend;
					e ? (ht.mergeIf(e, ot.global.legend), i ? (be.configure(t, i, e), i.options = e) : gn(t, e)) : i && (be.removeBox(t, i), delete t.legend)
				},
				afterEvent: function (t, e) {
					var i = t.legend;
					i && i.handleEvent(e)
				}
			},
			vn = ht.noop;
		ot._set("global", {
			title: {
				display: !1,
				fontStyle: "bold",
				fullWidth: !0,
				padding: 10,
				position: "top",
				text: "",
				weight: 2e3
			}
		});
		var yn = pt.extend({
			initialize: function (t) {
				ht.extend(this, t), this.legendHitBoxes = []
			},
			beforeUpdate: vn,
			update: function (t, e, i) {
				var n = this;
				return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize
			},
			afterUpdate: vn,
			beforeSetDimensions: vn,
			setDimensions: function () {
				var t = this;
				t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {
					width: 0,
					height: 0
				}
			},
			afterSetDimensions: vn,
			beforeBuildLabels: vn,
			buildLabels: vn,
			afterBuildLabels: vn,
			beforeFit: vn,
			fit: function () {
				var t = this.options,
					e = t.display,
					i = this.minSize,
					n = ht.isArray(t.text) ? t.text.length : 1,
					r = ht.options._parseFont(t),
					a = e ? n * r.lineHeight + 2 * t.padding : 0;
				this.isHorizontal() ? (i.width = this.maxWidth, i.height = a) : (i.width = a, i.height = this.maxHeight), this.width = i.width, this.height = i.height
			},
			afterFit: vn,
			isHorizontal: function () {
				var t = this.options.position;
				return "top" === t || "bottom" === t
			},
			draw: function () {
				var t = this.ctx,
					e = this.options;
				if (e.display) {
					var i, n, r, a = ht.options._parseFont(e),
						o = a.lineHeight,
						s = o / 2 + e.padding,
						l = 0,
						h = this.top,
						u = this.left,
						d = this.bottom,
						c = this.right;
					t.fillStyle = ht.valueOrDefault(e.fontColor, ot.global.defaultFontColor), t.font = a.string, this.isHorizontal() ? (n = u + (c - u) / 2, r = h + s, i = c - u) : (n = "left" === e.position ? u + s : c - s, r = h + (d - h) / 2, i = d - h, l = Math.PI * ("left" === e.position ? -.5 : .5)), t.save(), t.translate(n, r), t.rotate(l), t.textAlign = "center", t.textBaseline = "middle";
					var f = e.text;
					if (ht.isArray(f))
						for (var p = 0, g = 0; g < f.length; ++g) t.fillText(f[g], 0, p, i), p += o;
					else t.fillText(f, 0, 0, i);
					t.restore()
				}
			}
		});

		function xn(t, e) {
			var i = new yn({
				ctx: t.ctx,
				options: e,
				chart: t
			});
			be.configure(t, i, e), be.addBox(t, i), t.titleBlock = i
		}
		var bn = {},
			_n = un,
			wn = mn,
			kn = {
				id: "title",
				_element: yn,
				beforeInit: function (t) {
					var e = t.options.title;
					e && xn(t, e)
				},
				beforeUpdate: function (t) {
					var e = t.options.title,
						i = t.titleBlock;
					e ? (ht.mergeIf(e, ot.global.title), i ? (be.configure(t, i, e), i.options = e) : xn(t, e)) : i && (be.removeBox(t, i), delete t.titleBlock)
				}
			};
		for (var Mn in bn.filler = _n, bn.legend = wn, bn.title = kn, ri.helpers = ht,
				function () {
					function u(t, e, i) {
						var n;
						return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n
					}

					function d(t) {
						return null != t && "none" !== t
					}

					function e(t, e, i) {
						var n = document.defaultView,
							r = ht._getParentNode(t),
							a = n.getComputedStyle(t)[e],
							o = n.getComputedStyle(r)[e],
							s = d(a),
							l = d(o),
							h = Number.POSITIVE_INFINITY;
						return s || l ? Math.min(s ? u(a, t, i) : h, l ? u(o, r, i) : h) : "none"
					}
					ht.where = function (t, e) {
						if (ht.isArray(t) && Array.prototype.filter) return t.filter(e);
						var i = [];
						return ht.each(t, function (t) {
							e(t) && i.push(t)
						}), i
					}, ht.findIndex = Array.prototype.findIndex ? function (t, e, i) {
						return t.findIndex(e, i)
					} : function (t, e, i) {
						i = void 0 === i ? t : i;
						for (var n = 0, r = t.length; n < r; ++n)
							if (e.call(i, t[n], n, t)) return n;
						return -1
					}, ht.findNextWhere = function (t, e, i) {
						ht.isNullOrUndef(i) && (i = -1);
						for (var n = i + 1; n < t.length; n++) {
							var r = t[n];
							if (e(r)) return r
						}
					}, ht.findPreviousWhere = function (t, e, i) {
						ht.isNullOrUndef(i) && (i = t.length);
						for (var n = i - 1; 0 <= n; n--) {
							var r = t[n];
							if (e(r)) return r
						}
					}, ht.isNumber = function (t) {
						return !isNaN(parseFloat(t)) && isFinite(t)
					}, ht.almostEquals = function (t, e, i) {
						return Math.abs(t - e) < i
					}, ht.almostWhole = function (t, e) {
						var i = Math.round(t);
						return i - e < t && t < i + e
					}, ht.max = function (t) {
						return t.reduce(function (t, e) {
							return isNaN(e) ? t : Math.max(t, e)
						}, Number.NEGATIVE_INFINITY)
					}, ht.min = function (t) {
						return t.reduce(function (t, e) {
							return isNaN(e) ? t : Math.min(t, e)
						}, Number.POSITIVE_INFINITY)
					}, ht.sign = Math.sign ? function (t) {
						return Math.sign(t)
					} : function (t) {
						return 0 == (t = +t) || isNaN(t) ? t : 0 < t ? 1 : -1
					}, ht.log10 = Math.log10 ? function (t) {
						return Math.log10(t)
					} : function (t) {
						var e = Math.log(t) * Math.LOG10E,
							i = Math.round(e);
						return t === Math.pow(10, i) ? i : e
					}, ht.toRadians = function (t) {
						return t * (Math.PI / 180)
					}, ht.toDegrees = function (t) {
						return t * (180 / Math.PI)
					}, ht._decimalPlaces = function (t) {
						if (ht.isFinite(t)) {
							for (var e = 1, i = 0; Math.round(t * e) / e !== t;) e *= 10, i++;
							return i
						}
					}, ht.getAngleFromPoint = function (t, e) {
						var i = e.x - t.x,
							n = e.y - t.y,
							r = Math.sqrt(i * i + n * n),
							a = Math.atan2(n, i);
						return a < -.5 * Math.PI && (a += 2 * Math.PI), {
							angle: a,
							distance: r
						}
					}, ht.distanceBetweenPoints = function (t, e) {
						return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
					}, ht.aliasPixel = function (t) {
						return t % 2 == 0 ? 0 : .5
					}, ht._alignPixel = function (t, e, i) {
						var n = t.currentDevicePixelRatio,
							r = i / 2;
						return Math.round((e - r) * n) / n + r
					}, ht.splineCurve = function (t, e, i, n) {
						var r = t.skip ? e : t,
							a = e,
							o = i.skip ? e : i,
							s = Math.sqrt(Math.pow(a.x - r.x, 2) + Math.pow(a.y - r.y, 2)),
							l = Math.sqrt(Math.pow(o.x - a.x, 2) + Math.pow(o.y - a.y, 2)),
							h = s / (s + l),
							u = l / (s + l),
							d = n * (h = isNaN(h) ? 0 : h),
							c = n * (u = isNaN(u) ? 0 : u);
						return {
							previous: {
								x: a.x - d * (o.x - r.x),
								y: a.y - d * (o.y - r.y)
							},
							next: {
								x: a.x + c * (o.x - r.x),
								y: a.y + c * (o.y - r.y)
							}
						}
					}, ht.EPSILON = Number.EPSILON || 1e-14, ht.splineCurveMonotone = function (t) {
						var e, i, n, r, a, o, s, l, h, u = (t || []).map(function (t) {
								return {
									model: t._model,
									deltaK: 0,
									mK: 0
								}
							}),
							d = u.length;
						for (e = 0; e < d; ++e)
							if (!(n = u[e]).model.skip) {
								if (i = 0 < e ? u[e - 1] : null, (r = e < d - 1 ? u[e + 1] : null) && !r.model.skip) {
									var c = r.model.x - n.model.x;
									n.deltaK = 0 !== c ? (r.model.y - n.model.y) / c : 0
								}!i || i.model.skip ? n.mK = n.deltaK : !r || r.model.skip ? n.mK = i.deltaK : this.sign(i.deltaK) !== this.sign(n.deltaK) ? n.mK = 0 : n.mK = (i.deltaK + n.deltaK) / 2
							} for (e = 0; e < d - 1; ++e) n = u[e], r = u[e + 1], n.model.skip || r.model.skip || (ht.almostEquals(n.deltaK, 0, this.EPSILON) ? n.mK = r.mK = 0 : (a = n.mK / n.deltaK, o = r.mK / n.deltaK, (l = Math.pow(a, 2) + Math.pow(o, 2)) <= 9 || (s = 3 / Math.sqrt(l), n.mK = a * s * n.deltaK, r.mK = o * s * n.deltaK)));
						for (e = 0; e < d; ++e)(n = u[e]).model.skip || (i = 0 < e ? u[e - 1] : null, r = e < d - 1 ? u[e + 1] : null, i && !i.model.skip && (h = (n.model.x - i.model.x) / 3, n.model.controlPointPreviousX = n.model.x - h, n.model.controlPointPreviousY = n.model.y - h * n.mK), r && !r.model.skip && (h = (r.model.x - n.model.x) / 3, n.model.controlPointNextX = n.model.x + h, n.model.controlPointNextY = n.model.y + h * n.mK))
					}, ht.nextItem = function (t, e, i) {
						return i ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1]
					}, ht.previousItem = function (t, e, i) {
						return i ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1]
					}, ht.niceNum = function (t, e) {
						var i = Math.floor(ht.log10(t)),
							n = t / Math.pow(10, i);
						return (e ? n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10 : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * Math.pow(10, i)
					}, ht.requestAnimFrame = "undefined" == typeof window ? function (t) {
						t()
					} : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {
						return window.setTimeout(t, 1e3 / 60)
					}, ht.getRelativePosition = function (t, e) {
						var i, n, r = t.originalEvent || t,
							a = t.target || t.srcElement,
							o = a.getBoundingClientRect(),
							s = r.touches;
						n = s && 0 < s.length ? (i = s[0].clientX, s[0].clientY) : (i = r.clientX, r.clientY);
						var l = parseFloat(ht.getStyle(a, "padding-left")),
							h = parseFloat(ht.getStyle(a, "padding-top")),
							u = parseFloat(ht.getStyle(a, "padding-right")),
							d = parseFloat(ht.getStyle(a, "padding-bottom")),
							c = o.right - o.left - l - u,
							f = o.bottom - o.top - h - d;
						return {
							x: i = Math.round((i - o.left - l) / c * a.width / e.currentDevicePixelRatio),
							y: n = Math.round((n - o.top - h) / f * a.height / e.currentDevicePixelRatio)
						}
					}, ht.getConstraintWidth = function (t) {
						return e(t, "max-width", "clientWidth")
					}, ht.getConstraintHeight = function (t) {
						return e(t, "max-height", "clientHeight")
					}, ht._calculatePadding = function (t, e, i) {
						return -1 < (e = ht.getStyle(t, e)).indexOf("%") ? i * parseInt(e, 10) / 100 : parseInt(e, 10)
					}, ht._getParentNode = function (t) {
						var e = t.parentNode;
						return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e
					}, ht.getMaximumWidth = function (t) {
						var e = ht._getParentNode(t);
						if (!e) return t.clientWidth;
						var i = e.clientWidth,
							n = i - ht._calculatePadding(e, "padding-left", i) - ht._calculatePadding(e, "padding-right", i),
							r = ht.getConstraintWidth(t);
						return isNaN(r) ? n : Math.min(n, r)
					}, ht.getMaximumHeight = function (t) {
						var e = ht._getParentNode(t);
						if (!e) return t.clientHeight;
						var i = e.clientHeight,
							n = i - ht._calculatePadding(e, "padding-top", i) - ht._calculatePadding(e, "padding-bottom", i),
							r = ht.getConstraintHeight(t);
						return isNaN(r) ? n : Math.min(n, r)
					}, ht.getStyle = function (t, e) {
						return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e)
					}, ht.retinaScale = function (t, e) {
						var i = t.currentDevicePixelRatio = e || "undefined" != typeof window && window.devicePixelRatio || 1;
						if (1 !== i) {
							var n = t.canvas,
								r = t.height,
								a = t.width;
							n.height = r * i, n.width = a * i, t.ctx.scale(i, i), n.style.height || n.style.width || (n.style.height = r + "px", n.style.width = a + "px")
						}
					}, ht.fontString = function (t, e, i) {
						return e + " " + t + "px " + i
					}, ht.longestText = function (e, t, i, n) {
						var r = (n = n || {}).data = n.data || {},
							a = n.garbageCollect = n.garbageCollect || [];
						n.font !== t && (r = n.data = {}, a = n.garbageCollect = [], n.font = t), e.font = t;
						var o = 0;
						ht.each(i, function (t) {
							null != t && !0 !== ht.isArray(t) ? o = ht.measureText(e, r, a, o, t) : ht.isArray(t) && ht.each(t, function (t) {
								null == t || ht.isArray(t) || (o = ht.measureText(e, r, a, o, t))
							})
						});
						var s = a.length / 2;
						if (s > i.length) {
							for (var l = 0; l < s; l++) delete r[a[l]];
							a.splice(0, s)
						}
						return o
					}, ht.measureText = function (t, e, i, n, r) {
						var a = e[r];
						return a || (a = e[r] = t.measureText(r).width, i.push(r)), n < a && (n = a), n
					}, ht.numberOfLabelLines = function (t) {
						var e = 1;
						return ht.each(t, function (t) {
							ht.isArray(t) && t.length > e && (e = t.length)
						}), e
					}, ht.color = G ? function (t) {
						return t instanceof CanvasGradient && (t = ot.global.defaultColor), G(t)
					} : function (t) {
						return console.error("Color.js not found!"), t
					}, ht.getHoverColor = function (t) {
						return t instanceof CanvasPattern || t instanceof CanvasGradient ? t : ht.color(t).saturate(.5).darken(.1).rgbString()
					}
				}(), ri._adapters = si, ri.Animation = mt, ri.animationService = vt, ri.controllers = he, ri.DatasetController = wt, ri.defaults = ot, ri.Element = pt, ri.elements = zt, ri.Interaction = me, ri.layouts = be, ri.platform = Ye, ri.plugins = Ee, ri.Scale = fi, ri.scaleService = He, ri.Ticks = li, ri.Tooltip = Ke, ri.helpers.each(tn, function (t, e) {
					ri.scaleService.registerScaleType(e, t, t._defaults)
				}), bn) bn.hasOwnProperty(Mn) && ri.plugins.register(bn[Mn]);
		ri.platform.initialize();
		var Sn = ri;
		return "undefined" != typeof window && (window.Chart = ri), (ri.Chart = ri).Legend = bn.legend._element, ri.Title = bn.title._element, ri.pluginService = ri.plugins, ri.PluginBase = ri.Element.extend({}), ri.canvasHelpers = ri.helpers.canvas, ri.layoutService = ri.layouts, ri.LinearScaleBase = yi, ri.helpers.each(["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"], function (i) {
			ri[i] = function (t, e) {
				return new ri(t, ri.helpers.merge(e || {}, {
					type: i.charAt(0).toLowerCase() + i.slice(1)
				}))
			}
		}), Sn
	}),
	function (t) {
		"function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery)
	}(function (u) {
		"use strict";
		var i = {},
			d = Math.max,
			c = Math.min;
		i.c = {}, i.c.d = u(document), i.c.t = function (t) {
			return t.originalEvent.touches.length - 1
		}, i.o = function () {
			var n = this;
			this.o = null, this.$ = null, this.i = null, this.g = null, this.v = null, this.cv = null, this.x = 0, this.y = 0, this.w = 0, this.h = 0, this.$c = null, this.c = null, this.t = 0, this.isInit = !1, this.fgColor = null, this.pColor = null, this.dH = null, this.cH = null, this.eH = null, this.rH = null, this.scale = 1, this.relative = !1, this.relativeWidth = !1, this.relativeHeight = !1, this.$div = null, this.run = function () {
				var t = function (t, e) {
					var i;
					for (i in e) n.o[i] = e[i];
					n._carve().init(), n._configure()._draw()
				};
				if (!this.$.data("kontroled")) {
					if (this.$.data("kontroled", !0), this.extend(), this.o = u.extend({
							min: void 0 !== this.$.data("min") ? this.$.data("min") : 0,
							max: void 0 !== this.$.data("max") ? this.$.data("max") : 100,
							stopper: !0,
							readOnly: this.$.data("readonly") || "readonly" === this.$.attr("readonly"),
							cursor: (!0 === this.$.data("cursor") ? 30 : this.$.data("cursor")) || 0,
							thickness: this.$.data("thickness") && Math.max(Math.min(this.$.data("thickness"), 1), .01) || .35,
							lineCap: this.$.data("linecap") || "butt",
							width: this.$.data("width") || 200,
							height: this.$.data("height") || 200,
							displayInput: null == this.$.data("displayinput") || this.$.data("displayinput"),
							displayPrevious: this.$.data("displayprevious"),
							fgColor: this.$.data("fgcolor") || "#87CEEB",
							inputColor: this.$.data("inputcolor"),
							font: this.$.data("font") || "Shabnam",
							fontWeight: this.$.data("font-weight") || "bold",
							inline: !1,
							step: this.$.data("step") || 1,
							rotation: this.$.data("rotation"),
							draw: null,
							change: null,
							cancel: null,
							release: null,
							format: function (t) {
								return t
							},
							parse: function (t) {
								return parseFloat(t)
							}
						}, this.o), this.o.flip = "anticlockwise" === this.o.rotation || "acw" === this.o.rotation, this.o.inputColor || (this.o.inputColor = this.o.fgColor), this.$.is("fieldset") ? (this.v = {}, this.i = this.$.find("input"), this.i.each(function (e) {
							var i = u(this);
							n.i[e] = i, n.v[e] = n.o.parse(i.val()), i.bind("change blur", function () {
								var t = {};
								t[e] = i.val(), n.val(n._validate(t))
							})
						}), this.$.find("legend").remove()) : (this.i = this.$, this.v = this.o.parse(this.$.val()), "" === this.v && (this.v = this.o.min), this.$.bind("change blur", function () {
							n.val(n._validate(n.o.parse(n.$.val())))
						})), !this.o.displayInput && this.$.hide(), this.$c = u(document.createElement("canvas")).attr({
							width: this.o.width,
							height: this.o.height
						}), this.$div = u('<div style="' + (this.o.inline ? "display:inline;" : "") + "width:" + this.o.width + "px;height:" + this.o.height + 'px;"></div>'), this.$.wrap(this.$div).before(this.$c), this.$div = this.$.parent(), "undefined" != typeof G_vmlCanvasManager && G_vmlCanvasManager.initElement(this.$c[0]), this.c = this.$c[0].getContext ? this.$c[0].getContext("2d") : null, !this.c) throw {
						name: "CanvasNotSupportedException",
						message: "Canvas not supported. Please use excanvas on IE8.0.",
						toString: function () {
							return this.name + ": " + this.message
						}
					};
					return this.scale = (window.devicePixelRatio || 1) / (this.c.webkitBackingStorePixelRatio || this.c.mozBackingStorePixelRatio || this.c.msBackingStorePixelRatio || this.c.oBackingStorePixelRatio || this.c.backingStorePixelRatio || 1), this.relativeWidth = this.o.width % 1 != 0 && this.o.width.indexOf("%"), this.relativeHeight = this.o.height % 1 != 0 && this.o.height.indexOf("%"), this.relative = this.relativeWidth || this.relativeHeight, this._carve(), this.v instanceof Object ? (this.cv = {}, this.copy(this.v, this.cv)) : this.cv = this.v, this.$.bind("configure", t).parent().bind("configure", t), this._listen()._configure()._xy().init(), this.isInit = !0, this.$.val(this.o.format(this.v)), this._draw(), this
				}
			}, this._carve = function () {
				if (this.relative) {
					var t = this.relativeWidth ? this.$div.parent().width() * parseInt(this.o.width) / 100 : this.$div.parent().width(),
						e = this.relativeHeight ? this.$div.parent().height() * parseInt(this.o.height) / 100 : this.$div.parent().height();
					this.w = this.h = Math.min(t, e)
				} else this.w = this.o.width, this.h = this.o.height;
				return this.$div.css({
					width: this.w + "px",
					height: this.h + "px"
				}), this.$c.attr({
					width: this.w,
					height: this.h
				}), 1 !== this.scale && (this.$c[0].width = this.$c[0].width * this.scale, this.$c[0].height = this.$c[0].height * this.scale, this.$c.width(this.w), this.$c.height(this.h)), this
			}, this._draw = function () {
				var t = !0;
				n.g = n.c, n.clear(), n.dH && (t = n.dH()), !1 !== t && n.draw()
			}, this._touch = function (t) {
				var e = function (t) {
					var e = n.xy2val(t.originalEvent.touches[n.t].pageX, t.originalEvent.touches[n.t].pageY);
					e != n.cv && (n.cH && !1 === n.cH(e) || (n.change(n._validate(e)), n._draw()))
				};
				return this.t = i.c.t(t), e(t), i.c.d.bind("touchmove.k", e).bind("touchend.k", function () {
					i.c.d.unbind("touchmove.k touchend.k"), n.val(n.cv)
				}), this
			}, this._mouse = function (t) {
				var e = function (t) {
					var e = n.xy2val(t.pageX, t.pageY);
					e != n.cv && (n.cH && !1 === n.cH(e) || (n.change(n._validate(e)), n._draw()))
				};
				return e(t), i.c.d.bind("mousemove.k", e).bind("keyup.k", function (t) {
					if (27 === t.keyCode) {
						if (i.c.d.unbind("mouseup.k mousemove.k keyup.k"), n.eH && !1 === n.eH()) return;
						n.cancel()
					}
				}).bind("mouseup.k", function (t) {
					i.c.d.unbind("mousemove.k mouseup.k keyup.k"), n.val(n.cv)
				}), this
			}, this._xy = function () {
				var t = this.$c.offset();
				return this.x = t.left, this.y = t.top, this
			}, this._listen = function () {
				return this.o.readOnly ? this.$.attr("readonly", "readonly") : (this.$c.bind("mousedown", function (t) {
					t.preventDefault(), n._xy()._mouse(t)
				}).bind("touchstart", function (t) {
					t.preventDefault(), n._xy()._touch(t)
				}), this.listen()), this.relative && u(window).resize(function () {
					n._carve().init(), n._draw()
				}), this
			}, this._configure = function () {
				return this.o.draw && (this.dH = this.o.draw), this.o.change && (this.cH = this.o.change), this.o.cancel && (this.eH = this.o.cancel), this.o.release && (this.rH = this.o.release), this.o.displayPrevious ? (this.pColor = this.h2rgba(this.o.fgColor, "0.4"), this.fgColor = this.h2rgba(this.o.fgColor, "0.6")) : this.fgColor = this.o.fgColor, this
			}, this._clear = function () {
				this.$c[0].width = this.$c[0].width
			}, this._validate = function (t) {
				var e = ~~((t < 0 ? -.5 : .5) + t / this.o.step) * this.o.step;
				return Math.round(100 * e) / 100
			}, this.listen = function () {}, this.extend = function () {}, this.init = function () {}, this.change = function (t) {}, this.val = function (t) {}, this.xy2val = function (t, e) {}, this.draw = function () {}, this.clear = function () {
				this._clear()
			}, this.h2rgba = function (t, e) {
				var i;
				return t = t.substring(1, 7), "rgba(" + (i = [parseInt(t.substring(0, 2), 16), parseInt(t.substring(2, 4), 16), parseInt(t.substring(4, 6), 16)])[0] + "," + i[1] + "," + i[2] + "," + e + ")"
			}, this.copy = function (t, e) {
				for (var i in t) e[i] = t[i]
			}
		}, i.Dial = function () {
			i.o.call(this), this.startAngle = null, this.xy = null, this.radius = null, this.lineWidth = null, this.cursorExt = null, this.w2 = null, this.PI2 = 2 * Math.PI, this.extend = function () {
				this.o = u.extend({
					bgColor: this.$.data("bgcolor") || "#EEEEEE",
					angleOffset: this.$.data("angleoffset") || 0,
					angleArc: this.$.data("anglearc") || 360,
					inline: !0
				}, this.o)
			}, this.val = function (t, e) {
				if (null == t) return this.v;
				t = this.o.parse(t), !1 !== e && t != this.v && this.rH && !1 === this.rH(t) || (this.cv = this.o.stopper ? d(c(t, this.o.max), this.o.min) : t, this.v = this.cv, this.$.val(this.o.format(this.v)), this._draw())
			}, this.xy2val = function (t, e) {
				var i, n;
				return i = Math.atan2(t - (this.x + this.w2), -(e - this.y - this.w2)) - this.angleOffset, this.o.flip && (i = this.angleArc - i - this.PI2), this.angleArc != this.PI2 && i < 0 && -.5 < i ? i = 0 : i < 0 && (i += this.PI2), n = i * (this.o.max - this.o.min) / this.angleArc + this.o.min, this.o.stopper && (n = d(c(n, this.o.max), this.o.min)), n
			}, this.listen = function () {
				var a, o, n, r, s = this,
					t = function (t) {
						t.preventDefault();
						var e = t.originalEvent,
							i = e.detail || e.wheelDeltaX,
							n = e.detail || e.wheelDeltaY,
							r = s._validate(s.o.parse(s.$.val())) + (0 < i || 0 < n ? s.o.step : i < 0 || n < 0 ? -s.o.step : 0);
						r = d(c(r, s.o.max), s.o.min), s.val(r, !1), s.rH && (clearTimeout(a), a = setTimeout(function () {
							s.rH(r), a = null
						}, 100), o || (o = setTimeout(function () {
							a && s.rH(r), o = null
						}, 200)))
					},
					l = 1,
					h = {
						37: -s.o.step,
						38: s.o.step,
						39: s.o.step,
						40: -s.o.step
					};
				this.$.bind("keydown", function (t) {
					var e = t.keyCode;
					if (96 <= e && e <= 105 && (e = t.keyCode = e - 48), n = parseInt(String.fromCharCode(e)), isNaN(n) && (13 !== e && 8 !== e && 9 !== e && 189 !== e && (190 !== e || s.$.val().match(/\./)) && t.preventDefault(), -1 < u.inArray(e, [37, 38, 39, 40]))) {
						t.preventDefault();
						var i = s.o.parse(s.$.val()) + h[e] * l;
						s.o.stopper && (i = d(c(i, s.o.max), s.o.min)), s.change(s._validate(i)), s._draw(), r = window.setTimeout(function () {
							l *= 2
						}, 30)
					}
				}).bind("keyup", function (t) {
					isNaN(n) ? r && (window.clearTimeout(r), r = null, l = 1, s.val(s.$.val())) : s.$.val() > s.o.max && s.$.val(s.o.max) || s.$.val() < s.o.min && s.$.val(s.o.min)
				}), this.$c.bind("mousewheel DOMMouseScroll", t), this.$.bind("mousewheel DOMMouseScroll", t)
			}, this.init = function () {
				(this.v < this.o.min || this.v > this.o.max) && (this.v = this.o.min), this.$.val(this.v), this.w2 = this.w / 2, this.cursorExt = this.o.cursor / 100, this.xy = this.w2 * this.scale, this.lineWidth = this.xy * this.o.thickness, this.lineCap = this.o.lineCap, this.radius = this.xy - this.lineWidth / 2, this.o.angleOffset && (this.o.angleOffset = isNaN(this.o.angleOffset) ? 0 : this.o.angleOffset), this.o.angleArc && (this.o.angleArc = isNaN(this.o.angleArc) ? this.PI2 : this.o.angleArc), this.angleOffset = this.o.angleOffset * Math.PI / 180, this.angleArc = this.o.angleArc * Math.PI / 180, this.startAngle = 1.5 * Math.PI + this.angleOffset, this.endAngle = 1.5 * Math.PI + this.angleOffset + this.angleArc;
				var t = d(String(Math.abs(this.o.max)).length, String(Math.abs(this.o.min)).length, 2) + 2;
				this.o.displayInput && this.i.css({
					width: (this.w / 2 + 4 >> 0) + "px",
					height: (this.w / 3 >> 0) + "px",
					position: "absolute",
					"vertical-align": "middle",
					"margin-top": (this.w / 3 >> 0) + "px",
					"margin-left": "-" + (3 * this.w / 4 + 2 >> 0) + "px",
					border: 0,
					background: "none",
					font: this.o.fontWeight + " " + (this.w / t >> 0) + "px " + this.o.font,
					"text-align": "center",
					color: this.o.inputColor || this.o.fgColor,
					padding: "0px",
					"-webkit-appearance": "none"
				}) || this.i.css({
					width: "0px",
					visibility: "hidden"
				})
			}, this.change = function (t) {
				this.cv = t, this.$.val(this.o.format(t))
			}, this.angle = function (t) {
				return (t - this.o.min) * this.angleArc / (this.o.max - this.o.min)
			}, this.arc = function (t) {
				var e, i;
				return t = this.angle(t), i = this.o.flip ? (e = this.endAngle + 1e-5) - t - 1e-5 : (e = this.startAngle - 1e-5) + t + 1e-5, this.o.cursor && (e = i - this.cursorExt) && (i += this.cursorExt), {
					s: e,
					e: i,
					d: this.o.flip && !this.o.cursor
				}
			}, this.draw = function () {
				var t, e = this.g,
					i = this.arc(this.cv),
					n = 1;
				e.lineWidth = this.lineWidth, e.lineCap = this.lineCap, "none" !== this.o.bgColor && (e.beginPath(), e.strokeStyle = this.o.bgColor, e.arc(this.xy, this.xy, this.radius, this.endAngle - 1e-5, this.startAngle + 1e-5, !0), e.stroke()), this.o.displayPrevious && (t = this.arc(this.v), e.beginPath(), e.strokeStyle = this.pColor, e.arc(this.xy, this.xy, this.radius, t.s, t.e, t.d), e.stroke(), n = this.cv == this.v), e.beginPath(), e.strokeStyle = n ? this.o.fgColor : this.fgColor, e.arc(this.xy, this.xy, this.radius, i.s, i.e, i.d), e.stroke()
			}, this.cancel = function () {
				this.val(this.v)
			}
		}, u.fn.dial = u.fn.knob = function (e) {
			return this.each(function () {
				var t = new i.Dial;
				t.o = e, t.$ = u(this), t.run()
			}).parent()
		}
	});
